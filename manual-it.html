<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="A backup program for disk arrays. It stores parity information of your data and it recovers from up to six disk failures">
<meta name="keywords" content="snapraid snapshot raid backup disk array redundancy parity">
<meta name="author" content="Andrea Mazzoleni">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="stylesheet" type="text/css" href="style.css">
<title>SnapRAID</title>

<!-- Google Analytics 4 -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W1Z5FKHYQ4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-W1Z5FKHYQ4');
</script>

<!-- Google Universal Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<div id="header">
<img src="index.jpg" width="1200" height="150" alt="Title">
</div>
<div id="menu">
<a href="/">About</a>
<a href="download">Download</a>
<a href="design">Design</a>
<a href="compare">Compare</a>
<a href="faq">FAQ</a>
<a href="manual">Manual</a>
<a href="support">Support</a>
<a href="authors">Authors</a>
</div>
<div id="main">



<p>
Italian manual for <span class="bold">SnapRAID</span>.
</p>

<h2><a name="1">1</a> 
Sinossi
</h2>
<pre>
snapraid [-c, --conf CONFIG]
&nbsp;&nbsp;&nbsp;&nbsp;[-f, --filter PATTERN] [-d, --filter-disk NAME]
&nbsp;&nbsp;&nbsp;&nbsp;[-m, --filter-missing] [-e, --filter-error]
&nbsp;&nbsp;&nbsp;&nbsp;[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR]
&nbsp;&nbsp;&nbsp;&nbsp;[-p, --plan PERC|bad|new|full]
&nbsp;&nbsp;&nbsp;&nbsp;[-o, --older-than DAYS] [-l, --log FILE]
&nbsp;&nbsp;&nbsp;&nbsp;[-s, --spin-down-on-error] [-w, --bw-limit RATE]
&nbsp;&nbsp;&nbsp;&nbsp;[-Z, --force-zero] [-E, --force-empty]
&nbsp;&nbsp;&nbsp;&nbsp;[-U, --force-uuid] [-D, --force-device]
&nbsp;&nbsp;&nbsp;&nbsp;[-N, --force-nocopy] [-F, --force-full]
&nbsp;&nbsp;&nbsp;&nbsp;[-R, --force-realloc]
&nbsp;&nbsp;&nbsp;&nbsp;[-S, --start BLKSTART] [-B, --count BLKCOUNT]
&nbsp;&nbsp;&nbsp;&nbsp;[-L, --error-limit NUMBER]
&nbsp;&nbsp;&nbsp;&nbsp;[-A, --stats]
&nbsp;&nbsp;&nbsp;&nbsp;[-v, --verbose] [-q, --quiet]
&nbsp;&nbsp;&nbsp;&nbsp;status|smart|probe|up|down|diff|sync|scrub|fix|check
&nbsp;&nbsp;&nbsp;&nbsp;|list|dup|pool|devices|touch|rehash
</pre>
<p>
<pre>
snapraid [-V, --version] [-H, --help] [-C, --gen-conf CONTENT]
</pre>
<h2><a name="2">2</a> 
Descrizione
</h2>
SnapRAID è un programma di backup progettato per array di dischi, che
memorizza informazioni di parità per il recupero dati in caso di guasto
fino a sei dischi.
<p>
Destinato principalmente a centri multimediali domestici con file grandi
e che cambiano raramente, SnapRAID offre diverse funzionalità:
<ul>
<li>
È possibile utilizzare dischi già pieni di file senza la necessità
di riformattarli, accedendovi come al solito.
</li>
<li>
Tutti i dati sono sottoposti ad hashing per garantire l'integrità dei
dati e prevenire la corruzione silente.
</li>
<li>
Quando il numero di dischi guasti supera il conteggio di parità,
la perdita di dati è confinata ai dischi interessati; i dati sugli
altri dischi rimangono accessibili.
</li>
<li>
Se si eliminano accidentalmente dei file su un disco, il recupero
è possibile.
</li>
<li>
I dischi possono avere dimensioni diverse.
</li>
<li>
È possibile aggiungere dischi in qualsiasi momento.
</li>
<li>
SnapRAID non blocca i dati; è possibile smettere di usarlo in qualsiasi
momento senza riformattare o spostare i dati.
</li>
<li>
Per accedere a un file, è necessario far girare solo un singolo disco,
risparmiando energia e riducendo il rumore.
</li>
</ul>
<p>
Per maggiori informazioni, si prega di visitare il sito ufficiale SnapRAID:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.snapraid.it/
</pre>
</td></tr></table>
<h2><a name="3">3</a> 
Limitazioni
</h2>
SnapRAID è un ibrido tra un programma RAID e un programma di backup,
che mira a combinare i migliori vantaggi di entrambi. Tuttavia, ha
alcune limitazioni che si dovrebbero considerare prima di usarlo.
<p>
La limitazione principale è che se un disco si guasta e non si è
effettuato un sync di recente, potrebbe non essere possibile recuperare
completamente.
Più specificamente, potrebbe non essere possibile recuperare fino alla
dimensione dei file modificati o eliminati dall'ultima operazione di sync.
Ciò accade anche se i file modificati o eliminati non si trovano sul
disco guasto. Questo è il motivo per cui SnapRAID è più adatto per dati
che cambiano raramente.
<p>
D'altra parte, i file appena aggiunti non impediscono il recupero dei
file già esistenti. Si perderanno solo i file aggiunti di recente se si
trovano sul disco guasto.
<p>
Altre limitazioni di SnapRAID sono:
<ul>
<li>
Con SnapRAID, si hanno ancora file system separati per ogni disco.
Con RAID, si ottiene un unico grande file system.
</li>
<li>
SnapRAID non esegue lo striping dei dati.
Con RAID, si ottiene un aumento di velocità con lo striping.
</li>
<li>
SnapRAID non supporta il recupero in tempo reale.
Con RAID, non si deve smettere di lavorare quando un disco si guasta.
</li>
<li>
SnapRAID può recuperare i dati solo da un numero limitato di guasti
del disco.
Con un backup, è possibile recuperare da un guasto completo
dell'intero array di dischi.
</li>
<li>
Vengono salvati solo nomi di file, timestamp, symlink e hardlink.
Permessi, proprietà e attributi estesi non vengono salvati.
</li>
</ul>
<h2><a name="4">4</a> 
Iniziare
</h2>
Per usare SnapRAID, è necessario prima selezionare un disco nell'array
di dischi da dedicare alle informazioni di `parity` (parità). Con un
disco per la parità, si sarà in grado di recuperare da un singolo guasto
del disco, in modo simile a RAID5.
<p>
Se si desidera recuperare da più guasti del disco, in modo simile a RAID6,
è necessario riservare dischi aggiuntivi per la parità. Ogni disco di
parità aggiuntivo consente il recupero da un guasto in più del disco.
<p>
Come dischi di parità, è necessario scegliere i dischi più grandi
dell'array, poiché le informazioni di parità possono crescere fino alle
dimensioni del più grande disco dati nell'array.
<p>
Questi dischi saranno dedicati alla memorizzazione dei file di `parity`.
Non si dovrebbero memorizzare i propri dati su di essi.
<p>
Quindi, è necessario definire i dischi `data` (dati) che si desidera
proteggere con SnapRAID. La protezione è più efficace se questi dischi
contengono dati che cambiano raramente. Per questo motivo, è meglio
NON includere il disco C:\ di Windows o le directory Unix /home, /var,
e /tmp.
<p>
L'elenco dei file viene salvato nei file `content` (contenuto), di solito
memorizzati sui dischi dati, di parità o di avvio.
Questo file contiene i dettagli del backup, inclusi tutti i checksum
per verificarne l'integrità.
Il file `content` viene memorizzato in più copie e ogni copia deve
essere su un disco diverso per garantire che, anche in caso di guasti
multipli del disco, sia disponibile almeno una copia.
<p>
Ad esempio, supponiamo di essere interessati a un solo livello di
protezione con parità e che i dischi si trovino in:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
/mnt/diskp &lt;- disco selezionato per la parità
/mnt/disk1 &lt;- primo disco da proteggere
/mnt/disk2 &lt;- secondo disco da proteggere
/mnt/disk3 &lt;- terzo disco da proteggere
</pre>
</td></tr></table>
<p>
È necessario creare il file di configurazione /etc/snapraid.conf con
le seguenti opzioni:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity /mnt/diskp/snapraid.parity
content /var/snapraid/snapraid.content
content /mnt/disk1/snapraid.content
content /mnt/disk2/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
</pre>
</td></tr></table>
<p>
Se si è su Windows, si dovrebbe usare il formato del percorso di Windows,
con lettere di unità e backslash invece di slash.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity E:\snapraid.parity
content C:\snapraid\snapraid.content
content F:\array\snapraid.content
content G:\array\snapraid.content
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
</pre>
</td></tr></table>
<p>
Se si hanno molti dischi e si esauriscono le lettere di unità, è
possibile montare i dischi direttamente nelle sottocartelle. Vedi:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.google.com/search?q=Windows+mount+point
</pre>
</td></tr></table>
<p>
A questo punto, si è pronti per eseguire il comando `sync` per costruire
le informazioni di parità.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid sync
</pre>
</td></tr></table>
<p>
Questo processo può richiedere diverse ore la prima volta, a seconda
delle dimensioni dei dati già presenti sui dischi. Se i dischi sono
vuoti, il processo è immediato.
<p>
È possibile interromperlo in qualsiasi momento premendo Ctrl+C e, alla
prossima esecuzione, riprenderà da dove è stato interrotto.
<p>
Quando questo comando è completato, i dati sono SICURI.
<p>
Ora è possibile iniziare a usare l'array come si desidera e aggiornare
periodicamente le informazioni di parità eseguendo il comando `sync`.
<h3><a name="4.1">4.1</a> 
Scrubbing
</h3>
Per controllare periodicamente i dati e la parità per gli errori, è
possibile eseguire il comando `scrub`.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid scrub
</pre>
</td></tr></table>
<p>
Questo comando confronta i dati nell'array con l'hash calcolato
durante il comando `sync` per verificarne l'integrità.
<p>
Ogni esecuzione del comando controlla circa l'8% dell'array, escludendo
i dati già sottoposti a scrub nei 10 giorni precedenti.
È possibile utilizzare l'opzione -p, --plan per specificare un importo
diverso e l'opzione -o, --older-than per specificare un'età diversa
in giorni.
Ad esempio, per controllare il 5% dell'array per blocchi più vecchi di
20 giorni, usare:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -p 5 -o 20 scrub
</pre>
</td></tr></table>
<p>
Se vengono trovati errori silenti o di input/output durante il processo,
i blocchi corrispondenti vengono contrassegnati come bad (cattivi) nel
file `content` ed elencati nel comando `status`.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid status
</pre>
</td></tr></table>
<p>
Per correggerli, è possibile utilizzare il comando `fix`, filtrando
i blocchi bad con l'opzione -e, --filter-error:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -e fix
</pre>
</td></tr></table>
<p>
Al prossimo `scrub`, gli errori scompariranno dal report `status`
se sono stati veramente corretti. Per renderlo più veloce, è possibile
utilizzare -p bad per eseguire lo scrub solo dei blocchi contrassegnati
come bad.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -p bad scrub
</pre>
</td></tr></table>
<p>
L'esecuzione di `scrub` su un array non sincronizzato può riportare
errori causati da file rimossi o modificati. Questi errori sono riportati
nell'output di `scrub`, ma i blocchi correlati non sono contrassegnati
come bad.
<h3><a name="4.2">4.2</a> 
Pooling
</h3>
Nota: La funzionalità di pooling descritta di seguito è stata
sostituita dallo strumento mergefs, che è ora l'opzione consigliata
per gli utenti Linux nella comunità SnapRAID. Mergefs fornisce un modo
più flessibile ed efficiente per raggruppare più unità in un singolo
punto di montaggio unificato, consentendo un accesso trasparente ai
file attraverso l'array senza fare affidamento sui collegamenti
simbolici. Si integra bene con SnapRAID per la protezione della parità
ed è comunemente usato in configurazioni come OpenMediaVault (OMV) o
NAS personalizzati.
<p>
Per avere tutti i file nell'array mostrati nello stesso albero di
directory, è possibile abilitare la funzionalità di `pooling`. Crea
una vista virtuale di sola lettura di tutti i file nell'array
utilizzando collegamenti simbolici.
<p>
È possibile configurare la directory di `pooling` nel file di
configurazione con:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
pool /pool
</pre>
</td></tr></table>
<p>
o, se si è su Windows, con:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
pool C:\pool
</pre>
</td></tr></table>
<p>
e quindi eseguire il comando `pool` per creare o aggiornare la
vista virtuale.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid pool
</pre>
</td></tr></table>
<p>
Se si sta utilizzando una piattaforma Unix e si desidera condividere
questa directory sulla rete con macchine Windows o Unix, è necessario
aggiungere le seguenti opzioni al file /etc/samba/smb.conf:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Nella sezione globale di smb.conf
unix extensions = no
</pre>
</td></tr></table>
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Nella sezione di condivisione di smb.conf
[pool]
comment = Pool
path = /pool
read only = yes
guest ok = yes
wide links = yes
follow symlinks = yes
</pre>
</td></tr></table>
<p>
In Windows, la condivisione di collegamenti simbolici su una rete
richiede che i client li risolvano da remoto. Per abilitare questo, oltre
a condividere la directory pool, è necessario condividere anche tutti i
dischi in modo indipendente, utilizzando i nomi dei dischi definiti nel
file di configurazione come punti di condivisione. È inoltre necessario
specificare nell'opzione `share` del file di configurazione il percorso
UNC di Windows che i client remoti devono utilizzare per accedere a
questi dischi condivisi.
<p>
Ad esempio, operando da un server chiamato `darkstar`, è possibile
utilizzare le opzioni:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
pool C:\pool
share \\darkstar
</pre>
</td></tr></table>
<p>
e condividere le seguenti directory sulla rete:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
\\darkstar\pool -&gt; C:\pool
\\darkstar\d1 -&gt; F:\array
\\darkstar\d2 -&gt; G:\array
\\darkstar\d3 -&gt; H:\array
</pre>
</td></tr></table>
<p>
per consentire ai client remoti di accedere a tutti i file in
\\darkstar\pool.
<p>
Potrebbe anche essere necessario configurare i client remoti per
abilitare l'accesso ai symlink remoti con il comando:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
fsutil behavior set SymlinkEvaluation L2L:1 R2R:1 L2R:1 R2L:1
</pre>
</td></tr></table>
<h3><a name="4.3">4.3</a> 
Annullamento Eliminazione
</h3>
SnapRAID funziona più come un programma di backup che come un sistema RAID
e può essere utilizzato per ripristinare o annullare l'eliminazione dei
file al loro stato precedente utilizzando l'opzione -f, --filter:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -f FILE
</pre>
</td></tr></table>
<p>
o per una directory:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -f DIR/
</pre>
</td></tr></table>
<p>
È anche possibile usarlo per recuperare solo i file eliminati
accidentalmente all'interno di una directory utilizzando l'opzione -m,
--filter-missing, che ripristina solo i file mancanti, lasciando tutti
gli altri intatti.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -m -f DIR/
</pre>
</td></tr></table>
<p>
O per recuperare tutti i file eliminati su tutte le unità con:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -m
</pre>
</td></tr></table>
<h3><a name="4.4">4.4</a> 
Recupero
</h3>
È successo il peggio e si è perso uno o più dischi!
<p>
NON FARSI PRENDERE DAL PANICO! Sarà possibile recuperarli!
<p>
La prima cosa da fare è evitare ulteriori modifiche all'array di dischi.
Disabilitare qualsiasi connessione remota ad esso e qualsiasi processo
pianificato, incluso qualsiasi sync o scrub notturno pianificato di SnapRAID.
<p>
Quindi procedere con i seguenti passaggi.
<h4><a name="4.4.1">4.4.1</a> 
PASSO 1 -&gt; Riconfigurazione
</h4>
È necessario un po' di spazio per recuperare, idealmente su dischi di
riserva aggiuntivi, ma un disco USB esterno o un disco remoto saranno
sufficienti.
<p>
Modificare il file di configurazione SnapRAID per far puntare l'opzione
`data` o `parity` del disco guasto a una posizione con spazio vuoto
sufficiente per recuperare i file.
<p>
Ad esempio, se il disco `d1` è guasto, cambiare da:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 /mnt/disk1/
</pre>
</td></tr></table>
<p>
a:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 /mnt/new_spare_disk/
</pre>
</td></tr></table>
<p>
Se il disco da recuperare è un disco di parità, aggiornare l'opzione
`parity` appropriata.
Se si hanno più dischi guasti, aggiornare tutte le loro opzioni di
configurazione.
<h4><a name="4.4.2">4.4.2</a> 
PASSO 2 -&gt; Correzione (Fix)
</h4>
Eseguire il comando fix, memorizzando il log in un file esterno con:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -d NAME -l fix.log fix
</pre>
</td></tr></table>
<p>
Dove NAME è il nome del disco, come `d1` nel nostro esempio precedente.
Se il disco da recuperare è un disco di parità, usare i nomi `parity`,
`2-parity`, ecc.
Se si hanno più dischi guasti, usare più opzioni -d per specificarli tutti.
<p>
Questo comando richiederà molto tempo.
<p>
Assicurarsi di avere alcuni gigabyte liberi per memorizzare il file
fix.log. Eseguirlo da un disco con spazio libero sufficiente.
<p>
Ora si è recuperato tutto ciò che è recuperabile. Se alcuni file sono
parzialmente o totalmente irrecuperabili, verranno rinominati aggiungendo
l'estensione `.unrecoverable`.
<p>
È possibile trovare un elenco dettagliato di tutti i blocchi
irrecuperabili nel file fix.log controllando tutte le righe che iniziano
con `unrecoverable:`.
<p>
Se non si è soddisfatti del recupero, è possibile riprovare tutte le
volte che si desidera.
<p>
Ad esempio, se si sono rimossi file dall'array dopo l'ultimo `sync`,
questo può comportare che alcuni file non vengano recuperati.
In questo caso, è possibile riprovare il `fix` usando l'opzione -i,
--import, specificando dove si trovano ora questi file per includerli
di nuovo nel processo di recupero.
<p>
Se si è soddisfatti del recupero, è possibile procedere oltre,
ma notare che dopo la sincronizzazione, non è più possibile riprovare
il comando `fix`!
<h4><a name="4.4.3">4.4.3</a> 
PASSO 3 -&gt; Controllo (Check)
</h4>
Come controllo cauto, è ora possibile eseguire un comando `check` per
assicurarsi che tutto sia corretto sul disco recuperato.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -d NAME -a check
</pre>
</td></tr></table>
<p>
Dove NAME è il nome del disco, come `d1` nel nostro esempio precedente.
<p>
Le opzioni -d e -a dicono a SnapRAID di controllare solo il disco
specificato e di ignorare tutti i dati di parità.
<p>
Questo comando richiederà molto tempo, ma se non si è eccessivamente
cauti, è possibile saltarlo.
<h4><a name="4.4.4">4.4.4</a> 
PASSO 4 -&gt; Sincronizzazione (Sync)
</h4>
Eseguire il comando `sync` per risincronizzare l'array con il nuovo disco.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid sync
</pre>
</td></tr></table>
<p>
Se tutto è recuperato, questo comando è immediato.
<h2><a name="5">5</a> 
Comandi
</h2>
SnapRAID fornisce alcuni semplici comandi che consentono di:
<ul>
<li>
Stampare lo stato dell'array -&gt; `status`
</li>
<li>
Controllare i dischi -&gt; `smart`, `probe`, `up`, `down`
</li>
<li>
Effettuare un backup/snapshot -&gt; `sync`
</li>
<li>
Controllare periodicamente i dati -&gt; `scrub`
</li>
<li>
Ripristinare l'ultimo backup/snapshot -&gt; `fix`.
</li>
</ul>
<p>
I comandi devono essere scritti in minuscolo.
<h3><a name="5.1">5.1</a> 
status
</h3>
Stampa un riepilogo dello stato dell'array di dischi.
<p>
Include informazioni sulla frammentazione della parità, quanto sono
vecchi i blocchi senza essere controllati e tutti gli errori silenti
registrati incontrati durante lo scrubbing.
<p>
Le informazioni presentate si riferiscono all'ultima volta che si è
eseguito `sync`. Le modifiche successive non vengono prese in
considerazione.
<p>
Se sono stati rilevati blocchi bad, vengono elencati i loro numeri
di blocco. Per correggerli, è possibile utilizzare il comando `fix -e`.
<p>
Mostra anche un grafico che rappresenta l'ultima volta che ogni blocco
è stato sottoposto a scrub o sincronizzato. I blocchi sottoposti a scrub
sono mostrati con '*', i blocchi sincronizzati ma non ancora sottoposti
a scrub con 'o'.
<p>
Nulla viene modificato.
<h3><a name="5.2">5.2</a> 
smart
</h3>
Stampa un report SMART di tutti i dischi nel sistema.
<p>
Include una stima della probabilità di guasto nel prossimo anno,
consentendo di pianificare sostituzioni di manutenzione di dischi
che mostrano attributi sospetti.
<p>
Questa stima della probabilità è ottenuta correlando gli attributi
SMART dei dischi con i dati Backblaze disponibili all'indirizzo:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.backblaze.com/hard-drive-test-data.html
</pre>
</td></tr></table>
<p>
Se SMART segnala che un disco sta per guastarsi, viene stampato `FAIL`
o `PREFAIL` per quel disco e SnapRAID restituisce un errore.
In questo caso, si raccomanda vivamente la sostituzione immediata del
disco.
<p>
Altre possibili stringhe di stato sono:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
logfail
</em></td><td width="90%">
In passato, alcuni attributi erano inferiori alla
soglia.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
logerr
</em></td><td width="90%">
Il log degli errori del dispositivo contiene errori.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
selferr
</em></td><td width="90%">
Il log dell'autotest del dispositivo contiene errori.
</td></tr>
</table>
<p>
Se viene specificata l'opzione -v, --verbose, viene fornita un'analisi
statistica più approfondita. Questa analisi può aiutare a decidere se
è necessaria più o meno parità.
<p>
Questo comando utilizza lo strumento `smartctl` ed è equivalente
all'esecuzione di `smartctl -a` su tutti i dispositivi.
<p>
Se i dispositivi non vengono rilevati automaticamente correttamente, è
possibile specificare un comando personalizzato utilizzando l'opzione
`smartctl` nel file di configurazione.
<p>
Nulla viene modificato.
<h3><a name="5.3">5.3</a> 
probe
</h3>
Stampa lo stato POWER di tutti i dischi nel sistema.
<p>
`Standby` significa che il disco non sta girando. `Active` significa
che il disco sta girando.
<p>
Questo comando utilizza lo strumento `smartctl` ed è equivalente
all'esecuzione di `smartctl -n standby -i` su tutti i dispositivi.
<p>
Se i dispositivi non vengono rilevati automaticamente correttamente, è
possibile specificare un comando personalizzato utilizzando l'opzione
`smartctl` nel file di configurazione.
<p>
Nulla viene modificato.
<h3><a name="5.4">5.4</a> 
up
</h3>
Fa girare tutti i dischi dell'array.
<p>
È possibile far girare solo dischi specifici utilizzando l'opzione -d,
--filter-disk.
<p>
Far girare tutti i dischi contemporaneamente richiede molta energia.
Assicurarsi che l'alimentatore possa sostenerlo.
<p>
Nulla viene modificato.
<h3><a name="5.5">5.5</a> 
down
</h3>
Ferma tutti i dischi dell'array.
<p>
Questo comando utilizza lo strumento `smartctl` ed è equivalente
all'esecuzione di `smartctl -s standby,now` su tutti i dispositivi.
<p>
È possibile fermare solo dischi specifici utilizzando l'opzione -d,
--filter-disk.
<p>
Per fermare automaticamente in caso di errore, è possibile utilizzare
l'opzione -s, --spin-down-on-error con qualsiasi altro comando,
che è equivalente all'esecuzione manuale di `down` quando si verifica
un errore.
<p>
Nulla viene modificato.
<h3><a name="5.6">5.6</a> 
diff
</h3>
Elenca tutti i file modificati dall'ultimo `sync` che devono avere i
loro dati di parità ricalcolati.
<p>
Questo comando non controlla i dati del file, ma solo il timestamp
del file, le dimensioni e l'inode.
<p>
Dopo aver elencato tutti i file modificati, viene presentato un
riepilogo delle modifiche, raggruppate per:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
equal
</em></td><td width="90%">
File invariati rispetto a prima.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
added
</em></td><td width="90%">
File aggiunti che non erano presenti prima.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
removed
</em></td><td width="90%">
File rimossi.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
updated
</em></td><td width="90%">
File con dimensioni o timestamp diversi, il che
significa che sono stati modificati.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
moved
</em></td><td width="90%">
File spostati in una directory diversa sullo stesso
disco. Sono identificati dall'avere lo stesso nome,
dimensioni, timestamp e inode, ma una directory diversa.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
copied
</em></td><td width="90%">
File copiati sullo stesso o su un disco diverso.
Si noti che se sono stati veramente spostati su un altro
disco, saranno contati anche in `removed`.
Sono identificati dall'avere lo stesso nome, dimensioni
e timestamp. Se il timestamp sotto il secondo è zero,
il percorso completo deve corrispondere, non solo il nome.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
restored
</em></td><td width="90%">
File con un inode diverso ma nome, dimensioni e
timestamp corrispondenti. Questi sono di solito file
ripristinati dopo essere stati eliminati.
</td></tr>
</table>
<p>
Se è richiesto un `sync`, il codice di ritorno del processo è 2,
invece del predefinito 0. Il codice di ritorno 1 è utilizzato per una
condizione di errore generica.
<p>
Nulla viene modificato.
<h3><a name="5.7">5.7</a> 
sync
</h3>
Aggiorna le informazioni di parità. Tutti i file modificati
nell'array di dischi vengono letti e i dati di parità
corrispondenti vengono aggiornati.
<p>
È possibile interrompere questo processo in qualsiasi momento
premendo Ctrl+C, senza perdere il lavoro già svolto.
Alla prossima esecuzione, il processo `sync` riprenderà da dove
è stato interrotto.
<p>
Se vengono trovati errori silenti o di input/output durante il processo,
i blocchi corrispondenti vengono contrassegnati come bad.
<p>
I file sono identificati dal percorso e/o dall'inode e controllati
per dimensione e timestamp.
Se la dimensione o il timestamp del file differiscono, i dati di parità
vengono ricalcolati per l'intero file.
Se il file viene spostato o rinominato sullo stesso disco,
mantenendo lo stesso inode, la parità non viene ricalcolata.
Se il file viene spostato su un altro disco, la parità viene ricalcolata,
ma le informazioni di hash precedentemente calcolate vengono mantenute.
<p>
I file `content` e `parity` vengono modificati se necessario.
I file nell'array NON vengono modificati.
<h3><a name="5.8">5.8</a> 
scrub
</h3>
Esegue lo scrub dell'array, controllando la presenza di errori silenti
o di input/output nei dischi dati e di parità.
<p>
Ogni invocazione controlla circa l'8% dell'array, escludendo
i dati già sottoposti a scrub negli ultimi 10 giorni.
Ciò significa che eseguire lo scrubbing una volta alla settimana
garantisce che ogni bit di dati venga controllato almeno una volta
ogni tre mesi.
<p>
È possibile definire un piano o una quantità di scrub diversa
utilizzando l'opzione -p, --plan, che accetta:
bad - Esegue lo scrub dei blocchi contrassegnati come bad.
new - Esegue lo scrub dei blocchi appena sincronizzati non ancora
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
sottoposti a scrub.
</td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
full
</em></td><td width="90%">
Esegue lo scrub di tutto.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
0-100
</em></td><td width="90%">
Esegue lo scrub della percentuale specificata di blocchi.
</td></tr>
</table>
<p>
Se si specifica una quantità percentuale, è anche possibile utilizzare
l'opzione -o, --older-than per definire quanto deve essere vecchio
il blocco.
I blocchi più vecchi vengono sottoposti a scrub per primi,
garantendo un controllo ottimale.
Se si desidera eseguire lo scrub solo dei blocchi appena sincronizzati
non ancora sottoposti a scrub, utilizzare l'opzione `-p new`.
<p>
Per ottenere i dettagli dello stato dello scrub, utilizzare il comando
`status`.
<p>
Per qualsiasi errore silente o di input/output trovato, i blocchi
corrispondenti vengono contrassegnati come bad nel file `content`.
Questi blocchi bad sono elencati in `status` e possono essere corretti
con `fix -e`.
Dopo la correzione, al prossimo scrub, verranno ricontrollati e, se
trovati corretti, il contrassegno bad verrà rimosso.
Per eseguire lo scrub solo dei blocchi bad, è possibile utilizzare
il comando `scrub -p bad`.
<p>
Si consiglia di eseguire `scrub` solo su un array sincronizzato per
evitare errori segnalati causati da dati non sincronizzati. Questi
errori sono riconosciuti come non essendo errori silenti e i blocchi non
vengono contrassegnati come bad, ma tali errori sono riportati
nell'output del comando.
<p>
Il file `content` viene modificato per aggiornare l'ora dell'ultimo
controllo per ogni blocco e per contrassegnare i blocchi bad.
I file `parity` NON vengono modificati.
I file nell'array NON vengono modificati.
<h3><a name="5.9">5.9</a> 
fix
</h3>
Corregge tutti i file e i dati di parità.
<p>
Tutti i file e i dati di parità vengono confrontati con lo stato
snapshot salvato nell'ultimo `sync`.
Se viene trovata una differenza, viene ripristinata allo snapshot
memorizzato.
<p>
ATTENZIONE! Il comando `fix` non differenzia tra errori e modifiche
intenzionali. Ripristina incondizionatamente lo stato del file
all'ultimo `sync`.
<p>
Se non viene specificata nessun'altra opzione, l'intero array viene
elaborato. Utilizzare le opzioni di filtro per selezionare un
sottoinsieme di file o dischi su cui operare.
<p>
Per correggere solo i blocchi contrassegnati come bad durante `sync`
e `scrub`, utilizzare l'opzione -e, --filter-error.
A differenza di altre opzioni di filtro, questa applica correzioni solo
ai file che sono invariati dall'ultimo `sync`.
<p>
SnapRAID rinomina tutti i file che non possono essere corretti aggiungendo
l'estensione `.unrecoverable`.
<p>
Prima di correggere, l'intero array viene scansionato per trovare
eventuali file spostati dall'ultima operazione di `sync`.
Questi file sono identificati dal loro timestamp, ignorando il loro nome
e la directory, e vengono utilizzati nel processo di recupero se
necessario.
Se alcuni di essi sono stati spostati al di fuori dell'array, è possibile
utilizzare l'opzione -i, --import per specificare directory aggiuntive
da scansionare.
<p>
I file sono identificati solo dal percorso, non dall'inode.
<p>
Il file `content` NON viene modificato.
I file `parity` vengono modificati se necessario.
I file nell'array vengono modificati se necessario.
<h3><a name="5.10">5.10</a> 
check
</h3>
Verifica tutti i file e i dati di parità.
<p>
Funziona come `fix`, ma simula solo un recupero e nessuna modifica
viene scritta nell'array.
<p>
Questo comando è destinato principalmente alla verifica manuale,
ad esempio dopo un processo di recupero o in altre condizioni speciali.
Per i controlli periodici e pianificati, utilizzare `scrub`.
<p>
Se si utilizza l'opzione -a, --audit-only, viene controllato solo
l'hash dei file e i dati di parità vengono ignorati per un'esecuzione
più veloce.
<p>
I file sono identificati solo dal percorso, non dall'inode.
<p>
Nulla viene modificato.
<h3><a name="5.11">5.11</a> 
list
</h3>
Elenca tutti i file contenuti nell'array al momento dell'ultimo
`sync`.
<p>
Con -v o --verbose, viene mostrato anche il tempo sotto il secondo.
<p>
Nulla viene modificato.
<h3><a name="5.12">5.12</a> 
dup
</h3>
Elenca tutti i file duplicati. Due file sono considerati uguali se i
loro hash corrispondono. I dati del file non vengono letti; vengono
utilizzati solo gli hash precalcolati.
<p>
Nulla viene modificato.
<h3><a name="5.13">5.13</a> 
pool
</h3>
Crea o aggiorna una vista virtuale di tutti
i file nell'array di dischi nella directory di `pooling`.
<p>
I file non vengono copiati ma collegati utilizzando
collegamenti simbolici.
<p>
Durante l'aggiornamento, tutti i collegamenti simbolici esistenti
e le sottodirectory vuote vengono eliminati e sostituiti con la nuova
vista dell'array. Qualsiasi altro file regolare viene lasciato al suo posto.
<p>
Nulla viene modificato al di fuori della directory pool.
<h3><a name="5.14">5.14</a> 
devices
</h3>
Stampa i dispositivi di basso livello utilizzati dall'array.
<p>
Questo comando visualizza le associazioni dei dispositivi nell'array
ed è principalmente destinato come interfaccia script.
<p>
Le prime due colonne sono l'ID e il percorso del dispositivo di basso
livello. Le due colonne successive sono l'ID e il percorso del dispositivo
di alto livello. L'ultima colonna è il nome del disco nell'array.
<p>
Nella maggior parte dei casi, si ha un dispositivo di basso livello per
ogni disco nell'array, ma in alcune configurazioni più complesse, si
potrebbe avere più dispositivi di basso livello utilizzati da un singolo
disco nell'array.
<p>
Nulla viene modificato.
<h3><a name="5.15">5.15</a> 
touch
</h3>
Imposta un timestamp arbitrario sotto il secondo per tutti i file
che lo hanno impostato a zero.
<p>
Questo migliora la capacità di SnapRAID di riconoscere i file
spostati e copiati, poiché rende il timestamp quasi unico,
riducendo possibili duplicati.
<p>
Più specificamente, se il timestamp sotto il secondo non è zero,
un file spostato o copiato viene identificato come tale se corrisponde
al nome, alle dimensioni e al timestamp. Se il timestamp sotto il secondo
è zero, è considerato una copia solo se il percorso completo,
le dimensioni e il timestamp corrispondono tutti.
<p>
Il timestamp di precisione al secondo non viene modificato,
quindi tutte le date e gli orari dei file saranno conservati.
<h3><a name="5.16">5.16</a> 
rehash
</h3>
Pianifica un rehash dell'intero array.
<p>
Questo comando cambia il tipo di hash utilizzato, in genere quando
si esegue l'aggiornamento da un sistema a 32 bit a uno a 64 bit, per
passare da MurmurHash3 al più veloce SpookyHash.
<p>
Se si sta già utilizzando l'hash ottimale, questo comando non fa
nulla e informa che non è necessaria alcuna azione.
<p>
Il rehash non viene eseguito immediatamente ma avviene
progressivamente durante `sync` e `scrub`.
<p>
È possibile controllare lo stato del rehash utilizzando `status`.
<p>
Durante il rehash, SnapRAID mantiene la piena funzionalità,
con l'unica eccezione che `dup` non è in grado di rilevare file
duplicati utilizzando un hash diverso.
<h2><a name="6">6</a> 
Opzioni
</h2>
SnapRAID fornisce le seguenti opzioni:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-c, --conf CONFIG
</strong></td></tr><tr><td>
Seleziona il file di configurazione da utilizzare. Se non
specificato, in Unix utilizza il file `/usr/local/etc/snapraid.conf`
se esiste, altrimenti `/etc/snapraid.conf`.
In Windows, utilizza il file `snapraid.conf` nella stessa
directory di `snapraid.exe`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-f, --filter PATTERN
</strong></td></tr><tr><td>
Filtra i file da elaborare in `check` e `fix`.
Vengono elaborati solo i file che corrispondono al modello
specificato.
Questa opzione può essere utilizzata più volte.
Vedere la sezione PATTERN per maggiori dettagli sulle
specifiche del modello.
In Unix, assicurarsi che i caratteri di globbing siano citati
se usati.
Questa opzione può essere utilizzata solo con `check` e `fix`.
Non può essere utilizzata con `sync` e `scrub`, poiché elaborano
sempre l'intero array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-d, --filter-disk NAME
</strong></td></tr><tr><td>
Filtra i dischi da elaborare in `check`, `fix`, `up` e `down`.
È necessario specificare un nome di disco come definito nel file
di configurazione.
È anche possibile specificare i dischi di parità con i nomi:
`parity`, `2-parity`, `3-parity`, ecc., per limitare le operazioni
a un disco di parità specifico.
Se si combinano più opzioni --filter, --filter-disk e
--filter-missing, vengono selezionati solo i file che corrispondono
a tutti i filtri.
Questa opzione può essere utilizzata più volte.
Questa opzione può essere utilizzata solo con `check`, `fix`,
`up` e `down`.
Non può essere utilizzata con `sync` e `scrub`, poiché elaborano
sempre l'intero array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-m, --filter-missing
</strong></td></tr><tr><td>
Filtra i file da elaborare in `check` e `fix`.
Vengono elaborati solo i file mancanti o eliminati dall'array.
Quando usato con `fix`, questo agisce come un comando di
`undelete` (annullamento eliminazione).
Se si combinano più opzioni --filter, --filter-disk e
--filter-missing, vengono selezionati solo i file che corrispondono
a tutti i filtri.
Questa opzione può essere utilizzata solo con `check` e `fix`.
Non può essere utilizzata con `sync` e `scrub`, poiché elaborano
sempre l'intero array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-e, --filter-error
</strong></td></tr><tr><td>
Elabora i file con errori in `check` e `fix`.
Elabora solo i file che hanno blocchi contrassegnati con errori
silenti o di input/output durante `sync` e `scrub`, come
elencato in `status`.
Questa opzione può essere utilizzata solo con `check` e `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-p, --plan PERC|bad|new|full
</strong></td></tr><tr><td>
Seleziona il piano di scrub. Se PERC è un valore numerico da 0 a
100, viene interpretato come la percentuale di blocchi da
sottoporre a scrub.
Invece di una percentuale, è possibile specificare un piano:
`bad` esegue lo scrub dei blocchi bad, `new` esegue lo scrub
dei blocchi non ancora sottoposti a scrub, e `full` esegue lo
scrub di tutto.
Questa opzione può essere utilizzata solo con `scrub`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-o, --older-than DAYS
</strong></td></tr><tr><td>
Seleziona la parte più vecchia dell'array da elaborare in `scrub`.
DAYS è l'età minima in giorni per un blocco da sottoporre a
scrub; il valore predefinito è 10.
I blocchi contrassegnati come bad vengono sempre sottoposti a scrub
indipendentemente da questa opzione.
Questa opzione può essere utilizzata solo con `scrub`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-a, --audit-only
</strong></td></tr><tr><td>
In `check`, verifica l'hash dei file senza
controllare i dati di parità.
Se si è interessati solo al controllo dei dati del file, questa
opzione può velocizzare significativamente il processo di controllo.
Questa opzione può essere utilizzata solo con `check`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-h, --pre-hash
</strong></td></tr><tr><td>
In `sync`, esegue una fase preliminare di hashing di tutti i nuovi
dati per una verifica aggiuntiva prima del calcolo della parità.
Di solito, in `sync`, non viene eseguito alcun hashing preliminare
e i nuovi dati vengono sottoposti a hash subito prima del calcolo
della parità quando vengono letti per la prima volta.
Questo processo si verifica quando il sistema è sotto
carico pesante, con tutti i dischi che girano e una CPU occupata.
Questa è una condizione estrema per la macchina e, se presenta un
problema hardware latente, gli errori silenti potrebbero non
essere rilevati perché i dati non sono ancora stati sottoposti a hash.
Per evitare questo rischio, è possibile abilitare la modalità
`pre-hash` per far leggere tutti i dati due volte per garantirne
l'integrità.
Questa opzione verifica anche i file spostati all'interno dell'array
per garantire che l'operazione di spostamento sia andata a buon fine
e, se necessario, consente di eseguire un'operazione di fix
prima di procedere.
Questa opzione può essere utilizzata solo con `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-i, --import DIR
</strong></td></tr><tr><td>
Importa dalla directory specificata tutti i file eliminati
dall'array dopo l'ultimo `sync`.
Se si hanno ancora tali file, possono essere utilizzati da `check`
e `fix` per migliorare il processo di recupero.
I file vengono letti, anche nelle sottodirectory, e sono
identificati indipendentemente dal loro nome.
Questa opzione può essere utilizzata solo con `check` e `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-s, --spin-down-on-error
</strong></td></tr><tr><td>
In caso di errore, ferma (spin down) tutti i dischi gestiti prima
di uscire con un codice di stato non zero. Ciò impedisce alle unità
di rimanere attive e in rotazione dopo un'operazione interrotta,
contribuendo a evitare inutili accumuli di calore e consumo di
energia. Utilizzare questa opzione per garantire che i dischi siano
arrestati in modo sicuro anche in caso di errore di un comando.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-w, --bw-limit RATE
</strong></td></tr><tr><td>
Applica un limite di larghezza di banda globale per tutti i dischi.
RATE è il numero di byte al secondo. È possibile specificare un
moltiplicatore come K, M o G (ad esempio, --bw-limit 1G).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-A, --stats
</strong></td></tr><tr><td>
Abilita una vista dello stato estesa che mostra informazioni
aggiuntive. La schermata visualizza due grafici:
Il primo grafico mostra il numero di stripe bufferizzate per
ciascun disco, insieme al percorso del file attualmente
acceduto su quel disco. In genere, il disco più lento non avrà
buffer disponibile, il che determina la larghezza di banda massima
raggiungibile.
Il secondo grafico mostra la percentuale di tempo trascorso in
attesa negli ultimi 100 secondi. Si prevede che il disco più
lento causi la maggior parte del tempo di attesa, mentre gli altri
dischi dovrebbero avere poco o nessun tempo di attesa perché possono
utilizzare le loro stripe bufferizzate.
Questo grafico mostra anche il tempo trascorso in attesa per
i calcoli di hash e i calcoli RAID.
Tutti i calcoli vengono eseguiti in parallelo con le operazioni
su disco. Pertanto, finché c'è un tempo di attesa misurabile per
almeno un disco, ciò indica che la CPU è abbastanza veloce da
tenere il passo con il carico di lavoro.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-Z, --force-zero
</strong></td></tr><tr><td>
Forza l'operazione non sicura di sincronizzazione di un file con
dimensione zero che in precedenza era non zero.
Se SnapRAID rileva una tale condizione, interrompe la
prosecuzione a meno che non si specifichi questa opzione.
Ciò consente di rilevare facilmente quando, dopo un arresto
anomalo del sistema, alcuni file a cui si è acceduto sono stati
troncati.
Questa è una possibile condizione in Linux con i file system
ext3/ext4.
Questa opzione può essere utilizzata solo con `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-E, --force-empty
</strong></td></tr><tr><td>
Forza l'operazione non sicura di sincronizzazione di un disco con
tutti i file originali mancanti.
Se SnapRAID rileva che tutti i file originariamente presenti
sul disco sono mancanti o riscritti, interrompe la prosecuzione
a meno che non si specifichi questa opzione.
Ciò consente di rilevare facilmente quando un file system di dati
non è montato.
Questa opzione può essere utilizzata solo con `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-U, --force-uuid
</strong></td></tr><tr><td>
Forza l'operazione non sicura di sincronizzazione, controllo e
correzione con dischi che hanno cambiato il loro UUID.
Se SnapRAID rileva che alcuni dischi hanno cambiato UUID,
interrompe la prosecuzione a meno che non si specifichi questa
opzione.
Ciò consente di rilevare quando i dischi sono montati sui punti
di montaggio sbagliati.
Tuttavia, è consentito avere un singolo cambio di UUID con
parità singola e di più con parità multipla, perché questo è
il caso normale quando si sostituiscono i dischi dopo un recupero.
Questa opzione può essere utilizzata solo con `sync`, `check`
o `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-D, --force-device
</strong></td></tr><tr><td>
Forza l'operazione non sicura di correzione con dischi inaccessibili
o con dischi sullo stesso dispositivo fisico.
Ad esempio, se si sono persi due dischi dati e si ha un disco di
riserva per recuperare solo il primo, è possibile ignorare il secondo
disco inaccessibile.
Oppure, se si desidera recuperare un disco nello spazio libero
rimasto su un disco già utilizzato, condividendo lo stesso dispositivo
fisico.
Questa opzione può essere utilizzata solo con `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-N, --force-nocopy
</strong></td></tr><tr><td>
In `sync`, `check` e `fix`, disabilita l'euristica di rilevamento
della copia.
Senza questa opzione, SnapRAID presume che i file con gli stessi
attributi, come nome, dimensione e timestamp, siano copie con gli
stessi dati.
Ciò consente l'identificazione di file copiati o spostati da un
disco all'altro e riutilizza le informazioni di hash già calcolate
per rilevare errori silenti o per recuperare file mancanti.
In alcuni rari casi, questo comportamento può comportare falsi
positivi o un processo lento a causa di molte verifiche di hash,
e questa opzione consente di risolvere tali problemi.
Questa opzione può essere utilizzata solo con `sync`, `check`
e `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-F, --force-full
</strong></td></tr><tr><td>
In `sync`, forza un ricalcolo completo della parità.
Questa opzione può essere utilizzata quando si aggiunge un nuovo
livello di parità o se si è tornati a un vecchio file di contenuto
utilizzando dati di parità più recenti.
Invece di ricreare la parità da zero, questo consente di riutilizzare
gli hash presenti nel file di contenuto per convalidare i dati e
mantenere la protezione dei dati durante il processo `sync`
utilizzando i dati di parità esistenti.
Questa opzione può essere utilizzata solo con `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-R, --force-realloc
</strong></td></tr><tr><td>
In `sync`, forza una riallocazione completa dei file e la
ricostruzione della parità.
Questa opzione può essere utilizzata per riallocare completamente
tutti i file, rimuovendo la frammentazione, riutilizzando gli hash
presenti nel file di contenuto per convalidare i dati.
Questa opzione può essere utilizzata solo con `sync`.
ATTENZIONE! Questa opzione è solo per esperti ed è vivamente
sconsigliato utilizzarla.
NON si ha protezione dei dati durante l'operazione `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-l, --log FILE
</strong></td></tr><tr><td>
Scrive un log dettagliato nel file specificato.
Se questa opzione non è specificata, gli errori imprevisti vengono
stampati sullo schermo, potenzialmente resulting in un output
eccessivo in caso di molti errori. Quando -l, --log è specificato,
vengono stampati sullo schermo solo gli errori fatali che
causano l'arresto di SnapRAID.
Se il percorso inizia con '&gt;&gt;', il file viene aperto in modalità
append. Le occorrenze di '%D' e '%T' nel nome vengono sostituite
con la data e l'ora nel formato YYYYMMDD e HHMMSS. Nei file batch
di Windows, è necessario raddoppiare il carattere '%', ad esempio
result-%%D.log. Per utilizzare '&gt;&gt;', è necessario racchiudere
il nome tra virgolette, ad esempio `"&gt;&gt;result.log"`.
Per indirizzare l'output del log all'output standard o all'errore
standard, è possibile utilizzare `"&gt;&amp;1"` e `"&gt;&amp;2"`,
rispettivamente.
Vedere il file snapraid_log.txt o la pagina man per le descrizioni
dei tag di log.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-L, --error-limit NUMBER
</strong></td></tr><tr><td>
Imposta un nuovo limite di errore prima di interrompere l'esecuzione.
Per impostazione predefinita, SnapRAID si interrompe se incontra
più di 100 errori di input/output, indicando che un disco
sta probabilmente fallendo.
Questa opzione influisce su `sync` e `scrub`, a cui è consentito
continuare dopo il primo set di errori del disco per cercare di
completare le loro operazioni.
Tuttavia, `check` e `fix` si interrompono sempre al primo errore.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-S, --start BLKSTART
</strong></td></tr><tr><td>
Avvia l'elaborazione dal numero di blocco specificato.
Ciò può essere utile per riprovare a controllare o correggere
blocchi specifici in caso di disco danneggiato.
Questa opzione è principalmente per il recupero manuale avanzato.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-B, --count BLKCOUNT
</strong></td></tr><tr><td>
Elabora solo il numero specificato di blocchi.
Questa opzione è principalmente per il recupero manuale avanzato.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-C, --gen-conf CONTENT
</strong></td></tr><tr><td>
Genera un file di configurazione fittizio da un file di contenuto
esistente.
Il file di configurazione viene scritto nell'output standard e non
sovrascrive uno esistente.
Questo file di configurazione contiene anche le informazioni
necessarie per ricostruire i punti di montaggio del disco nel caso
in cui si perda l'intero sistema.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-v, --verbose
</strong></td></tr><tr><td>
Stampa più informazioni sullo schermo.
Se specificato una volta, stampa i file esclusi
e statistiche aggiuntive.
Questa opzione non ha effetto sui file di log.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-q, --quiet
</strong></td></tr><tr><td>
Stampa meno informazioni sullo schermo.
Se specificato una volta, rimuove la barra di avanzamento;
due volte, le operazioni in corso; tre volte, i messaggi di
informazione; quattro volte, i messaggi di stato.
Gli errori fatali vengono sempre stampati sullo schermo.
Questa opzione non ha effetto sui file di log.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-H, --help
</strong></td></tr><tr><td>
Stampa una breve schermata di aiuto.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-V, --version
</strong></td></tr><tr><td>
Stampa la versione del programma.
</td></tr>
</table>
<h2><a name="7">7</a> 
Configurazione
</h2>
SnapRAID richiede un file di configurazione per sapere dove si trova
l'array di dischi e dove memorizzare le informazioni di parità.
<p>
In Unix, utilizza il file `/usr/local/etc/snapraid.conf` se esiste,
altrimenti `/etc/snapraid.conf`.
In Windows, utilizza il file `snapraid.conf` nella stessa
directory di `snapraid.exe`.
<p>
Deve contenere le seguenti opzioni (sensibili al maiuscolo/minuscolo):
<h3><a name="7.1">7.1</a> 
parity FILE [,FILE] ...
</h3>
Definisce i file da utilizzare per memorizzare le informazioni di parità.
La parità consente la protezione da un singolo guasto del disco,
simile a RAID5.
<p>
È possibile specificare più file, che devono essere su dischi diversi.
Quando un file non può più crescere, viene utilizzato il successivo.
Lo spazio totale disponibile deve essere almeno grande quanto il disco
dati più grande dell'array.
<p>
È possibile aggiungere file di parità aggiuntivi in seguito, ma non è
possibile riordinarli o rimuoverli.
<p>
Mantenere i dischi di parità riservati alla parità garantisce che non
diventino frammentati, migliorando le prestazioni.
<p>
In Windows, 256 MB vengono lasciati inutilizzati su ogni disco per
evitare l'avviso sui dischi pieni.
<p>
Questa opzione è obbligatoria e può essere utilizzata solo una volta.
<h3><a name="7.2">7.2</a> 
(2,3,4,5,6)-parity FILE [,FILE] ...
</h3>
Definisce i file da utilizzare per memorizzare informazioni di parità
extra.
<p>
Per ogni livello di parità specificato, è abilitato un livello
aggiuntivo di protezione:
<ul>
<li>
2-parity abilita la doppia parità RAID6.
</li>
<li>
3-parity abilita la tripla parità.
</li>
<li>
4-parity abilita la parità quadrupla.
</li>
<li>
5-parity abilita la parità quintupla.
</li>
<li>
6-parity abilita la parità esapla.
</li>
</ul>
<p>
Ogni livello di parità richiede la presenza di tutti i livelli di parità
precedenti.
<p>
Si applicano le stesse considerazioni dell'opzione 'parity'.
<p>
Queste opzioni sono facoltative e possono essere utilizzate solo una volta.
<h3><a name="7.3">7.3</a> 
z-parity FILE [,FILE] ...
</h3>
Definisce un file e un formato alternativi per memorizzare la tripla
parità.
<p>
Questa opzione è un'alternativa a '3-parity', destinata
principalmente a CPU di fascia bassa come ARM o AMD Phenom, Athlon
e Opteron che non supportano il set di istruzioni SSSE3. In tali
casi, fornisce prestazioni migliori.
<p>
Questo formato è simile ma più veloce di quello utilizzato da ZFS RAIDZ3.
Come ZFS, non funziona oltre la tripla parità.
<p>
Quando si utilizza '3-parity', si verrà avvisati se è consigliato
utilizzare il formato 'z-parity' per un miglioramento delle prestazioni.
<p>
È possibile convertire da un formato all'altro regolando il file
di configurazione con il file z-parity o 3-parity desiderato e
utilizzando 'fix' per ricrearlo.
<h3><a name="7.4">7.4</a> 
content FILE
</h3>
Definisce il file da utilizzare per memorizzare l'elenco e i checksum
di tutti i file presenti nell'array di dischi.
<p>
Può essere posizionato su un disco utilizzato per dati, parità o
qualsiasi altro disco disponibile.
Se si utilizza un disco dati, questo file viene automaticamente
escluso dal processo `sync`.
<p>
Questa opzione è obbligatoria e può essere utilizzata più volte
per salvare più copie dello stesso file.
<p>
È necessario memorizzare almeno una copia per ogni disco di parità
utilizzato più uno. L'utilizzo di copie aggiuntive non è dannoso.
<h3><a name="7.5">7.5</a> 
data NAME DIR
</h3>
Definisce il nome e il punto di montaggio dei dischi dati
nell'array. NAME viene utilizzato per identificare il disco e deve
essere unico. DIR è il punto di montaggio del disco nel file system.
<p>
È possibile cambiare il punto di montaggio secondo necessità,
purché si mantenga fisso NAME.
<p>
È necessario utilizzare un'opzione per ogni disco dati nell'array.
<p>
È possibile rinominare un disco in seguito modificando NAME
direttamente nel file di configurazione e quindi eseguendo un
comando 'sync'.
In caso di ridenominazione, l'associazione viene eseguita utilizzando
l'UUID memorizzato dei dischi.
<h3><a name="7.6">7.6</a> 
nohidden
</h3>
Esclude tutti i file e le directory nascosti.
In Unix, i file nascosti sono quelli che iniziano con `.`.
In Windows, sono quelli con l'attributo nascosto.
<h3><a name="7.7">7.7</a> 
exclude/include PATTERN
</h3>
Definisce i modelli di file o directory da escludere o includere
nel processo di sync.
Tutti i modelli vengono elaborati nell'ordine specificato.
<p>
Se il primo modello che corrisponde è un `exclude`, il file
viene escluso. Se è un `include`, il file viene incluso.
Se nessun modello corrisponde, il file viene escluso se l'ultimo
modello specificato è un `include`, o incluso se l'ultimo modello
specificato è un `exclude`.
<p>
Vedere la sezione PATTERN per maggiori dettagli sulle specifiche
del modello.
<p>
Questa opzione può essere utilizzata più volte.
<h3><a name="7.8">7.8</a> 
blocksize SIZE_IN_KIBIBYTES
</h3>
Definisce la dimensione di blocco di base in kibibyte per la parità.
Un kibibyte è 1024 byte.
<p>
La dimensione di blocco predefinita è 256, che dovrebbe funzionare
nella maggior parte dei casi.
<p>
ATTENZIONE! Questa opzione è solo per esperti ed è vivamente
sconsigliato modificare questo valore. Per modificare questo valore in
futuro, sarà necessario ricreare l'intera parità!
<p>
Un motivo per utilizzare una dimensione di blocco diversa è se si
hanno molti file piccoli, nell'ordine dei milioni.
<p>
Per ogni file, anche se solo pochi byte, viene allocato un intero
blocco di parità e, con molti file, ciò può comportare uno spazio
di parità inutilizzato significativo.
Quando si riempie completamente il disco di parità, non è
consentito aggiungere altri file ai dischi dati.
Tuttavia, la parità sprecata non si accumula tra i dischi dati.
Lo spazio sprecato risultante da un numero elevato di file su un
disco dati limita solo la quantità di dati su quel disco dati, non
gli altri.
<p>
Come approssimazione, si può presumere che metà della dimensione del
blocco sia sprecata per ogni file. Ad esempio, con 100.000 file e una
dimensione di blocco di 256 KiB, si sprecheranno 12,8 GB di parità,
il che può comportare 12,8 GB in meno di spazio disponibile sul disco
dati.
<p>
È possibile controllare la quantità di spazio sprecato su ogni disco
utilizzando `status`.
Questa è la quantità di spazio che è necessario lasciare libero sui
dischi dati o utilizzare per i file non inclusi nell'array.
Se questo valore è negativo, significa che si è vicini a riempire
la parità e rappresenta lo spazio che è ancora possibile sprecare.
<p>
Per evitare questo problema, è possibile utilizzare una partizione
più grande per la parità.
Ad esempio, se la partizione di parità è 12,8 GB più grande dei dischi
dati, si ha abbastanza spazio extra per gestire fino a 100.000
file su ogni disco dati senza alcuno spreco di spazio.
<p>
Un trucco per ottenere una partizione di parità più grande in Linux è
formattarla con il comando:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
mkfs.ext4 -m 0 -T largefile4 DEVICE
</pre>
</td></tr></table>
<p>
Ciò si traduce in circa l'1,5% di spazio extra, circa 60 GB per
un disco da 4 TB, che consente circa 460.000 file su ogni disco dati
senza alcuno spreco di spazio.
<h3><a name="7.9">7.9</a> 
hashsize SIZE_IN_BYTES
</h3>
Definisce la dimensione dell'hash in byte per i blocchi salvati.
<p>
La dimensione di hash predefinita è 16 byte (128 bit), che dovrebbe
funzionare nella maggior parte dei casi.
<p>
ATTENZIONE! Questa opzione è solo per esperti ed è vivamente
sconsigliato modificare questo valore. Per modificare questo valore in
futuro, sarà necessario ricreare l'intera parità!
<p>
Un motivo per utilizzare una dimensione di hash diversa è se il
sistema ha memoria limitata. Come regola generale, SnapRAID
tipicamente richiede 1 GiB di RAM per ogni 16 TB di dati nell'array.
<p>
Nello specifico, per memorizzare gli hash dei dati, SnapRAID richiede
circa $TS*(1+HS)/BS$ byte di RAM,
dove $TS$ è la dimensione totale in byte dell'array di dischi, $BS$ è la
dimensione del blocco in byte e $HS$ è la dimensione dell'hash in byte.
<p>
Ad esempio, con 8 dischi da 4 TB, una dimensione di blocco di 256 KiB
($1 \text{ KiB} = 1024 \text{ byte}$) e una dimensione di hash di 16, si ottiene:
<p>
<pre>
RAM = $(8 * 4 * 10^{12}) * (1+16) / (256 * 2^{10}) = 1.93 \text{ GiB}$
</pre>
<p>
Passando a una dimensione di hash di 8, si ottiene:
<p>
<pre>
RAM = $(8 * 4 * 10^{12}) * (1+8) / (256 * 2^{10}) = 1.02 \text{ GiB}$
</pre>
<p>
Passando a una dimensione di blocco di 512, si ottiene:
<p>
<pre>
RAM = $(8 * 4 * 10^{12}) * (1+16) / (512 * 2^{10}) = 0.96 \text{ GiB}$
</pre>
<p>
Passando sia a una dimensione di hash di 8 che a una dimensione di
blocco di 512, si ottiene:
<p>
<pre>
RAM = $(8 * 4 * 10^{12}) * (1+8) / (512 * 2^{10}) = 0.51 \text{ GiB}$
</pre>
<h3><a name="7.10">7.10</a> 
autosave SIZE_IN_GIGABYTES
</h3>
Salva automaticamente lo stato durante la sincronizzazione o lo scrubbing
dopo la quantità specificata di GB elaborati.
Questa opzione è utile per evitare di riavviare lunghi comandi `sync`
da zero se interrotti da un arresto anomalo della macchina o qualsiasi
altro evento.
<h3><a name="7.11">7.11</a> 
temp_limit TEMPERATURE_CELSIUS
</h3>
Imposta la temperatura massima del disco consentita in Celsius. Se
specificato, SnapRAID controlla periodicamente la temperatura di tutti
i dischi utilizzando lo strumento smartctl. Le temperature attuali dei
dischi vengono visualizzate mentre SnapRAID è in funzione. Se un disco
supera questo limite, tutte le operazioni si interrompono e i dischi
vengono messi in stand-by (spin down) per la durata definita
dall'opzione `temp_sleep`. Dopo il periodo di sonno, le operazioni
riprendono, potenzialmente mettendosi in pausa di nuovo se il limite
di temperatura viene raggiunto ancora una volta.
<p>
Durante il funzionamento, SnapRAID analizza anche la curva di riscaldamento
di ciascun disco e stima la temperatura costante a lungo termine che
dovrebbero raggiungere se l'attività continua. La stima viene eseguita
solo dopo che la temperatura del disco è aumentata quattro volte,
garantendo che siano disponibili abbastanza punti dati per stabilire
una tendenza affidabile.
Questa temperatura costante prevista è mostrata tra parentesi accanto
al valore attuale e aiuta a valutare se il raffreddamento del sistema
è adeguato. Questa temperatura stimata è solo a scopo informativo
e non ha alcun effetto sul comportamento di SnapRAID. Le azioni del
programma si basano esclusivamente sulle temperature effettive
misurate del disco.
<p>
Per eseguire questa analisi, SnapRAID necessita di un riferimento
per la temperatura del sistema. Tenta prima di leggerla dai sensori
hardware disponibili. Se non è possibile accedere a nessun sensore di
sistema, utilizza la temperatura del disco più bassa misurata all'inizio
dell'esecuzione come riferimento di riserva.
<p>
Normalmente, SnapRAID mostra solo la temperatura del disco più caldo.
Per visualizzare la temperatura di tutti i dischi, utilizzare l'opzione
-A o --stats.
<h3><a name="7.12">7.12</a> 
temp_sleep TIME_IN_MINUTES
</h3>
Imposta il tempo di stand-by, in minuti, quando il limite di temperatura
viene raggiunto. Durante questo periodo, i dischi rimangono fermi
(spin down). Il valore predefinito è 5 minuti.
<h3><a name="7.13">7.13</a> 
pool DIR
</h3>
Definisce la directory di pooling in cui viene creata la vista virtuale
dell'array di dischi utilizzando il comando `pool`.
<p>
La directory deve già esistere.
<h3><a name="7.14">7.14</a> 
share UNC_DIR
</h3>
Definisce il percorso UNC di Windows necessario per accedere ai dischi
da remoto.
<p>
Se questa opzione è specificata, i collegamenti simbolici creati nella
directory pool utilizzano questo percorso UNC per accedere ai dischi.
Senza questa opzione, i collegamenti simbolici generati utilizzano
solo percorsi locali, il che non consente la condivisione della
directory pool sulla rete.
<p>
I collegamenti simbolici sono formati utilizzando il percorso UNC
specificato, aggiungendo il nome del disco come specificato nell'opzione
`data` e infine aggiungendo la directory e il nome del file.
<p>
Questa opzione è richiesta solo per Windows.
<h3><a name="7.15">7.15</a> 
smartctl DISK/PARITY OPTIONS...
</h3>
Definisce opzioni smartctl personalizzate per ottenere gli attributi
SMART per ogni disco. Ciò potrebbe essere richiesto per controller RAID
e alcuni dischi USB che non possono essere rilevati automaticamente.
Il segnaposto %s viene sostituito dal nome del dispositivo, ma è
facoltativo per dispositivi fissi come i controller RAID.
<p>
DISK è lo stesso nome del disco specificato nell'opzione `data`.
PARITY è uno dei nomi di parità: `parity`, `2-parity`, `3-parity`,
`4-parity`, `5-parity`, `6-parity` o `z-parity`.
<p>
Nelle OPTIONS specificate, la stringa `%s` viene sostituita dal
nome del dispositivo. Per i controller RAID, il dispositivo è
probabilmente fisso e potrebbe non essere necessario utilizzare `%s`.
<p>
Fare riferimento alla documentazione di smartmontools per le possibili
opzioni:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.smartmontools.org/wiki/Supported_RAID-Controllers
https://www.smartmontools.org/wiki/Supported_USB-Devices
</pre>
</td></tr></table>
<p>
Ad esempio:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
smartctl parity -d sat %s
</pre>
</td></tr></table>
<h3><a name="7.16">7.16</a> 
smartignore DISK/PARITY ATTR [ATTR...]
</h3>
Ignora l'attributo SMART specificato durante il calcolo della
probabilità di guasto del disco. Questa opzione è utile se un disco
segnala valori insoliti o fuorvianti per un particolare attributo.
<p>
DISK è lo stesso nome del disco specificato nell'opzione `data`.
PARITY è uno dei nomi di parità: `parity`, `2-parity`, `3-parity`,
`4-parity`, `5-parity`, `6-parity` o `z-parity`.
Il valore speciale * può essere utilizzato per ignorare l'attributo
su tutti i dischi.
<p>
Ad esempio, per ignorare l'attributo `Current Pending Sector Count`
su tutti i dischi:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
smartignore * 197
</pre>
</td></tr></table>
<p>
Per ignorarlo solo sul primo disco di parità:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
smartignore parity 197
</pre>
</td></tr></table>
<h3><a name="7.17">7.17</a> 
Esempi
</h3>
Un esempio di configurazione tipica per Unix è:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity /mnt/diskp/snapraid.parity
content /mnt/diskp/snapraid.content
content /var/snapraid/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
exclude /lost+found/
exclude /tmp/
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/sg0
smartctl 2-parity -d areca,2/1 /dev/sg0
</pre>
</td></tr></table>
<p>
Un esempio di configurazione tipica per Windows è:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity E:\snapraid.parity
content E:\snapraid.content
content C:\snapraid\snapraid.content
data d1 G:\array\
data d2 H:\array\
data d3 I:\array\
exclude Thumbs.db
exclude \$RECYCLE.BIN
exclude \System Volume Information
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/arcmsr0
smartctl 2-parity -d areca,2/1 /dev/arcmsr0
</pre>
</td></tr></table>
<h2><a name="8">8</a> 
Pattern
</h2>
I pattern vengono utilizzati per selezionare un sottoinsieme di file da
escludere o includere nel processo.
<p>
Esistono quattro diversi tipi di pattern:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
FILE
</strong></td></tr><tr><td>
Seleziona qualsiasi file denominato FILE. È possibile utilizzare
qualsiasi carattere di globbing come * e ?, e classi di caratteri
come [a-z].
Questo pattern si applica solo ai file, non alle directory.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
DIR/
</strong></td></tr><tr><td>
Seleziona qualsiasi directory denominata DIR e tutto ciò che è
al suo interno. È possibile utilizzare qualsiasi carattere di
globbing come * e ?.
Questo pattern si applica solo alle directory, non ai file.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
/PATH/FILE
</strong></td></tr><tr><td>
Seleziona l'esatto percorso del file specificato. È possibile
utilizzare qualsiasi carattere di globbing come * e ?, ma non
corrispondono mai a uno slash di directory.
Questo pattern si applica solo ai file, non alle directory.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
/PATH/DIR/
</strong></td></tr><tr><td>
Seleziona l'esatto percorso della directory specificata e tutto
ciò che è al suo interno. È possibile utilizzare qualsiasi
carattere di globbing come * e ?, ma non corrispondono mai a
uno slash di directory.
Questo pattern si aplica solo alle directory, non ai file.
</td></tr>
</table>
<p>
Quando si specifica un percorso assoluto che inizia con /, viene
applicato alla directory radice dell'array, non alla directory radice
del file system locale.
<p>
In Windows, è possibile utilizzare il backslash \ invece dello slash
in avanti /. Le directory di sistema di Windows, le junction, i punti
di montaggio e altre directory speciali di Windows sono trattati come
file, il che significa che per escluderli, è necessario utilizzare una
regola di file, non una di directory.
<p>
Se il nome del file contiene un carattere '*', '?', '[' o ']',
è necessario eseguirne l'escape per evitare che venga interpretato
come un carattere di globbing. In Unix, il carattere di escape è '\';
in Windows, è '^'.
Quando il pattern è sulla riga di comando, è necessario raddoppiare
il carattere di escape per evitare che venga interpretato dalla shell
dei comandi.
<p>
Nel file di configurazione, è possibile utilizzare diverse strategie
per filtrare i file da elaborare.
L'approccio più semplice è utilizzare solo regole `exclude` per
rimuovere tutti i file e le directory che non si desidera elaborare.
Ad esempio:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Esclude qualsiasi file denominato `*.unrecoverable`
exclude *.unrecoverable
# Esclude la directory radice `/lost+found`
exclude /lost+found/
# Esclude qualsiasi sottodirectory denominata `tmp`
exclude tmp/
</pre>
</td></tr></table>
<p>
L'approccio opposto è definire solo i file che si desidera elaborare,
utilizzando solo regole `include`. Ad esempio:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Include solo alcune directory
include /movies/
include /musics/
include /pictures/
</pre>
</td></tr></table>
<p>
L'approccio finale è mescolare regole `exclude` e `include`. In questo
caso, l'ordine delle regole è importante. Le regole precedenti hanno
la precedenza su quelle successive.
Per semplificare, è possibile elencare prima tutte le regole `exclude`
e poi tutte le regole `include`. Ad esempio:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Esclude qualsiasi file denominato `*.unrecoverable`
exclude *.unrecoverable
# Esclude qualsiasi sottodirectory denominata `tmp`
exclude tmp/
# Include solo alcune directory
include /movies/
include /musics/
include /pictures/
</pre>
</td></tr></table>
<p>
Sulla riga di comando, utilizzando l'opzione -f, è possibile utilizzare
solo pattern `include`. Ad esempio:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Controlla solo i file .mp3.
# In Unix, utilizzare le virgolette per evitare l'espansione
# del globbing da parte della shell.
snapraid -f "*.mp3" check
</pre>
</td></tr></table>
<p>
In Unix, quando si utilizzano caratteri di globbing sulla riga di
comando, è necessario citarli per impedire alla shell di espanderli.
<h2><a name="9">9</a> 
Content
</h2>
SnapRAID memorizza l'elenco e i checksum dei file nel file di contenuto.
<p>
È un file binario che elenca tutti i file presenti nell'array di dischi,
insieme a tutti i checksum per verificarne l'integrità.
<p>
Questo file viene letto e scritto dai comandi `sync` e `scrub` e
letto dai comandi `fix`, `check` e `status`.
<h2><a name="10">10</a> 
Parity
</h2>
SnapRAID memorizza le informazioni di parità dell'array nei file di
parità.
<p>
Questi sono file binari contenenti la parità calcolata di tutti i
blocchi definiti nel file `content`.
<p>
Questi file vengono letti e scritti dai comandi `sync` e `fix` e
solo letti dai comandi `scrub` e `check`.
<h2><a name="11">11</a> 
Codifica
</h2>
SnapRAID in Unix ignora qualsiasi codifica. Legge e memorizza i
nomi dei file con la stessa codifica utilizzata dal file system.
<p>
In Windows, tutti i nomi letti dal file system vengono convertiti e
elaborati in formato UTF-8.
<p>
Per avere i nomi dei file stampati correttamente, è necessario impostare
la console di Windows in modalità UTF-8 con il comando `chcp 65001` e
utilizzare un carattere TrueType come `Lucida Console` come carattere
della console.
Questo influisce solo sui nomi dei file stampati; se si
reindirizza l'output della console a un file, il file risultante è
sempre in formato UTF-8.
<h2><a name="13">13</a> 
Vedi Anche
</h2>
snapraid_log(1), rsync(1)


<p>
</p>

</div>

<div id="footer">

<div class="column">
<span class="bold">Donate with</span>
<br>
<!--
<a href="http://sourceforge.net/p/snapraid/donate/"><img src="paypal.png" width="160" height="60" alt="PayPal"></a>
-->
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=amadvance%40gmail%2ecom&lc=US&item_name=SnapRAID&no_note=0&currency_code=USD&bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHostedGuest"><img src="paypal.png" width="160" height="60" alt="PayPal"></a>
<!--
<a href="https://coinkite.com/u/amadvance/"><img src="bitcoin.png" width="160" height="60" alt="BitCoin"></a>
-->
</div>

<div class="column">
<span class="bold">Find other resources at</span>
<br>
<a href="https://github.com/amadvance/snapraid/"><img src="github.png" width="160" height="60" alt="GitHub"></a>
<a href="http://sourceforge.net/projects/snapraid/"><img src="sourceforge.png" width="115" height="60" alt="SourceForge"></a>
</div>

</div>
</body>
</html>


