<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="A backup program for disk arrays. It stores parity information of your data and it recovers from up to six disk failures">
<meta name="keywords" content="snapraid snapshot raid backup disk array redundancy parity">
<meta name="author" content="Andrea Mazzoleni">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="stylesheet" type="text/css" href="style.css">
<title>SnapRAID</title>

<!-- Google Analytics 4 -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W1Z5FKHYQ4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-W1Z5FKHYQ4');
</script>

<!-- Google Universal Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<div id="header">
<img src="index.jpg" width="1200" height="150" alt="Title">
</div>
<div id="menu">
<a href="/">About</a>
<a href="download">Download</a>
<a href="design">Design</a>
<a href="compare">Compare</a>
<a href="faq">FAQ</a>
<a href="manual">Manual</a>
<a href="support">Support</a>
<a href="authors">Authors</a>
</div>
<div id="main">



<p>
Ukranian manual for <span class="bold">SnapRAID</span>.
</p>

<h2><a name="1">1</a> 
Короткий опис
</h2>
<pre>
snapraid [-c, --conf CONFIG]
&nbsp;&nbsp;&nbsp;&nbsp;[-f, --filter PATTERN] [-d, --filter-disk NAME]
&nbsp;&nbsp;&nbsp;&nbsp;[-m, --filter-missing] [-e, --filter-error]
&nbsp;&nbsp;&nbsp;&nbsp;[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR]
&nbsp;&nbsp;&nbsp;&nbsp;[-p, --plan PERC|bad|new|full]
&nbsp;&nbsp;&nbsp;&nbsp;[-o, --older-than DAYS] [-l, --log FILE]
&nbsp;&nbsp;&nbsp;&nbsp;[-s, --spin-down-on-error] [-w, --bw-limit RATE]
&nbsp;&nbsp;&nbsp;&nbsp;[-Z, --force-zero] [-E, --force-empty]
&nbsp;&nbsp;&nbsp;&nbsp;[-U, --force-uuid] [-D, --force-device]
&nbsp;&nbsp;&nbsp;&nbsp;[-N, --force-nocopy] [-F, --force-full]
&nbsp;&nbsp;&nbsp;&nbsp;[-R, --force-realloc]
&nbsp;&nbsp;&nbsp;&nbsp;[-S, --start BLKSTART] [-B, --count BLKCOUNT]
&nbsp;&nbsp;&nbsp;&nbsp;[-L, --error-limit NUMBER]
&nbsp;&nbsp;&nbsp;&nbsp;[-A, --stats]
&nbsp;&nbsp;&nbsp;&nbsp;[-v, --verbose] [-q, --quiet]
&nbsp;&nbsp;&nbsp;&nbsp;status|smart|probe|up|down|diff|sync|scrub|fix|check
&nbsp;&nbsp;&nbsp;&nbsp;|list|dup|pool|devices|touch|rehash
</pre>
<p>
<pre>
snapraid [-V, --version] [-H, --help] [-C, --gen-conf CONTENT]
</pre>
<h2><a name="2">2</a> 
Опис
</h2>
SnapRAID — це програма резервного копіювання, розроблена для
дискових масивів, яка зберігає інформацію парності для
відновлення даних у випадку відмови до шести дисків.
<p>
В першу чергу призначена для домашніх медіацентрів з великими
файлами, що рідко змінюються, SnapRAID пропонує кілька функцій:
<ul>
<li>
Ви можете використовувати диски, вже заповнені файлами, без
необхідності їх переформатування, отримуючи доступ до них
як зазвичай.
</li>
<li>
Усі ваші дані хешуються для забезпечення цілісності даних
та запобігання прихованому пошкодженню.
</li>
<li>
Коли кількість дисків, що відмовили, перевищує кількість
дисків парності, втрата даних обмежується дисками, що
постраждали; дані на інших дисках залишаються доступними.
</li>
<li>
Якщо ви випадково видалили файли на диску, можливе
відновлення.
</li>
<li>
Диски можуть мати різний розмір.
</li>
<li>
Ви можете додавати диски в будь-який час.
</li>
<li>
SnapRAID не блокує ваші дані; ви можете припинити його
використання в будь-який час без переформатування або
переміщення даних.
</li>
<li>
Для доступу до файлу потрібно розкрутити лише один диск, що
заощаджує електроенергію та зменшує шум.
</li>
</ul>
<p>
Для отримання додаткової інформації відвідайте офіційний сайт
SnapRAID:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.snapraid.it/
</pre>
</td></tr></table>
<h2><a name="3">3</a> 
Обмеження
</h2>
SnapRAID є гібридом між RAID та програмою резервного копіювання,
прагнучи поєднати найкращі переваги обох. Однак, він має деякі
обмеження, які слід врахувати перед його використанням.
<p>
Основне обмеження полягає в тому, що якщо диск виходить з ладу,
а ви нещодавно не виконували синхронізацію, ви можете не
змогти повністю відновити дані.
Конкретніше, ви можете втратити можливість відновлення даних
обсягом до розміру змінених або видалених файлів з моменту
останньої операції синхронізації.
Це відбувається, навіть якщо змінені або видалені файли не
знаходяться на диску, що вийшов з ладу. Ось чому SnapRAID
краще підходить для даних, які рідко змінюються.
<p>
З іншого боку, щойно додані файли не перешкоджають відновленню
вже існуючих файлів. Ви втратите лише нещодавно додані файли,
якщо вони знаходяться на диску, що вийшов з ладу.
<p>
Інші обмеження SnapRAID:
<ul>
<li>
З SnapRAID у вас все ще є окремі файлові системи для
кожного диска. З RAID ви отримуєте одну велику файлову
систему.
</li>
<li>
SnapRAID не використовує чергування (striping) даних.
З RAID ви отримуєте прискорення завдяки чергуванню.
</li>
<li>
SnapRAID не підтримує відновлення в реальному часі.
З RAID вам не потрібно припиняти роботу, коли диск
виходить з ладу.
</li>
<li>
SnapRAID може відновлювати дані лише з обмеженої кількості
дисків, що вийшли з ладу. З резервним копіюванням ви
можете відновити дані навіть після повної відмови
всього дискового масиву.
</li>
<li>
Зберігаються лише імена файлів, часові мітки, символічні
та жорсткі посилання. Права доступу, власність та
розширені атрибути не зберігаються.
</li>
</ul>
<h2><a name="4">4</a> 
Початок роботи
</h2>
Щоб використовувати SnapRAID, спершу потрібно вибрати один диск
у вашому дисковому масиві, щоб присвятити його інформації
`парності`. З одним диском для парності ви зможете відновити
дані після відмови одного диска, подібно до RAID5.
<p>
Якщо ви хочете відновити дані після більшої кількості
дисків, що відмовили, подібно до RAID6, ви повинні зарезервувати
додаткові диски для парності. Кожен додатковий диск парності
дозволяє відновити дані після відмови ще одного диска.
<p>
Як диски парності ви повинні вибрати найбільші диски в масиві,
оскільки інформація парності може зрости до розміру найбільшого
диска даних у масиві.
<p>
Ці диски будуть присвячені зберіганню файлів `парності`. Ви
не повинні зберігати на них свої дані.
<p>
Потім ви повинні визначити диски `даних`, які ви хочете
захистити за допомогою SnapRAID. Захист є більш ефективним,
якщо ці диски містять дані, що рідко змінюються. З цієї причини
краще НЕ включати диск Windows C:\ або каталоги Unix /home,
/var та /tmp.
<p>
Список файлів зберігається у файлах `content` (вміст), які
зазвичай зберігаються на дисках даних, парності або завантажувальних
дисках.
Цей файл містить деталі вашої резервної копії, включаючи
всі контрольні суми для перевірки її цілісності.
Файл `content` зберігається в кількох копіях, і кожна копія
повинна бути на окремому диску, щоб гарантувати, що навіть у
разі відмови кількох дисків, принаймні одна копія буде доступна.
<p>
Наприклад, припустимо, вас цікавить лише один рівень захисту
парності, а ваші диски розташовані за адресами:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
/mnt/diskp &lt;- вибраний диск для парності
/mnt/disk1 &lt;- перший диск для захисту
/mnt/disk2 &lt;- другий диск для захисту
/mnt/disk3 &lt;- третій диск для захисту
</pre>
</td></tr></table>
<p>
Ви повинні створити конфігураційний файл /etc/snapraid.conf з
наступними опціями:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity /mnt/diskp/snapraid.parity
content /var/snapraid/snapraid.content
content /mnt/disk1/snapraid.content
content /mnt/disk2/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
</pre>
</td></tr></table>
<p>
Якщо ви працюєте в Windows, ви повинні використовувати формат
шляху Windows, з літерами дисків та зворотними скісними рисками
замість прямих.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity E:\snapraid.parity
content C:\snapraid\snapraid.content
content F:\array\snapraid.content
content G:\array\snapraid.content
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
</pre>
</td></tr></table>
<p>
Якщо у вас багато дисків і закінчилися літери дисків, ви можете
монтувати диски безпосередньо у вкладені папки. Див:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.google.com/search?q=Windows+mount+point
</pre>
</td></tr></table>
<p>
На цьому етапі ви готові запустити команду `sync` для побудови
інформації парності.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid sync
</pre>
</td></tr></table>
<p>
Цей процес може зайняти кілька годин вперше, залежно від розміру
даних, які вже є на дисках. Якщо диски порожні, процес
відбувається миттєво.
<p>
Ви можете зупинити його в будь-який час, натиснувши Ctrl+C,
і під час наступного запуску він відновить роботу з місця,
де був перерваний.
<p>
Коли ця команда завершиться, ваші дані БЕЗПЕЧНІ.
<p>
Тепер ви можете почати використовувати свій масив як вам подобається
і періодично оновлювати інформацію парності, запускаючи команду `sync`.
<h3><a name="4.1">4.1</a> 
Скрабування (Scrubbing)
</h3>
Щоб періодично перевіряти дані та парність на наявність помилок,
ви можете запустити команду `scrub`.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid scrub
</pre>
</td></tr></table>
<p>
Ця команда порівнює дані у вашому масиві з хешем, обчисленим
під час команди `sync`, для перевірки цілісності.
<p>
Кожен запуск команди перевіряє приблизно 8% масиву, виключаючи
дані, які вже були скрабовані протягом попередніх 10 днів.
Ви можете використовувати опцію -p, --plan, щоб вказати іншу
кількість, і опцію -o, --older-than, щоб вказати інший вік
у днях.
Наприклад, щоб перевірити 5% масиву на блоки старші за 20 днів,
використовуйте:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -p 5 -o 20 scrub
</pre>
</td></tr></table>
<p>
Якщо під час процесу виявлено приховані помилки або помилки
введення/виведення, відповідні блоки позначаються як погані у
файлі `content` і перераховуються у команді `status`.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid status
</pre>
</td></tr></table>
<p>
Щоб їх виправити, ви можете використовувати команду `fix`,
фільтруючи погані блоки за допомогою опції -e, --filter-error:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -e fix
</pre>
</td></tr></table>
<p>
Під час наступного `scrub` помилки зникнуть зі звіту `status`,
якщо вони справді виправлені. Щоб зробити це швидше, ви можете
використовувати -p bad, щоб скрабувати лише блоки, позначені
як погані.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -p bad scrub
</pre>
</td></tr></table>
<p>
Запуск `scrub` на несинхронізованому масиві може повідомити
про помилки, спричинені видаленими або зміненими файлами.
Ці помилки відображаються у виведенні `scrub`, але пов'язані
блоки не позначаються як погані.
<h3><a name="4.2">4.2</a> 
Об'єднання (Pooling)
</h3>
Примітка: Функція об'єднання, описана нижче, була замінена
інструментом mergefs, який тепер є рекомендованою опцією для
користувачів Linux у спільноті SnapRAID. Mergefs забезпечує
більш гнучкий та ефективний спосіб об'єднання кількох дисків
в єдину уніфіковану точку монтування, дозволяючи безперешкодний
доступ до файлів у вашому масиві без використання символічних
посилань. Він добре інтегрується з SnapRAID для захисту
парності і зазвичай використовується в налаштуваннях, таких
як OpenMediaVault (OMV) або користувацьких конфігураціях NAS.
<p>
Щоб відобразити всі файли у вашому масиві в одному дереві
каталогів, ви можете ввімкнути функцію `pooling` (об'єднання).
Вона створює віртуальне представлення всіх файлів у вашому
масиві лише для читання, використовуючи символічні посилання.
<p>
Ви можете налаштувати каталог `pooling` у конфігураційному
файлі за допомогою:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
pool /pool
</pre>
</td></tr></table>
<p>
або, якщо ви працюєте в Windows, за допомогою:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
pool C:\pool
</pre>
</td></tr></table>
<p>
а потім запустити команду `pool` для створення або оновлення
віртуального представлення.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid pool
</pre>
</td></tr></table>
<p>
Якщо ви використовуєте платформу Unix і хочете надати спільний
доступ до цього каталогу через мережу для машин Windows або
Unix, ви повинні додати наступні опції до вашого
/etc/samba/smb.conf:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# У глобальному розділі smb.conf
unix extensions = no
</pre>
</td></tr></table>
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# У розділі спільного доступу smb.conf
[pool]
comment = Pool
path = /pool
read only = yes
guest ok = yes
wide links = yes
follow symlinks = yes
</pre>
</td></tr></table>
<p>
У Windows спільний доступ до символічних посилань через мережу
вимагає від клієнтів віддаленого їх розпізнавання. Щоб
увімкнути це, окрім спільного доступу до каталогу pool, ви
також повинні надати спільний доступ до всіх дисків незалежно,
використовуючи імена дисків, визначені у конфігураційному
файлі, як точки спільного доступу. Ви також повинні вказати у
опції `share` конфігураційного файлу шлях Windows UNC, який
потрібен віддаленим клієнтам для доступу до цих спільних дисків.
<p>
Наприклад, працюючи з сервера з іменем `darkstar`, ви можете
використовувати опції:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
pool C:\pool
share \\darkstar
</pre>
</td></tr></table>
<p>
і надати спільний доступ до наступних каталогів через мережу:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
\\darkstar\pool -&gt; C:\pool
\\darkstar\d1 -&gt; F:\array
\\darkstar\d2 -&gt; G:\array
\\darkstar\d3 -&gt; H:\array
</pre>
</td></tr></table>
<p>
щоб дозволити віддаленим клієнтам отримати доступ до всіх файлів
за адресою \\darkstar\pool.
<p>
Вам також може знадобитися налаштувати віддалені клієнти, щоб
увімкнути доступ до віддалених символічних посилань за допомогою
команди:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
fsutil behavior set SymlinkEvaluation L2L:1 R2R:1 L2R:1 R2L:1
</pre>
</td></tr></table>
<h3><a name="4.3">4.3</a> 
Відновлення видалених файлів (Undeleting)
</h3>
SnapRAID функціонує більше як програма резервного копіювання,
ніж система RAID, і його можна використовувати для відновлення
або повернення файлів до їх попереднього стану за допомогою
опції -f, --filter:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -f FILE
</pre>
</td></tr></table>
<p>
або для каталогу:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -f DIR/
</pre>
</td></tr></table>
<p>
Ви також можете використовувати його для відновлення лише випадково
видалених файлів усередині каталогу за допомогою опції -m,
--filter-missing, яка відновлює лише відсутні файли,
залишаючи всі інші недоторканими.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -m -f DIR/
</pre>
</td></tr></table>
<p>
Або для відновлення всіх видалених файлів на всіх дисках за допомогою:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -m
</pre>
</td></tr></table>
<h3><a name="4.4">4.4</a> 
Відновлення (Recovering)
</h3>
Сталося найгірше, і ви втратили один або кілька дисків!
<p>
НЕ ПАНІКУЙТЕ! Ви зможете їх відновити!
<p>
Перше, що ви повинні зробити, це уникнути подальших змін у
вашому дисковому масиві. Вимкніть будь-які віддалені
підключення до нього та будь-які заплановані процеси,
включаючи будь-яку заплановану нічну синхронізацію або
скрабування SnapRAID.
<p>
Потім виконайте наступні кроки.
<h4><a name="4.4.1">4.4.1</a> 
КРОК 1 -&gt; Переналаштування
</h4>
Вам потрібен деякий простір для відновлення, в ідеалі на
додаткових запасних дисках, але зовнішній USB-диск або
віддалений диск підійде.
<p>
Змініть конфігураційний файл SnapRAID, щоб опція `data` або
`parity` диска, що вийшов з ладу, вказувала на місце розташування
з достатньою кількістю вільного місця для відновлення файлів.
<p>
Наприклад, якщо диск `d1` вийшов з ладу, змініть з:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 /mnt/disk1/
</pre>
</td></tr></table>
<p>
на:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 /mnt/new_spare_disk/
</pre>
</td></tr></table>
<p>
Якщо диск, який потрібно відновити, є диском парності, оновіть
відповідну опцію `parity`.
Якщо у вас кілька дисків, що вийшли з ладу, оновіть усі їхні
конфігураційні опції.
<h4><a name="4.4.2">4.4.2</a> 
КРОК 2 -&gt; Виправлення (Fix)
</h4>
Запустіть команду fix, зберігаючи журнал у зовнішньому файлі
за допомогою:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -d NAME -l fix.log fix
</pre>
</td></tr></table>
<p>
Де NAME — це ім'я диска, наприклад `d1` у нашому попередньому
прикладі.
Якщо диск, який потрібно відновити, є диском парності,
використовуйте імена `parity`, `2-parity`, тощо.
Якщо у вас кілька дисків, що вийшли з ладу, використовуйте
кілька опцій -d, щоб вказати їх усі.
<p>
Ця команда займе багато часу.
<p>
Переконайтеся, що у вас є кілька гігабайт вільного місця для
зберігання файлу fix.log.
Запустіть її з диска з достатньою кількістю вільного місця.
<p>
Тепер ви відновили все, що можна відновити. Якщо деякі файли
частково або повністю неможливо відновити, вони будуть перейменовані
з додаванням розширення `.unrecoverable`.
<p>
Ви можете знайти детальний список усіх невідновлюваних блоків
у файлі fix.log, перевіривши всі рядки, що починаються з
`unrecoverable:`.
<p>
Якщо ви не задоволені відновленням, ви можете повторити його
стільки разів, скільки забажаєте.
<p>
Наприклад, якщо ви видалили файли з масиву після останньої
`sync`, це може призвести до того, що деякі файли не будуть
відновлені.
У цьому випадку ви можете повторити `fix`, використовуючи
опцію -i, --import, вказавши, де ці файли знаходяться зараз,
щоб знову включити їх у процес відновлення.
<p>
Якщо ви задоволені відновленням, ви можете продовжити, але
зауважте, що після синхронізації ви більше не зможете повторити
команду `fix`!
<h4><a name="4.4.3">4.4.3</a> 
КРОК 3 -&gt; Перевірка (Check)
</h4>
Як обережну перевірку, ви можете тепер запустити команду
`check`, щоб переконатися, що на відновленому диску все
правильно.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -d NAME -a check
</pre>
</td></tr></table>
<p>
Де NAME — це ім'я диска, наприклад `d1` у нашому попередньому
прикладі.
<p>
Опції -d та -a вказують SnapRAID перевіряти лише вказаний
диск та ігнорувати всі дані парності.
<p>
Ця команда займе багато часу, але якщо ви не надто обережні,
ви можете її пропустити.
<h4><a name="4.4.4">4.4.4</a> 
КРОК 4 -&gt; Синхронізація (Sync)
</h4>
Запустіть команду `sync`, щоб повторно синхронізувати масив
з новим диском.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid sync
</pre>
</td></tr></table>
<p>
Якщо все відновлено, ця команда виконується миттєво.
<h2><a name="5">5</a> 
Команди
</h2>
SnapRAID надає кілька простих команд, які дозволяють:
<ul>
<li>
Вивести статус масиву -&gt; `status`
</li>
<li>
Керувати дисками -&gt; `smart`, `probe`, `up`, `down`
</li>
<li>
Створити резервну копію/знімок -&gt; `sync`
</li>
<li>
Періодично перевіряти дані -&gt; `scrub`
</li>
<li>
Відновити останню резервну копію/знімок -&gt; `fix`.
</li>
</ul>
<p>
Команди повинні бути написані малими літерами.
<h3><a name="5.1">5.1</a> 
status
</h3>
Виводить зведення стану дискового масиву.
<p>
Включає інформацію про фрагментацію парності, вік блоків без
перевірки та всі записані приховані помилки, виявлені під
час скрабування.
<p>
Представлена інформація стосується останнього часу, коли ви
запустили `sync`. Пізніші модифікації не враховуються.
<p>
Якщо виявлено погані блоки, перераховуються їхні номери блоків.
Щоб їх виправити, ви можете використовувати команду `fix -e`.
<p>
Також показує графік, що представляє останній час, коли
кожен блок був скрабований або синхронізований. Скрабовані
блоки позначаються символом '*', блоки, синхронізовані,
але ще не скрабовані, - 'o'.
<p>
Нічого не змінюється.
<h3><a name="5.2">5.2</a> 
smart
</h3>
Виводить звіт SMART усіх дисків у системі.
<p>
Включає оцінку ймовірності відмови протягом наступного року,
дозволяючи вам планувати планову заміну дисків, які
виявляють підозрілі атрибути.
<p>
Ця оцінка ймовірності отримана шляхом кореляції атрибутів
SMART дисків з даними Backblaze, доступними за адресою:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.backblaze.com/hard-drive-test-data.html
</pre>
</td></tr></table>
<p>
Якщо SMART повідомляє, що диск виходить з ладу, для цього
диска виводиться `FAIL` або `PREFAIL`, і SnapRAID повертає
помилку. У цьому випадку настійно рекомендується негайна
заміна диска.
<p>
Інші можливі рядки стану:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
logfail
</em></td><td width="90%">
У минулому деякі атрибути були нижчими за
поріг.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
logerr
</em></td><td width="90%">
Журнал помилок пристрою містить помилки.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
selferr
</em></td><td width="90%">
Журнал самотестування пристрою містить помилки.
</td></tr>
</table>
<p>
Якщо вказано опцію -v, --verbose, надається глибший
статистичний аналіз. Цей аналіз може допомогти вам вирішити,
чи потрібна вам більша або менша парність.
<p>
Ця команда використовує інструмент `smartctl` і еквівалентна
запуску `smartctl -a` на всіх пристроях.
<p>
Якщо ваші пристрої не виявляються автоматично правильно, ви
можете вказати користувацьку команду, використовуючи опцію
`smartctl` у конфігураційному файлі.
<p>
Нічого не змінюється.
<h3><a name="5.3">5.3</a> 
probe
</h3>
Виводить стан ЖИВЛЕННЯ всіх дисків у системі.
<p>
`Standby` означає, що диск не обертається. `Active` означає,
що диск обертається.
<p>
Ця команда використовує інструмент `smartctl` і еквівалентна
запуску `smartctl -n standby -i` на всіх пристроях.
<p>
Якщо ваші пристрої не виявляються автоматично правильно, ви
можете вказати користувацьку команду, використовуючи опцію
`smartctl` у конфігураційному файлі.
<p>
Нічого не змінюється.
<h3><a name="5.4">5.4</a> 
up
</h3>
Розкручує всі диски масиву.
<p>
Ви можете розкрутити лише певні диски, використовуючи
опцію -d, --filter-disk.
<p>
Одночасне розкручування всіх дисків вимагає багато енергії.
Переконайтеся, що ваш блок живлення може це витримати.
<p>
Нічого не змінюється.
<h3><a name="5.5">5.5</a> 
down
</h3>
Зупиняє всі диски масиву.
<p>
Ця команда використовує інструмент `smartctl` і еквівалентна
запуску `smartctl -s standby,now` на всіх пристроях.
<p>
Ви можете зупинити лише певні диски, використовуючи
опцію -d, --filter-disk.
<p>
Для автоматичної зупинки при помилці ви можете
використовувати опцію -s, --spin-down-on-error з будь-якою
іншою командою, що еквівалентно ручному запуску `down`
при виникненні помилки.
<p>
Нічого не змінюється.
<h3><a name="5.6">5.6</a> 
diff
</h3>
Виводить список усіх файлів, змінених з моменту останньої
`sync`, для яких необхідно перерахувати дані парності.
<p>
Ця команда не перевіряє дані файлів, а лише часову мітку
файлу, розмір та inode.
<p>
Після перерахування всіх змінених файлів представляється
зведення змін, згруповане за:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
equal (рівні)
</em></td><td width="90%">
Файли, незмінені з попереднього стану.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
added (додані)
</em></td><td width="90%">
Файли, додані, яких не було раніше.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
removed (видалені)
</em></td><td width="90%">
Файли, видалені.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
updated (оновлені)
</em></td><td width="90%">
Файли з іншим розміром або часовою
міткою, що означає, що вони були змінені.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
moved (переміщені)
</em></td><td width="90%">
Файли, переміщені в інший каталог
на тому ж диску. Вони ідентифікуються за тим же
іменем, розміром, часовою міткою та inode, але іншим
каталогом.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
copied (скопійовані)
</em></td><td width="90%">
Файли, скопійовані на тому ж
або іншому диску. Зауважте, що якщо вони справді
переміщені на інший диск, вони також будуть враховані
як `removed`.
Вони ідентифікуються за тим же іменем, розміром
та часовою міткою. Якщо часова мітка з точністю
до долі секунди дорівнює нулю, повний шлях повинен
збігатися, а не лише ім'я.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
restored (відновлені)
</em></td><td width="90%">
Файли з іншим inode, але
збігаються ім'я, розмір та часова мітка. Це
зазвичай файли, відновлені після видалення.
</td></tr>
</table>
<p>
Якщо потрібна `sync`, код повернення процесу дорівнює 2,
замість стандартного 0. Код повернення 1 використовується для
загальної умови помилки.
<p>
Нічого не змінюється.
<h3><a name="5.7">5.7</a> 
sync
</h3>
Оновлює інформацію парності. Всі змінені файли у дисковому
масиві зчитуються, і відповідні дані парності оновлюються.
<p>
Ви можете зупинити цей процес у будь-який час, натиснувши
Ctrl+C, не втрачаючи вже виконану роботу.
Під час наступного запуску процес `sync` відновить роботу
з місця, де був перерваний.
<p>
Якщо під час процесу виявлено приховані помилки або помилки
введення/виведення, відповідні блоки позначаються як погані.
<p>
Файли ідентифікуються за шляхом та/або inode та перевіряються
за розміром та часовою міткою.
Якщо розмір або часова мітка файлу відрізняються, дані
парності перераховуються для всього файлу.
Якщо файл переміщено або перейменовано на тому ж диску,
зберігаючи той самий inode, парність не перераховується.
Якщо файл переміщено на інший диск, парність перераховується,
але раніше обчислена інформація хешу зберігається.
<p>
Файли `content` та `parity` змінюються за потреби.
Файли в масиві НЕ змінюються.
<h3><a name="5.8">5.8</a> 
scrub
</h3>
Скрабує масив, перевіряючи на наявність прихованих помилок
або помилок введення/виведення на дисках даних та парності.
<p>
Кожен виклик перевіряє приблизно 8% масиву, виключаючи
дані, які вже були скрабовані протягом останніх 10 днів.
Це означає, що скрабування раз на тиждень забезпечує
перевірку кожного біта даних принаймні раз на три місяці.
<p>
Ви можете визначити інший план скрабування або кількість
за допомогою опції -p, --plan, яка приймає:
bad - Скрабувати блоки, позначені як погані.
new - Скрабувати щойно синхронізовані блоки, які ще не були
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
скрабовані.
</td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
full
</em></td><td width="90%">
Скрабувати все.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
0-100
</em></td><td width="90%">
Скрабувати вказаний відсоток блоків.
</td></tr>
</table>
<p>
Якщо ви вказуєте відсоткове значення, ви також можете
використовувати опцію -o, --older-than, щоб визначити,
яким має бути вік блоку.
Найстаріші блоки скрабуються першими, забезпечуючи оптимальну
перевірку.
Якщо ви хочете скрабувати лише щойно синхронізовані блоки,
які ще не були скрабовані, використовуйте опцію `-p new`.
<p>
Щоб отримати деталі статусу скрабування, використовуйте команду
`status`.
<p>
Для будь-якої знайденої прихованої помилки або помилки
введення/виведення відповідні блоки позначаються як погані
у файлі `content`.
Ці погані блоки перераховуються у `status` і можуть бути
виправлені за допомогою `fix -e`.
Після виправлення, під час наступного скрабування, вони будуть
повторно перевірені, і якщо виявиться, що вони виправлені,
позначка "поганий" буде видалена.
Щоб скрабувати лише погані блоки, ви можете використовувати
команду `scrub -p bad`.
<p>
Рекомендується запускати `scrub` лише на синхронізованому
масиві, щоб уникнути повідомлень про помилки, спричинені
несинхронізованими даними. Ці помилки розпізнаються як
не приховані помилки, і блоки не позначаються як погані,
але такі помилки повідомляються у виведенні команди.
<p>
Файл `content` змінюється для оновлення часу останньої перевірки
для кожного блоку та для позначення поганих блоків.
Файли `parity` НЕ змінюються.
Файли в масиві НЕ змінюються.
<h3><a name="5.9">5.9</a> 
fix
</h3>
Виправляє всі файли та дані парності.
<p>
Усі файли та дані парності порівнюються зі станом знімка,
збереженим під час останньої `sync`.
Якщо знайдено різницю, вона повертається до збереженого знімка.
<p>
УВАГА! Команда `fix` не розрізняє помилки та навмисні
модифікації. Вона безумовно повертає стан файлу до останньої
`sync`.
<p>
Якщо не вказано жодної іншої опції, обробляється весь масив.
Використовуйте опції фільтра, щоб вибрати підмножину файлів
або дисків для роботи.
<p>
Щоб виправити лише блоки, позначені як погані під час `sync`
та `scrub`, використовуйте опцію -e, --filter-error.
На відміну від інших опцій фільтра, ця застосовує виправлення
лише до файлів, які не змінилися з моменту останньої `sync`.
<p>
SnapRAID перейменовує всі файли, які не можуть бути виправлені,
додаючи розширення `.unrecoverable`.
<p>
Перед виправленням сканується весь масив, щоб знайти будь-які
файли, переміщені з моменту останньої `sync`.
Ці файли ідентифікуються за їхньою часовою міткою, ігноруючи
їхнє ім'я та каталог, і використовуються в процесі відновлення,
якщо це необхідно.
Якщо ви перемістили деякі з них за межі масиву, ви можете
використовувати опцію -i, --import, щоб вказати додаткові
каталоги для сканування.
<p>
Файли ідентифікуються лише за шляхом, а не за inode.
<p>
Файл `content` НЕ змінюється.
Файли `parity` змінюються за потреби.
Файли в масиві змінюються за потреби.
<h3><a name="5.10">5.10</a> 
check
</h3>
Перевіряє всі файли та дані парності.
<p>
Працює як `fix`, але лише імітує відновлення, і жодні зміни
не записуються в масив.
<p>
Ця команда в першу чергу призначена для ручної перевірки,
наприклад, після процесу відновлення або в інших особливих
умовах. Для періодичних та запланованих перевірок використовуйте
`scrub`.
<p>
Якщо ви використовуєте опцію -a, --audit-only, перевіряється
лише хеш файлів, а дані парності ігноруються для швидшого
запуску.
<p>
Файли ідентифікуються лише за шляхом, а не за inode.
<p>
Нічого не змінюється.
<h3><a name="5.11">5.11</a> 
list
</h3>
Виводить список усіх файлів, що містяться в масиві на момент
останньої `sync`.
<p>
З -v або --verbose також показується час з точністю до
долі секунди.
<p>
Нічого не змінюється.
<h3><a name="5.12">5.12</a> 
dup
</h3>
Виводить список усіх дублікатів файлів. Два файли вважаються
рівними, якщо їхні хеші збігаються. Дані файлів не
зчитуються; використовуються лише попередньо обчислені хеші.
<p>
Нічого не змінюється.
<h3><a name="5.13">5.13</a> 
pool
</h3>
Створює або оновлює віртуальне представлення всіх файлів
у вашому дисковому масиві в каталозі `pooling`.
<p>
Файли не копіюються, а пов'язуються за допомогою символічних
посилань.
<p>
Під час оновлення всі існуючі символічні посилання та порожні
підкаталоги видаляються та замінюються новим
представленням масиву. Будь-які інші звичайні файли залишаються
на місці.
<p>
Нічого не змінюється за межами каталогу pool.
<h3><a name="5.14">5.14</a> 
devices
</h3>
Виводить низькорівневі пристрої, які використовуються масивом.
<p>
Ця команда відображає асоціації пристроїв у масиві і в
основному призначена як інтерфейс для сценаріїв.
<p>
Перші два стовпці — це низькорівневий ідентифікатор пристрою
та шлях.
Наступні два стовпці — це високорівневий ідентифікатор пристрою
та шлях.
Останній стовпець — це ім'я диска в масиві.
<p>
У більшості випадків у вас є один низькорівневий пристрій для
кожного диска в масиві, але в деяких складніших конфігураціях
у вас може бути кілька низькорівневих пристроїв, які використовуються
одним диском у масиві.
<p>
Нічого не змінюється.
<h3><a name="5.15">5.15</a> 
touch
</h3>
Встановлює довільну часову мітку з точністю до долі секунди
для всіх файлів, у яких вона встановлена на нуль.
<p>
Це покращує здатність SnapRAID розпізнавати переміщені та
скопійовані файли, оскільки робить часову мітку майже
унікальною, зменшуючи можливі дублікати.
<p>
Зокрема, якщо часова мітка з точністю до долі секунди не
дорівнює нулю, переміщений або скопійований файл ідентифікується
як такий, якщо він збігається з іменем, розміром та часовою
міткою. Якщо часова мітка з точністю до долі секунди дорівнює
нулю, він вважається копією, лише якщо повний шлях, розмір та
часова мітка збігаються.
<p>
Часова мітка з точністю до секунди не змінюється, тому
всі дати та час ваших файлів будуть збережені.
<h3><a name="5.16">5.16</a> 
rehash
</h3>
Планує повторне хешування всього масиву.
<p>
Ця команда змінює тип хешу, що використовується, як правило,
при оновленні з 32-розрядної системи на 64-розрядну, щоб
переключитися з MurmurHash3 на швидший SpookyHash.
<p>
Якщо ви вже використовуєте оптимальний хеш, ця команда
нічого не робить і повідомляє, що жодних дій не потрібно.
<p>
Повторне хешування не виконується негайно, а відбувається
поступово під час `sync` та `scrub`.
<p>
Ви можете перевірити стан повторного хешування за допомогою
`status`.
<p>
Під час повторного хешування SnapRAID зберігає повну
функціональність, за єдиним винятком, що `dup` не може
виявити дублікати файлів, використовуючи інший хеш.
<h2><a name="6">6</a> 
Опції
</h2>
SnapRAID надає наступні опції:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-c, --conf CONFIG
</strong></td></tr><tr><td>
Вибирає конфігураційний файл для використання. Якщо не
вказано, в Unix використовується файл `/usr/local/etc/snapraid.conf`,
якщо він існує, інакше `/etc/snapraid.conf`.
У Windows використовується файл `snapraid.conf` у тому
самому каталозі, що й `snapraid.exe`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-f, --filter PATTERN
</strong></td></tr><tr><td>
Фільтрує файли для обробки у `check` та `fix`.
Обробляються лише файли, що відповідають вказаному
шаблону. Цю опцію можна використовувати кілька разів.
Дивіться розділ PATTERN для отримання додаткової
інформації про специфікації шаблонів.
В Unix переконайтеся, що символи глоббінгу взяті
в лапки, якщо вони використовуються.
Цю опцію можна використовувати лише з `check` та `fix`.
Її не можна використовувати з `sync` та `scrub`, оскільки
вони завжди обробляють весь масив.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-d, --filter-disk NAME
</strong></td></tr><tr><td>
Фільтрує диски для обробки у `check`, `fix`, `up` та `down`.
Ви повинні вказати ім'я диска, як визначено у
конфігураційному файлі.
Ви також можете вказати диски парності з іменами:
`parity`, `2-parity`, `3-parity`, тощо, щоб обмежити
операції певним диском парності.
Якщо ви поєднуєте кілька опцій --filter, --filter-disk
та --filter-missing, вибираються лише файли, що
відповідають усім фільтрам.
Цю опцію можна використовувати кілька разів.
Цю опцію можна використовувати лише з `check`, `fix`,
`up` та `down`.
Її не можна використовувати з `sync` та `scrub`, оскільки
вони завжди обробляють весь масив.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-m, --filter-missing
</strong></td></tr><tr><td>
Фільтрує файли для обробки у `check` та `fix`.
Обробляються лише файли, що відсутні або видалені з
масиву. При використанні з `fix` це діє як команда
`undelete` (відновлення видалених файлів).
Якщо ви поєднуєте кілька опцій --filter, --filter-disk
та --filter-missing, вибираються лише файли, що
відповідають усім фільтрам.
Цю опцію можна використовувати лише з `check` та `fix`.
Її не можна використовувати з `sync` та `scrub`, оскільки
вони завжди обробляють весь масив.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-e, --filter-error
</strong></td></tr><tr><td>
Обробляє файли з помилками у `check` та `fix`.
Обробляє лише файли, які мають блоки, позначені
прихованими помилками або помилками введення/виведення
під час `sync` та `scrub`, як зазначено у `status`.
Цю опцію можна використовувати лише з `check` та `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-p, --plan PERC|bad|new|full
</strong></td></tr><tr><td>
Вибирає план скрабування. Якщо PERC є числовим
значенням від 0 до 100, воно інтерпретується як відсоток
блоків для скрабування.
Замість відсотка ви можете вказати план: `bad`
скрабує погані блоки, `new` скрабує блоки, які ще не
були скрабовані, і `full` скрабує все.
Цю опцію можна використовувати лише з `scrub`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-o, --older-than DAYS
</strong></td></tr><tr><td>
Вибирає найстарішу частину масиву для обробки у `scrub`.
DAYS — це мінімальний вік у днях для блоку, який
повинен бути скрабований; за замовчуванням 10.
Блоки, позначені як погані, завжди скрабуються
незалежно від цієї опції.
Цю опцію можна використовувати лише з `scrub`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-a, --audit-only
</strong></td></tr><tr><td>
У `check` перевіряє хеш файлів без перевірки даних
парності. Якщо вас цікавить лише перевірка даних файлів,
ця опція може значно прискорити процес перевірки.
Цю опцію можна використовувати лише з `check`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-h, --pre-hash
</strong></td></tr><tr><td>
У `sync` запускає попередню фазу хешування всіх нових
даних для додаткової перевірки перед обчисленням
парності. Зазвичай у `sync` не виконується попереднє
хешування, а нові дані хешуються безпосередньо перед
обчисленням парності, коли вони зчитуються вперше.
Цей процес відбувається, коли система знаходиться під
великим навантаженням, усі диски обертаються та ЦП
зайнятий. Це екстремальна умова для машини, і якщо вона
має приховану апаратну проблему, приховані помилки
можуть залишитися невиявленими, оскільки дані ще не
були хешовані.
Щоб уникнути цього ризику, ви можете ввімкнути режим
`pre-hash`, щоб усі дані були зчитані двічі для
забезпечення їх цілісності.
Ця опція також перевіряє файли, переміщені в межах
масиву, щоб переконатися, що операція переміщення була
успішною, і, якщо необхідно, дозволяє запустити операцію
виправлення перед продовженням.
Цю опцію можна використовувати лише з `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-i, --import DIR
</strong></td></tr><tr><td>
Імпортує з вказаного каталогу будь-які файли, видалені
з масиву після останньої `sync`.
Якщо у вас все ще є такі файли, вони можуть бути
використані `check` та `fix` для покращення процесу
відновлення.
Файли зчитуються, включаючи підкаталоги, та
ідентифікуються незалежно від їхнього імені.
Цю опцію можна використовувати лише з `check` та `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-s, --spin-down-on-error
</strong></td></tr><tr><td>
При будь-якій помилці зупиняє всі керовані диски перед
завершенням з ненульовим кодом стану. Це запобігає
тому, щоб диски залишалися активними та оберталися
після перерваної операції, допомагаючи уникнути
зайвого нагрівання та споживання електроенергії.
Використовуйте цю опцію, щоб забезпечити безпечну
зупинку дисків, навіть коли команда завершується
помилкою.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-w, --bw-limit RATE
</strong></td></tr><tr><td>
Застосовує глобальне обмеження пропускної здатності
для всіх дисків. RATE — це кількість байтів на секунду.
Ви можете вказати множник, такий як K, M або G (наприклад,
--bw-limit 1G).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-A, --stats
</strong></td></tr><tr><td>
Вмикає розширений перегляд стану, який показує
додаткову інформацію.
На екрані відображаються два графіки:
Перший графік показує кількість буферизованих смуг
(stripes) для кожного диска, разом зі шляхом до файлу,
до якого наразі здійснюється доступ на цьому диску.
Зазвичай найповільніший диск не матиме доступного
буфера, що визначає максимально досяжну пропускну
здатність.
Другий графік показує відсоток часу, витраченого на
очікування, за останні 100 секунд. Очікується, що
найповільніший диск спричинить більшу частину часу
очікування, тоді як інші диски повинні мати невеликий
час очікування або зовсім його не мати, оскільки
вони можуть використовувати свої буферизовані смуги.
Цей графік також показує час, витрачений на очікування
обчислення хешу та обчислень RAID.
Усі обчислення виконуються паралельно з операціями
диска. Тому, доки є вимірюваний час очікування
принаймні для одного диска, це вказує на те, що ЦП
достатньо швидкий, щоб справлятися з робочим навантаженням.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-Z, --force-zero
</strong></td></tr><tr><td>
Форсує небезпечну операцію синхронізації файлу з
нульовим розміром, який раніше був ненульовим.
Якщо SnapRAID виявляє таку умову, він припиняє
продовження, якщо ви не вкажете цю опцію.
Це дозволяє легко виявити, коли після збою системи
деякі доступні файли були обрізані.
Це можлива умова в Linux з файловими системами
ext3/ext4.
Цю опцію можна використовувати лише з `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-E, --force-empty
</strong></td></tr><tr><td>
Форсує небезпечну операцію синхронізації диска, на
якому відсутні всі оригінальні файли.
Якщо SnapRAID виявляє, що всі файли, які спочатку
були на диску, відсутні або перезаписані, він
припиняє продовження, якщо ви не вкажете цю опцію.
Це дозволяє легко виявити, коли файлова система
даних не змонтована.
Цю опцію можна використовувати лише з `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-U, --force-uuid
</strong></td></tr><tr><td>
Форсує небезпечну операцію синхронізації, перевірки
та виправлення з дисками, які змінили свій UUID.
Якщо SnapRAID виявляє, що деякі диски змінили UUID,
він припиняє продовження, якщо ви не вкажете цю опцію.
Це дозволяє виявити, коли ваші диски змонтовані
в неправильних точках монтування.
Однак, дозволено мати одну зміну UUID з однією парністю
і більше з множинною парністю, оскільки це нормальний
випадок при заміні дисків після відновлення.
Цю опцію можна використовувати лише з `sync`, `check`
або `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-D, --force-device
</strong></td></tr><tr><td>
Форсує небезпечну операцію виправлення з недоступними
дисками або з дисками на тому ж фізичному пристрої.
Наприклад, якщо ви втратили два диски даних і маєте
запасний диск для відновлення лише першого, ви можете
ігнорувати другий недоступний диск.
Або, якщо ви хочете відновити диск у вільному місці,
залишеному на вже використовуваному диску, що
використовує той самий фізичний пристрій.
Цю опцію можна використовувати лише з `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-N, --force-nocopy
</strong></td></tr><tr><td>
У `sync`, `check` та `fix` вимикає евристику
виявлення копій. Без цієї опції SnapRAID припускає,
що файли з однаковими атрибутами, такими як ім'я,
розмір та часова мітка, є копіями з тими ж даними.
Це дозволяє ідентифікувати скопійовані або
переміщені файли з одного диска на інший і повторно
використовує вже обчислену інформацію хешу для
виявлення прихованих помилок або для відновлення
відсутніх файлів.
У деяких рідкісних випадках ця поведінка може
призвести до хибних спрацьовувань або повільного
процесу через багато перевірок хешу, і ця опція
дозволяє вирішити такі проблеми.
Цю опцію можна використовувати лише з `sync`, `check`
та `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-F, --force-full
</strong></td></tr><tr><td>
У `sync` форсує повне переобчислення парності.
Цю опцію можна використовувати, коли ви додаєте
новий рівень парності або якщо ви повернулися до
старого файлу вмісту, використовуючи більш
нові дані парності.
Замість створення парності з нуля, це дозволяє
повторно використовувати хеші, присутні у файлі
вмісту, для перевірки даних та підтримки захисту
даних під час процесу `sync`, використовуючи
існуючі дані парності.
Цю опцію можна використовувати лише з `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-R, --force-realloc
</strong></td></tr><tr><td>
У `sync` форсує повне перерозподілення файлів
та перебудову парності.
Цю опцію можна використовувати для повного
перерозподілу всіх файлів, усуваючи фрагментацію,
повторно використовуючи хеші, присутні у файлі
вмісту, для перевірки даних.
Цю опцію можна використовувати лише з `sync`.
УВАГА! Ця опція лише для експертів, і
настійно не рекомендується її використовувати.
Ви НЕ маєте захисту даних під час операції `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-l, --log FILE
</strong></td></tr><tr><td>
Записує детальний журнал у вказаний файл.
Якщо ця опція не вказана, несподівані помилки
виводяться на екран, що потенційно призводить до
надмірного виведення у випадку багатьох помилок.
Коли вказано -l, --log, на екран виводяться лише
фатальні помилки, які спричиняють зупинку SnapRAID.
Якщо шлях починається з '&gt;&gt;', файл відкривається
у режимі доповнення. Входження '%D' та '%T' в
імені замінюються датою та часом у форматі YYYYMMDD
та HHMMSS. У пакетних файлах Windows ви повинні
подвоїти символ '%', наприклад, result-%%D.log.
Щоб використовувати '&gt;&gt;', ви повинні взяти ім'я
в лапки, наприклад, `"&gt;&gt;result.log"`.
Щоб вивести журнал на стандартний вивід або
стандартну помилку, ви можете використовувати
`"&gt;&amp;1"` та `"&gt;&amp;2"` відповідно.
Дивіться файл snapraid_log.txt або man-сторінку
для описів тегів журналу.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-L, --error-limit NUMBER
</strong></td></tr><tr><td>
Встановлює новий ліміт помилок перед зупинкою
виконання. За замовчуванням SnapRAID зупиняється,
якщо зустрічає більше 100 помилок введення/виведення,
що вказує на ймовірну відмову диска.
Ця опція впливає на `sync` та `scrub`, яким
дозволено продовжувати після першого набору
помилок диска, щоб спробувати завершити
свої операції. Однак `check` та `fix` завжди
зупиняються при першій помилці.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-S, --start BLKSTART
</strong></td></tr><tr><td>
Починає обробку з вказаного номера блоку.
Це може бути корисно для повторної спроби
перевірки або виправлення певних блоків у
випадку пошкодженого диска.
Ця опція в основному для розширеного ручного
відновлення.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-B, --count BLKCOUNT
</strong></td></tr><tr><td>
Обробляє лише вказану кількість блоків.
Ця опція в основному для розширеного ручного
відновлення.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-C, --gen-conf CONTENT
</strong></td></tr><tr><td>
Генерує фіктивний конфігураційний файл з існуючого
файлу вмісту.
Конфігураційний файл записується на стандартний
вивід і не перезаписує існуючий.
Цей конфігураційний файл також містить інформацію,
необхідну для реконструкції точок монтування диска
у випадку втрати всієї системи.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-v, --verbose
</strong></td></tr><tr><td>
Виводить більше інформації на екран.
Якщо вказано один раз, виводить виключені файли
та додаткову статистику.
Ця опція не впливає на файли журналу.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-q, --quiet
</strong></td></tr><tr><td>
Виводить менше інформації на екран.
Якщо вказано один раз, видаляє індикатор прогресу;
двічі — поточні операції; тричі — інформаційні
повідомлення; чотири рази — повідомлення про
статус. Фатальні помилки завжди виводяться на
екран. Ця опція не впливає на файли журналу.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-H, --help
</strong></td></tr><tr><td>
Виводить короткий довідковий екран.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-V, --version
</strong></td></tr><tr><td>
Виводить версію програми.
</td></tr>
</table>
<h2><a name="7">7</a> 
Конфігурація
</h2>
SnapRAID вимагає конфігураційний файл, щоб знати, де
розташований ваш дисковий масив і де зберігати інформацію
парності.
<p>
В Unix використовується файл `/usr/local/etc/snapraid.conf`,
якщо він існує, інакше `/etc/snapraid.conf`.
У Windows використовується файл `snapraid.conf` у тому
самому каталозі, що й `snapraid.exe`.
<p>
Він повинен містити наступні опції (чутливі до регістру):
<h3><a name="7.1">7.1</a> 
parity FILE [,FILE] ...
</h3>
Визначає файли, які потрібно використовувати для зберігання
інформації парності. Парність забезпечує захист від
відмови одного диска, подібно до RAID5.
<p>
Ви можете вказати кілька файлів, які повинні бути на
різних дисках. Коли файл більше не може зростати,
використовується наступний.
Загальний доступний простір повинен бути принаймні
таким же великим, як найбільший диск даних у масиві.
<p>
Ви можете додати додаткові файли парності пізніше,
але ви не можете їх переупорядковувати або видаляти.
<p>
Збереження дисків парності зарезервованими для парності
забезпечує, що вони не стають фрагментованими, покращуючи
продуктивність.
<p>
У Windows 256 МБ залишається невикористаними на кожному
диску, щоб уникнути попередження про повні диски.
<p>
Ця опція є обов'язковою і може бути використана лише один раз.
<h3><a name="7.2">7.2</a> 
(2,3,4,5,6)-parity FILE [,FILE] ...
</h3>
Визначає файли, які потрібно використовувати для зберігання
додаткової інформації парності.
<p>
Для кожного вказаного рівня парності вмикається один
додатковий рівень захисту:
<ul>
<li>
2-parity вмикає подвійну парність RAID6.
</li>
<li>
3-parity вмикає потрійну парність.
</li>
<li>
4-parity вмикає четверну парність.
</li>
<li>
5-parity вмикає п'ятерну парність.
</li>
<li>
6-parity вмикає шестерну парність.
</li>
</ul>
<p>
Кожен рівень парності вимагає наявності всіх попередніх
рівнів парності.
<p>
Застосовуються ті самі міркування, що й для опції 'parity'.
<p>
Ці опції є необов'язковими і можуть бути використані лише
один раз.
<h3><a name="7.3">7.3</a> 
z-parity FILE [,FILE] ...
</h3>
Визначає альтернативний файл та формат для зберігання
потрійної парності.
<p>
Ця опція є альтернативою '3-parity', в першу чергу
призначена для ЦП низького класу, таких як ARM або
AMD Phenom, Athlon та Opteron, які не підтримують
набір інструкцій SSSE3. У таких випадках вона
забезпечує кращу продуктивність.
<p>
Цей формат схожий, але швидший, ніж той, що використовується
ZFS RAIDZ3. Як і ZFS, він не працює далі потрійної парності.
<p>
При використанні '3-parity' ви будете попереджені,
якщо рекомендується використовувати формат 'z-parity'
для покращення продуктивності.
<p>
Можна конвертувати з одного формату в інший, налаштувавши
конфігураційний файл з бажаним файлом z-parity або
3-parity та використовуючи 'fix' для його відтворення.
<h3><a name="7.4">7.4</a> 
content FILE
</h3>
Визначає файл, який потрібно використовувати для зберігання
списку та контрольних сум усіх файлів, присутніх у
вашому дисковому масиві.
<p>
Він може бути розміщений на диску, що використовується для
даних, парності або будь-якому іншому доступному диску.
Якщо ви використовуєте диск даних, цей файл автоматично
виключається з процесу `sync`.
<p>
Ця опція є обов'язковою і може бути використана кілька
разів для збереження кількох копій одного і того ж
файлу.
<p>
Ви повинні зберігати принаймні одну копію для кожного
використаного диска парності плюс одну. Використання
додаткових копій не зашкодить.
<h3><a name="7.5">7.5</a> 
data NAME DIR
</h3>
Визначає ім'я та точку монтування дисків даних у
масиві. NAME використовується для ідентифікації диска
і має бути унікальним. DIR — це точка монтування
диска у файловій системі.
<p>
Ви можете змінювати точку монтування за потреби,
поки ви зберігаєте NAME фіксованим.
<p>
Ви повинні використовувати одну опцію для кожного
диска даних у масиві.
<p>
Ви можете перейменувати диск пізніше, змінивши NAME
безпосередньо у конфігураційному файлі, а потім
запустивши команду 'sync'. У випадку перейменування
асоціація здійснюється за допомогою збереженого
UUID дисків.
<h3><a name="7.6">7.6</a> 
nohidden
</h3>
Виключає всі приховані файли та каталоги.
В Unix приховані файли — це ті, що починаються з `.`.
У Windows це ті, що мають прихований атрибут.
<h3><a name="7.7">7.7</a> 
exclude/include PATTERN
</h3>
Визначає шаблони файлів або каталогів для виключення
або включення у процес синхронізації.
Усі шаблони обробляються у вказаному порядку.
<p>
Якщо перший шаблон, який збігається, є `exclude` (виключити),
файл виключається. Якщо він є `include` (включити),
файл включається.
Якщо жоден шаблон не збігається, файл виключається,
якщо останній вказаний шаблон є `include`, або
включається, якщо останній вказаний шаблон є `exclude`.
<p>
Дивіться розділ PATTERN для отримання додаткової
інформації про специфікації шаблонів.
<p>
Цю опцію можна використовувати кілька разів.
<h3><a name="7.8">7.8</a> 
blocksize SIZE_IN_KIBIBYTES
</h3>
Визначає основний розмір блоку в кібібайтах для парності.
Один кібібайт дорівнює 1024 байтам.
<p>
Розмір блоку за замовчуванням становить 256, що має
працювати для більшості випадків.
<p>
УВАГА! Ця опція лише для експертів, і настійно
не рекомендується змінювати це значення. Щоб змінити
це значення в майбутньому, вам потрібно буде
перестворити всю парність!
<p>
Причина використовувати інший розмір блоку полягає
в тому, якщо у вас є багато невеликих файлів, порядку
мільйонів.
<p>
Для кожного файлу, навіть якщо це лише кілька байтів,
виділяється цілий блок парності, і з багатьма файлами
це може призвести до значного невикористаного місця
парності. Коли ви повністю заповнюєте диск парності,
вам не дозволяється додавати більше файлів на диски
даних. Однак, витрачена парність не накопичується
між дисками даних. Витрачене місце внаслідок великої
кількості файлів на диску даних обмежує лише кількість
даних на цьому диску даних, а не на інших.
<p>
Як наближення, ви можете припустити, що половина
розміру блоку витрачається для кожного файлу.
Наприклад, зі 100 000 файлами та розміром блоку 256 КіБ
ви витратите 12,8 ГБ парності, що може призвести до
того, що на диску даних буде на 12,8 ГБ менше місця.
<p>
Ви можете перевірити кількість витраченого місця на
кожному диску за допомогою `status`. Це кількість
місця, яку ви повинні залишити вільною на дисках даних
або використовувати для файлів, не включених у масив.
Якщо це значення від'ємне, це означає, що ви
наближаєтеся до заповнення парності, і воно
представляє місце, яке ви ще можете витратити.
<p>
Щоб уникнути цієї проблеми, ви можете використовувати
більший розділ для парності. Наприклад, якщо розділ
парності на 12,8 ГБ більший за диски даних, у вас є
достатньо додаткового місця для обробки до 100 000
файлів на кожному диску даних без будь-якого
витраченого місця.
<p>
Хитрість, щоб отримати більший розділ парності в
Linux, полягає в тому, щоб відформатувати його
командою:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
mkfs.ext4 -m 0 -T largefile4 DEVICE
</pre>
</td></tr></table>
<p>
Це призводить до приблизно 1,5% додаткового місця,
приблизно 60 ГБ для диска 4 ТБ, що дозволяє
приблизно 460 000 файлів на кожному диску даних
без будь-якого витраченого місця.
<h3><a name="7.9">7.9</a> 
hashsize SIZE_IN_BYTES
</h3>
Визначає розмір хешу в байтах для збережених блоків.
<p>
Розмір хешу за замовчуванням становить 16 байтів
(128 біт), що має працювати для більшості випадків.
<p>
УВАГА! Ця опція лише для експертів, і настійно
не рекомендується змінювати це значення. Щоб змінити
це значення в майбутньому, вам потрібно буде
перестворити всю парність!
<p>
Причина використовувати інший розмір хешу полягає
в тому, якщо ваша система має обмежену пам'ять.
Як правило, SnapRAID зазвичай вимагає 1 ГіБ ОЗП
на кожні 16 ТБ даних у масиві.
<p>
Зокрема, для зберігання хешів даних SnapRAID
вимагає приблизно $TS \times (1+HS) / BS$ байтів
ОЗП, де TS — загальний розмір вашого дискового масиву
у байтах, BS — розмір блоку у байтах, а HS —
розмір хешу у байтах.
<p>
Наприклад, з 8 дисками по 4 ТБ, розміром блоку 256 КіБ
(1 КіБ = 1024 байта) та розміром хешу 16, ви отримуєте:
<p>
<pre>
RAM = $(8 \times 4 \times 10^{12}) \times (1+16) / (256 \times 2^{10}) = 1.93$ ГіБ
</pre>
<p>
Перехід до розміру хешу 8, ви отримуєте:
<p>
<pre>
RAM = $(8 \times 4 \times 10^{12}) \times (1+8) / (256 \times 2^{10}) = 1.02$ ГіБ
</pre>
<p>
Перехід до розміру блоку 512, ви отримуєте:
<p>
<pre>
RAM = $(8 \times 4 \times 10^{12}) \times (1+16) / (512 \times 2^{10}) = 0.96$ ГіБ
</pre>
<p>
Перехід до розміру хешу 8 та розміру блоку 512, ви отримуєте:
<p>
<pre>
RAM = $(8 \times 4 \times 10^{12}) \times (1+8) / (512 \times 2^{10}) = 0.51$ ГіБ
</pre>
<h3><a name="7.10">7.10</a> 
autosave SIZE_IN_GIGABYTES
</h3>
Автоматично зберігає стан під час синхронізації або
скрабування після обробки вказаної кількості ГБ.
Ця опція корисна, щоб уникнути перезапуску довгих
команд `sync` з нуля, якщо вони були перервані
збоєм машини або будь-якою іншою подією.
<h3><a name="7.11">7.11</a> 
temp_limit TEMPERATURE_CELSIUS
</h3>
Встановлює максимальну дозволену температуру диска
в Цельсіях. Якщо вказано, SnapRAID періодично перевіряє
температуру всіх дисків за допомогою інструменту
smartctl. Поточні температури дисків відображаються
під час роботи SnapRAID. Якщо будь-який диск перевищує
цей ліміт, усі операції зупиняються, і диски
зупиняються (переходять у режим очікування) на час,
визначений опцією `temp_sleep`. Після періоду
очікування операції відновлюються, потенційно
знову призупиняючись, якщо ліміт температури знову
досягнутий.
<p>
Під час роботи SnapRAID також аналізує криву
нагрівання кожного диска та оцінює довгострокову
стабільну температуру, якої вони, як очікується,
досягнуть, якщо активність продовжиться.
Оцінка виконується лише після того, як температура
диска підвищилася чотири рази, що гарантує наявність
достатньої кількості даних для встановлення
надійного тренду. Ця прогнозована стабільна
температура відображається в дужках поруч із
поточним значенням і допомагає оцінити, чи
достатнє охолодження системи. Ця оцінювана
температура є лише інформаційною і не впливає на
поведінку SnapRAID. Дії програми базуються
виключно на фактично виміряних температурах
дисків.
<p>
Для виконання цього аналізу SnapRAID потрібна
довідкова інформація про температуру системи.
Спочатку він намагається зчитати її з доступних
апаратних датчиків. Якщо до системного датчика
неможливо отримати доступ, він використовує
найнижчу температуру диска, виміряну на початку
запуску, як резервну довідкову інформацію.
<p>
Зазвичай SnapRAID показує лише температуру
найгарячішого диска. Щоб відобразити температуру
всіх дисків, використовуйте опцію -A або --stats.
<h3><a name="7.12">7.12</a> 
temp_sleep TIME_IN_MINUTES
</h3>
Встановлює час очікування, у хвилинах, коли
досягнуто ліміту температури. Протягом цього
періоду диски залишаються зупиненими.
За замовчуванням 5 хвилин.
<h3><a name="7.13">7.13</a> 
pool DIR
</h3>
Визначає каталог об'єднання, де створюється
віртуальне представлення дискового масиву за
допомогою команди `pool`.
<p>
Каталог повинен вже існувати.
<h3><a name="7.14">7.14</a> 
share UNC_DIR
</h3>
Визначає шлях Windows UNC, необхідний для
віддаленого доступу до дисків.
<p>
Якщо ця опція вказана, символічні посилання,
створені в каталозі pool, використовують цей
шлях UNC для доступу до дисків.
Без цієї опції згенеровані символічні посилання
використовують лише локальні шляхи, що не
дозволяє спільно використовувати каталог pool
через мережу.
<p>
Символічні посилання формуються за допомогою
вказаного шляху UNC, додаючи ім'я диска, як
зазначено в опції `data`, і, нарешті,
додаючи каталог та ім'я файлу.
<p>
Ця опція потрібна лише для Windows.
<h3><a name="7.15">7.15</a> 
smartctl DISK/PARITY OPTIONS...
</h3>
Визначає користувацькі опції smartctl для
отримання атрибутів SMART для кожного диска.
Це може знадобитися для RAID-контролерів та
деяких USB-дисків, які не можуть бути
автоматично виявлені. Заповнювач %s
замінюється іменем пристрою, але він
необов'язковий для фіксованих пристроїв,
таких як RAID-контролери.
<p>
DISK — це те саме ім'я диска, вказане в опції `data`.
PARITY — це одне з імен парності: `parity`,
`2-parity`, `3-parity`, `4-parity`, `5-parity`,
`6-parity` або `z-parity`.
<p>
У вказаних OPTIONS рядок `%s` замінюється
іменем пристрою. Для RAID-контролерів пристрій
ймовірно фіксований, і вам може не знадобитися
використовувати `%s`.
<p>
Зверніться до документації smartmontools
для можливих опцій:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.smartmontools.org/wiki/Supported_RAID-Controllers
https://www.smartmontools.org/wiki/Supported_USB-Devices
</pre>
</td></tr></table>
<p>
Наприклад:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
smartctl parity -d sat %s
</pre>
</td></tr></table>
<h3><a name="7.16">7.16</a> 
smartignore DISK/PARITY ATTR [ATTR...]
</h3>
Ігнорує вказаний атрибут SMART при обчисленні
ймовірності відмови диска. Ця опція корисна,
якщо диск повідомляє незвичайні або
оманливі значення для певного атрибута.
<p>
DISK — це те саме ім'я диска, вказане в опції `data`.
PARITY — це одне з імен парності: `parity`,
`2-parity`, `3-parity`, `4-parity`, `5-parity`,
`6-parity` або `z-parity`.
Спеціальне значення * можна використовувати
для ігнорування атрибута на всіх дисках.
<p>
Наприклад, щоб ігнорувати атрибут `Current Pending Sector Count`
на всіх дисках:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
smartignore * 197
</pre>
</td></tr></table>
<p>
Щоб ігнорувати його лише на першому диску парності:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
smartignore parity 197
</pre>
</td></tr></table>
<h3><a name="7.17">7.17</a> 
Приклади
</h3>
Приклад типової конфігурації для Unix:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity /mnt/diskp/snapraid.parity
content /mnt/diskp/snapraid.content
content /var/snapraid/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
exclude /lost+found/
exclude /tmp/
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/sg0
smartctl 2-parity -d areca,2/1 /dev/sg0
</pre>
</td></tr></table>
<p>
Приклад типової конфігурації для Windows:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity E:\snapraid.parity
content E:\snapraid.content
content C:\snapraid\snapraid.content
data d1 G:\array\
data d2 H:\array\
data d3 I:\array\
exclude Thumbs.db
exclude \$RECYCLE.BIN
exclude \System Volume Information
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/arcmsr0
smartctl 2-parity -d areca,2/1 /dev/arcmsr0
</pre>
</td></tr></table>
<h2><a name="8">8</a> 
Шаблон (Pattern)
</h2>
Шаблони використовуються для вибору підмножини файлів
для виключення або включення в процес.
<p>
Існує чотири різні типи шаблонів:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
FILE
</strong></td></tr><tr><td>
Вибирає будь-який файл з іменем FILE. Ви можете
використовувати будь-які символи глоббінгу,
такі як * та ?, та класи символів, такі як [a-z].
Цей шаблон застосовується лише до файлів, а не
до каталогів.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
DIR/
</strong></td></tr><tr><td>
Вибирає будь-який каталог з іменем DIR та все
всередині. Ви можете використовувати будь-які
символи глоббінгу, такі як * та ?.
Цей шаблон застосовується лише до каталогів,
а не до файлів.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
/PATH/FILE
</strong></td></tr><tr><td>
Вибирає точно вказаний шлях до файлу. Ви можете
використовувати будь-які символи глоббінгу, такі
як * та ?, але вони ніколи не збігаються з
похилою рискою каталогу.
Цей шаблон застосовується лише до файлів,
а не до каталогів.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
/PATH/DIR/
</strong></td></tr><tr><td>
Вибирає точно вказаний шлях до каталогу та все
всередині. Ви можете використовувати будь-які
символи глоббінгу, такі як * та ?, але вони
ніколи не збігаються з похилою рискою каталогу.
Цей шаблон застосовується лише до каталогів,
а не до файлів.
</td></tr>
</table>
<p>
Коли ви вказуєте абсолютний шлях, що починається
з /, він застосовується до кореневого каталогу
масиву, а не до кореневого каталогу локальної
файлової системи.
<p>
У Windows ви можете використовувати зворотну
скісну риску \ замість прямої скісної риски /.
Системні каталоги Windows, з'єднання, точки
монтування та інші спеціальні каталоги Windows
розглядаються як файли, що означає, що для
їх виключення ви повинні використовувати правило
файлу, а не правило каталогу.
<p>
Якщо ім'я файлу містить символи '*', '?', '[',
або ']', ви повинні екранувати їх, щоб уникнути
їх інтерпретації як символу глоббінгу.
В Unix символом екранування є '\'; у Windows — '^'.
Коли шаблон знаходиться в командному рядку,
ви повинні подвоїти символ екранування, щоб
запобігти його інтерпретації командною оболонкою.
<p>
У конфігураційному файлі ви можете використовувати
різні стратегії для фільтрації файлів, які потрібно
обробити.
Найпростіший підхід — використовувати лише
правила `exclude` для видалення всіх файлів та
каталогів, які ви не хочете обробляти.
Наприклад:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Виключає будь-який файл з іменем `*.unrecoverable`
exclude *.unrecoverable
# Виключає кореневий каталог `/lost+found`
exclude /lost+found/
# Виключає будь-який підкаталог з іменем `tmp`
exclude tmp/
</pre>
</td></tr></table>
<p>
Протилежний підхід — визначити лише файли,
які ви хочете обробити, використовуючи лише
правила `include`. Наприклад:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Включає лише деякі каталоги
include /movies/
include /musics/
include /pictures/
</pre>
</td></tr></table>
<p>
Останній підхід — змішувати правила `exclude`
та `include`. У цьому випадку порядок правил
важливий. Раніші правила мають пріоритет
над пізнішими.
Для спрощення ви можете спочатку перерахувати
всі правила `exclude`, а потім усі правила `include`.
Наприклад:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Виключає будь-який файл з іменем `*.unrecoverable`
exclude *.unrecoverable
# Виключає будь-який підкаталог з іменем `tmp`
exclude tmp/
# Включає лише деякі каталоги
include /movies/
include /musics/
include /pictures/
</pre>
</td></tr></table>
<p>
У командному рядку, використовуючи опцію -f,
ви можете використовувати лише шаблони `include`.
Наприклад:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Перевіряє лише файли .mp3.
# В Unix використовуйте лапки, щоб уникнути
# розширення глоббінгу оболонкою.
snapraid -f "*.mp3" check
</pre>
</td></tr></table>
<p>
В Unix, при використанні символів глоббінгу в
командному рядку, ви повинні взяти їх у лапки,
щоб запобігти їх розширенню оболонкою.
<h2><a name="9">9</a> 
Вміст (Content)
</h2>
SnapRAID зберігає список та контрольні суми
ваших файлів у файлі вмісту.
<p>
Це бінарний файл, який перераховує всі файли,
присутні у вашому дисковому масиві, разом з
усіма контрольними сумами для перевірки їх
цілісності.
<p>
Цей файл зчитується та записується командами
`sync` та `scrub` та зчитується командами `fix`,
`check` та `status`.
<h2><a name="10">10</a> 
Парність (Parity)
</h2>
SnapRAID зберігає інформацію парності вашого
масиву у файлах парності.
<p>
Це бінарні файли, що містять обчислену
парність усіх блоків, визначених у файлі
`content`.
<p>
Ці файли зчитуються та записуються командами
`sync` та `fix` і лише зчитуються командами
`scrub` та `check`.
<h2><a name="11">11</a> 
Кодування (Encoding)
</h2>
SnapRAID в Unix ігнорує будь-яке кодування.
Він зчитує та зберігає імена файлів з
тим самим кодуванням, що використовується
файловою системою.
<p>
У Windows усі імена, зчитані з файлової
системи, конвертуються та обробляються
у форматі UTF-8.
<p>
Щоб імена файлів відображалися правильно,
ви повинні встановити консоль Windows
у режим UTF-8 за допомогою команди
`chcp 65001` та використовувати шрифт
TrueType, такий як `Lucida Console`, як
шрифт консолі.
Це впливає лише на надруковані імена
файлів; якщо ви перенаправляєте вивід
консолі у файл, отриманий файл завжди
буде у форматі UTF-8.
<h2><a name="12">12</a> 
Авторське право (Copyright)
</h2>
Цей файл захищений авторським правом (C) 2025 Andrea Mazzoleni
<h2><a name="13">13</a> 
Див. також (See Also)
</h2>
snapraid_log(1), rsync(1)


<p>
</p>

</div>

<div id="footer">

<div class="column">
<span class="bold">Donate with</span>
<br>
<!--
<a href="http://sourceforge.net/p/snapraid/donate/"><img src="paypal.png" width="160" height="60" alt="PayPal"></a>
-->
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=amadvance%40gmail%2ecom&lc=US&item_name=SnapRAID&no_note=0&currency_code=USD&bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHostedGuest"><img src="paypal.png" width="160" height="60" alt="PayPal"></a>
<!--
<a href="https://coinkite.com/u/amadvance/"><img src="bitcoin.png" width="160" height="60" alt="BitCoin"></a>
-->
</div>

<div class="column">
<span class="bold">Find other resources at</span>
<br>
<a href="https://github.com/amadvance/snapraid/"><img src="github.png" width="160" height="60" alt="GitHub"></a>
<a href="http://sourceforge.net/projects/snapraid/"><img src="sourceforge.png" width="115" height="60" alt="SourceForge"></a>
</div>

</div>
</body>
</html>


