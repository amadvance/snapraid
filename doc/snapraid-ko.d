Name{number}
	snapraid - 디스크 어레이를 위한 SnapRAID 백업

Synopsis
	:snapraid [-c, --conf CONFIG]
	:	[-f, --filter PATTERN] [-d, --filter-disk NAME]
	:	[-m, --filter-missing] [-e, --filter-error]
	:	[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR]
	:	[-p, --plan PERC|bad|new|full]
	:	[-o, --older-than DAYS] [-l, --log FILE]
	:	[-s, --spin-down-on-error] [-w, --bw-limit RATE]
	:	[-Z, --force-zero] [-E, --force-empty]
	:	[-U, --force-uuid] [-D, --force-device]
	:	[-N, --force-nocopy] [-F, --force-full]
	:	[-R, --force-realloc]
	:	[-S, --start BLKSTART] [-B, --count BLKCOUNT]
	:	[-L, --error-limit NUMBER]
	:	[-A, --stats]
	:	[-v, --verbose] [-q, --quiet]
	:	status|smart|probe|up|down|diff|sync|scrub|fix|check
	:	|list|dup|pool|devices|touch|rehash

	:snapraid [-V, --version] [-H, --help] [-C, --gen-conf CONTENT]

Description
	SnapRAID는 디스크 어레이를 위해 설계된 백업 프로그램으로,
	최대 6개의 디스크 오류가 발생해도 데이터를 복구하기 위한
	패리티 정보를 저장합니다.

	주로 크고 자주 변경되지 않는 파일을 가진 홈 미디어 센터를
	위해 고안된 SnapRAID는 다음과 같은 몇 가지 기능을 제공합니다:

	* 파일을 다시 포맷할 필요 없이 이미 파일로 채워진 디스크를
		활용할 수 있으며, 평소처럼 액세스할 수 있습니다.
	* 데이터 무결성을 보장하고 무단 손상을 방지하기 위해 모든 데이터가
		해시됩니다.
	* 실패한 디스크의 수가 패리티 수를 초과하는 경우, 데이터 손실은
		영향을 받은 디스크로 제한되며, 다른 디스크의 데이터는
		계속 액세스할 수 있습니다.
	* 실수로 디스크의 파일을 삭제한 경우에도 복구가 가능합니다.
	* 디스크는 서로 다른 크기를 가질 수 있습니다.
	* 언제든지 디스크를 추가할 수 있습니다.
	* SnapRAID는 데이터를 가두지 않습니다. 언제든지 포맷하거나 데이터를
		이동할 필요 없이 사용을 중단할 수 있습니다.
	* 파일에 액세스하려면 단일 디스크만 회전하면 되므로, 전력을 절약하고
		소음을 줄일 수 있습니다.

	더 자세한 정보는 공식 SnapRAID 사이트를 방문하십시오:

		:https://www.snapraid.it/

Limitations
	SnapRAID는 RAID와 백업 프로그램의 하이브리드로, 두 가지의 장점을
	결합하는 것을 목표로 합니다. 하지만, 사용 전에 고려해야 할 몇 가지
	제한 사항이 있습니다.

	주요 제한 사항은 디스크가 실패하고 최근에 동기화(sync)하지 않은 경우,
	완전히 복구하지 못할 수 있다는 것입니다.
	더 구체적으로, 마지막 동기화 작업 이후 변경되거나 삭제된 파일의
	크기만큼 복구가 불가능할 수 있습니다.
	이는 변경되거나 삭제된 파일이 실패한 디스크에 있지 않더라도 발생합니다.
	이것이 SnapRAID가 **거의 변경되지 않는 데이터**에 더 적합한 이유입니다.

	반면에, 새로 추가된 파일은 이미 존재하는 파일의 복구를 방해하지 않습니다.
	새로 추가된 파일이 실패한 디스크에 있는 경우에만 해당 파일을 잃게 됩니다.

	기타 SnapRAID 제한 사항은 다음과 같습니다:

	* SnapRAID를 사용하면 여전히 각 디스크에 대해 별도의 파일 시스템이
		있습니다. RAID를 사용하면 하나의 큰 파일 시스템을 얻습니다.
	* SnapRAID는 데이터를 스트라이핑하지 않습니다.
		RAID를 사용하면 스트라이핑으로 속도 향상을 얻습니다.
	* SnapRAID는 실시간 복구를 지원하지 않습니다.
		RAID를 사용하면 디스크가 실패했을 때 작업을 멈출 필요가 없습니다.
	* SnapRAID는 제한된 수의 디스크 오류에서만 데이터를 복구할 수 있습니다.
		백업을 사용하면 전체 디스크 어레이의 완전한 오류로부터
		복구할 수 있습니다.
	* 파일 이름, 타임스탬프, 심볼릭 링크, 하드 링크만 저장됩니다.
		권한, 소유권, 확장 속성은 저장되지 않습니다.

Getting Started
	SnapRAID를 사용하려면, 먼저 디스크 어레이에서 하나의 디스크를
	`parity`(패리티) 정보 전용으로 선택해야 합니다. 하나의 패리티 디스크로
	RAID5와 유사하게 단일 디스크 오류로부터 복구할 수 있습니다.

	RAID6와 유사하게 더 많은 디스크 오류로부터 복구하려면,
	추가 디스크를 패리티용으로 예약해야 합니다. 추가 패리티 디스크
	하나당 하나의 디스크 오류에 대한 복구를 더 허용합니다.

	패리티 디스크로는 어레이에서 가장 큰 디스크를 선택해야 합니다.
	패리티 정보가 어레이에서 가장 큰 **데이터 디스크**의 크기만큼
	커질 수 있기 때문입니다.

	이 디스크들은 `parity` 파일을 저장하는 데 전념하게 됩니다.
	여기에 데이터를 저장해서는 안 됩니다.

	다음으로, SnapRAID로 보호하려는 `data`(데이터) 디스크를 정의해야 합니다.
	이 디스크들이 **거의 변경되지 않는 데이터**를 포함할 때 보호 효과가
	더 좋습니다. 이러한 이유로, Windows C:\ 디스크나 Unix의 /home, /var,
	/tmp 디렉토리를 포함하지 않는 것이 좋습니다.

	파일 목록은 `content` 파일에 저장되며, 보통 데이터, 패리티, 또는 부트
	디스크에 저장됩니다.
	이 파일에는 무결성을 확인하기 위한 모든 체크섬을 포함하여
	백업에 대한 세부 정보가 들어 있습니다.
	`content` 파일은 여러 복사본으로 저장되며, 다중 디스크 오류의 경우에도
	적어도 하나의 복사본을 사용할 수 있도록 각 복사본은 서로 다른 디스크에
	있어야 합니다.

	예를 들어, 하나의 패리티 보호 수준만 원하고 디스크가 다음과 같이
	위치한다고 가정해 봅시다:

		:/mnt/diskp <- 패리티용으로 선택된 디스크
		:/mnt/disk1 <- 보호할 첫 번째 디스크
		:/mnt/disk2 <- 보호할 두 번째 디스크
		:/mnt/disk3 <- 보호할 세 번째 디스크

	다음 옵션으로 설정 파일 /etc/snapraid.conf를 생성해야 합니다:

		:parity /mnt/diskp/snapraid.parity
		:content /var/snapraid/snapraid.content
		:content /mnt/disk1/snapraid.content
		:content /mnt/disk2/snapraid.content
		:data d1 /mnt/disk1/
		:data d2 /mnt/disk2/
		:data d3 /mnt/disk3/

	Windows를 사용하는 경우, 슬래시 대신 드라이브 문자 및 백슬래시를 사용하는
	Windows 경로 형식을 사용해야 합니다.

		:parity E:\snapraid.parity
		:content C:\snapraid\snapraid.content
		:content F:\array\snapraid.content
		:content G:\array\snapraid.content
		:data d1 F:\array\
		:data d2 G:\array\
		:data d3 H:\array\

	디스크가 많아 드라이브 문자가 부족한 경우, 디스크를 하위 폴더에
	직접 마운트할 수 있습니다. 다음을 참조하십시오:

		:https://www.google.com/search?q=Windows+mount+point

	이 시점에서, 패리티 정보를 빌드하기 위해 `sync` 명령을 실행할
	준비가 되었습니다.

		:snapraid sync

	이 프로세스는 디스크에 이미 존재하는 데이터의 크기에 따라 첫 실행 시
	몇 시간이 걸릴 수 있습니다. 디스크가 비어 있으면 프로세스는 즉시
	완료됩니다.

	Ctrl+C를 눌러 언제든지 중지할 수 있으며, 다음 실행 시 중단된
	곳에서 재개됩니다.

	이 명령이 완료되면 데이터는 **SAFE**합니다.

	이제 어레이를 원하는 대로 사용하고 주기적으로 `sync` 명령을
	실행하여 패리티 정보를 업데이트할 수 있습니다.

  Scrubbing
	주기적으로 데이터 및 패리티의 오류를 확인하려면 `scrub` 명령을
	실행할 수 있습니다.

		:snapraid scrub

	이 명령은 데이터 무결성을 확인하기 위해 어레이의 데이터를 `sync` 명령
	중에 계산된 해시와 비교합니다.

	이 명령을 실행할 때마다 이전에 10일 이내에 스크럽된 데이터를 제외하고
	어레이의 약 8%를 확인합니다.
	다른 양을 지정하려면 -p, --plan 옵션을 사용하고, 다른 일령(days)을
	지정하려면 -o, --older-than 옵션을 사용할 수 있습니다.
	예를 들어, 20일보다 오래된 블록에 대해 어레이의 5%를 확인하려면
	다음과 같이 사용합니다:

		:snapraid -p 5 -o 20 scrub

	이 프로세스 중에 무단 또는 입출력 오류가 발견되면, 해당 블록은
	`content` 파일에 bad로 표시되며 `status` 명령에 나열됩니다.

		:snapraid status

	이들을 수정하려면 -e, --filter-error 옵션으로 bad 블록을 필터링하여
	`fix` 명령을 사용할 수 있습니다.

		:snapraid -e fix

	다음 `scrub` 시에 오류가 실제로 수정되면 `status` 보고서에서
	사라집니다. 더 빠르게 하려면, `-p bad`를 사용하여 bad로 표시된 블록만
	스크럽할 수 있습니다.

		:snapraid -p bad scrub

	동기화되지 않은 어레이에서 `scrub`을 실행하면 제거되거나 수정된 파일로
	인한 오류가 보고될 수 있습니다. 이러한 오류는 `scrub` 출력에는
	보고되지만, 관련 블록은 bad로 표시되지 않습니다.

  Pooling
	참고: 아래에 설명된 풀링(pooling) 기능은 **mergefs** 도구로 대체되었으며,
	이는 SnapRAID 커뮤니티에서 Linux 사용자를 위한 권장 옵션입니다.
	Mergefs는 여러 드라이브를 단일 통합 마운트 지점으로 풀링하는 더 유연하고
	효율적인 방법을 제공하여, 심볼릭 링크에 의존하지 않고 어레이 전체의
	파일에 대한 원활한 액세스를 허용합니다. 이는 패리티 보호를 위한
	SnapRAID와 잘 통합되며, OpenMediaVault (OMV) 또는 사용자 정의 NAS
	구성과 같은 설정에서 흔히 사용됩니다.

	어레이의 모든 파일을 동일한 디렉토리 트리에 표시하려면,
	`pooling` 기능을 활성화할 수 있습니다. 이 기능은 심볼릭 링크를 사용하여
	어레이의 모든 파일에 대한 읽기 전용 가상 뷰를 생성합니다.

	설정 파일에서 `pooling` 디렉토리를 다음과 같이 구성할 수 있습니다:

		:pool /pool

	또는 Windows에서 다음과 같이 합니다:

		:pool C:\pool

	그리고 나서 `pool` 명령을 실행하여 가상 뷰를 생성하거나 업데이트합니다.

		:snapraid pool

	Unix 플랫폼을 사용하고 이 디렉토리를 Windows 또는 Unix 컴퓨터에
	네트워크를 통해 공유하려면, /etc/samba/smb.conf에 다음 옵션을
	추가해야 합니다:

		:# smb.conf의 global 섹션에서
		:unix extensions = no

		:# smb.conf의 share 섹션에서
		:[pool]
		:comment = Pool
		:path = /pool
		:read only = yes
		:guest ok = yes
		:wide links = yes
		:follow symlinks = yes

	Windows에서 네트워크를 통해 심볼릭 링크를 공유하려면 클라이언트가
	원격으로 이들을 해석해야 합니다. 이를 활성화하기 위해, 풀 디렉토리를
	공유하는 것 외에도, 설정 파일에 정의된 디스크 이름을 공유 지점으로
	사용하여 모든 디스크를 독립적으로 공유해야 합니다. 또한 설정 파일의
	`share` 옵션에서 원격 클라이언트가 이러한 공유 디스크에 액세스하는 데
	필요한 Windows UNC 경로를 지정해야 합니다.

	예를 들어, `darkstar`라는 서버에서 작업하는 경우, 다음 옵션을
	사용할 수 있습니다:

		:data d1 F:\array\
		:data d2 G:\array\
		:data d3 H:\array\
		:pool C:\pool
		:share \\darkstar

	그리고 네트워크를 통해 다음 디렉토리를 공유합니다:

		:\\darkstar\pool -> C:\pool
		:\\darkstar\d1 -> F:\array
		:\\darkstar\d2 -> G:\array
		:\\darkstar\d3 -> H:\array

	이렇게 하면 원격 클라이언트가 \\darkstar\pool에서 모든 파일에 액세스할
	수 있습니다.

	또한 다음 명령으로 원격 클라이언트를 구성하여 원격 심볼릭 링크에
	대한 액세스를 활성화해야 할 수도 있습니다:

		:fsutil behavior set SymlinkEvaluation L2L:1 R2R:1 L2R:1 R2L:1

  Undeleting
	SnapRAID는 RAID 시스템보다는 백업 프로그램처럼 작동하며,
	-f, --filter 옵션을 사용하여 파일이나 디렉토리를 이전 상태로 복원하거나
	삭제 취소할 수 있습니다:

		:snapraid fix -f FILE

	또는 디렉토리에 대해:

		:snapraid fix -f DIR/

	또한 -m, --filter-missing 옵션을 사용하여 디렉토리 내에서 실수로
	삭제된 파일만 복구할 수도 있습니다. 이 옵션은 누락된 파일만 복원하고
	다른 파일은 그대로 둡니다.

		:snapraid fix -m -f DIR/

	또는 모든 드라이브에서 삭제된 모든 파일을 다음으로 복구합니다:

		:snapraid fix -m

  Recovering
	최악의 상황이 발생하여 하나 이상의 디스크를 잃었습니다!

	**패닉하지 마십시오!** 복구할 수 있습니다!

	가장 먼저 해야 할 일은 디스크 어레이에 대한 추가 변경을 피하는 것입니다.
	모든 원격 연결과 SnapRAID 야간 동기화 또는 스크럽을 포함한 모든 예약된
	프로세스를 비활성화하십시오.

	그런 다음 다음 단계를 진행하십시오.

    STEP 1 -> Reconfigure
	복구할 공간이 필요하며, 이상적으로는 추가 예비 디스크에,
	하지만 외부 USB 디스크 또는 원격 디스크로도 충분합니다.

	SnapRAID 설정 파일을 수정하여 실패한 디스크의 `data` 또는 `parity`
	옵션이 파일을 복구할 수 있는 충분한 빈 공간이 있는 위치를
	가리키도록 합니다.

	예를 들어, 디스크 `d1`이 실패한 경우, 다음에서 변경합니다:

		:data d1 /mnt/disk1/

	다음으로:

		:data d1 /mnt/new_spare_disk/

	복구할 디스크가 패리티 디스크인 경우, 적절한 `parity` 옵션을
	업데이트합니다.
	여러 개의 실패한 디스크가 있는 경우, 모든 구성 옵션을 업데이트합니다.

    STEP 2 -> Fix
	로그를 외부 파일에 저장하면서 fix 명령을 실행합니다:

		:snapraid -d NAME -l fix.log fix

	여기서 NAME은 이전 예제의 `d1`과 같은 디스크 이름입니다.
	복구할 디스크가 패리티 디스크인 경우, `parity`, `2-parity` 등의 이름을
	사용합니다.
	여러 개의 실패한 디스크가 있는 경우, 여러 -d 옵션을 사용하여
	모두 지정합니다.

	이 명령은 오랜 시간이 걸립니다.

	fix.log 파일을 저장할 몇 기가바이트의 여유 공간이 있는지 확인하십시오.
	충분한 여유 공간이 있는 디스크에서 실행하십시오.

	이제 복구할 수 있는 모든 것을 복구했습니다. 일부 파일이 부분적으로
	또는 완전히 복구 불가능한 경우, `.unrecoverable` 확장자가 추가되어
	이름이 변경됩니다.

	`unrecoverable:`로 시작하는 모든 줄을 확인하여 fix.log 파일에서
	복구 불가능한 모든 블록의 자세한 목록을 찾을 수 있습니다.

	복구가 만족스럽지 않으면, 원하는 만큼 여러 번 재시도할 수 있습니다.

	예를 들어, 마지막 `sync` 이후 어레이에서 파일을 제거한 경우,
	일부 파일이 복구되지 않을 수 있습니다.
	이 경우, -i, --import 옵션을 사용하여 `fix`를 재시도하고,
	이 파일들이 현재 어디에 있는지 지정하여 복구 프로세스에 다시 포함시킬
	수 있습니다.

	복구가 만족스럽다면 계속 진행할 수 있지만, 동기화 후에는 `fix` 명령을
	더 이상 재시도할 수 없다는 점에 유의하십시오!

    STEP 3 -> Check
	조심스러운 확인으로, 이제 `check` 명령을 실행하여 복구된 디스크의
	모든 것이 올바른지 확인할 수 있습니다.

		:snapraid -d NAME -a check

	여기서 NAME은 이전 예제의 `d1`과 같은 디스크 이름입니다.

	-d 및 -a 옵션은 SnapRAID에게 지정된 디스크만 확인하고 모든 패리티
	데이터를 무시하도록 지시합니다.

	이 명령은 오랜 시간이 걸리지만, 지나치게 조심스럽지 않다면 건너뛸 수
	있습니다.

    STEP 4 -> Sync
	`sync` 명령을 실행하여 새 디스크로 어레이를 재동기화합니다.

		:snapraid sync

	모든 것이 복구되면 이 명령은 즉시 완료됩니다.

Commands
	SnapRAID는 다음을 허용하는 몇 가지 간단한 명령을 제공합니다:

	* 어레이의 상태 출력 -> `status`
	* 디스크 제어 -> `smart`, `probe`, `up`, `down`
	* 백업/스냅샷 생성 -> `sync`
	* 주기적으로 데이터 확인 -> `scrub`
	* 마지막 백업/스냅샷 복원 -> `fix`.

	명령은 소문자로 작성해야 합니다.

  status
	디스크 어레이의 상태 요약을 출력합니다.

	패리티 단편화, 확인 없이 블록이 얼마나 오래되었는지, 그리고
	스크럽 중에 발생한 모든 기록된 무단 오류에 대한 정보를 포함합니다.

	제시된 정보는 마지막으로 `sync`를 실행했을 때를 나타냅니다.
	나중에 수정된 내용은 고려되지 않습니다.

	bad 블록이 감지되면 해당 블록 번호가 나열됩니다.
	이들을 수정하려면 `fix -e` 명령을 사용할 수 있습니다.

	또한 각 블록이 마지막으로 스크럽되거나 동기화된 시간을 나타내는
	그래프를 보여줍니다. 스크럽된 블록은 '*', 동기화되었지만 아직
	스크럽되지 않은 블록은 'o'로 표시됩니다.

	아무것도 수정되지 않습니다.

  smart
	시스템의 모든 디스크에 대한 SMART 보고서를 출력합니다.

	향후 1년 동안의 실패 확률 추정치를 포함하여, 의심스러운 속성을
	보이는 디스크의 유지 보수 교체를 계획할 수 있습니다.

	이 확률 추정치는 다음에서 사용 가능한 Backblaze 데이터와 디스크의
	SMART 속성을 상호 연관시켜 얻습니다:

		:https://www.backblaze.com/hard-drive-test-data.html

	SMART가 디스크가 실패하고 있다고 보고하면, 해당 디스크에 대해
	`FAIL` 또는 `PREFAIL`이 출력되며, SnapRAID는 오류를 반환하며 종료됩니다.
	이 경우, 디스크의 즉각적인 교체가 강력히 권장됩니다.

	다른 가능한 상태 문자열은 다음과 같습니다:
		logfail - 과거에 일부 속성이 임계값보다 낮았습니다.
		logerr - 장치 오류 로그에 오류가 포함되어 있습니다.
		selferr - 장치 자체 테스트 로그에 오류가 포함되어 있습니다.

	-v, --verbose 옵션이 지정되면, 더 깊은 통계 분석이 제공됩니다.
	이 분석은 더 많거나 적은 패리티가 필요한지 결정하는 데 도움이 될 수 있습니다.

	이 명령은 `smartctl` 도구를 사용하며, 모든 장치에서 `smartctl -a`를
	실행하는 것과 동일합니다.

	장치가 올바르게 자동 감지되지 않으면, 설정 파일에서 `smartctl` 옵션을
	사용하여 사용자 정의 명령을 지정할 수 있습니다.

	아무것도 수정되지 않습니다.

  probe
	시스템의 모든 디스크의 POWER 상태를 출력합니다.

	`Standby`는 디스크가 회전하지 않음을 의미합니다. `Active`는
	디스크가 회전하고 있음을 의미합니다.

	이 명령은 `smartctl` 도구를 사용하며, 모든 장치에서 `smartctl -n standby -i`를
	실행하는 것과 동일합니다.

	장치가 올바르게 자동 감지되지 않으면, 설정 파일에서 `smartctl` 옵션을
	사용하여 사용자 정의 명령을 지정할 수 있습니다.

	아무것도 수정되지 않습니다.

  up
	어레이의 모든 디스크를 회전시킵니다(spin up).

	-d, --filter-disk 옵션을 사용하여 특정 디스크만 회전시킬 수 있습니다.

	모든 디스크를 동시에 회전시키려면 많은 전력이 필요합니다.
	전원 공급 장치가 이를 지탱할 수 있는지 확인하십시오.

	아무것도 수정되지 않습니다.

  down
	어레이의 모든 디스크를 회전 중지합니다(spin down).

	이 명령은 `smartctl` 도구를 사용하며, 모든 장치에서 `smartctl -s standby,now`를
	실행하는 것과 동일합니다.

	-d, --filter-disk 옵션을 사용하여 특정 디스크만 회전 중지할 수 있습니다.

	오류 발생 시 자동으로 회전 중지하려면, 다른 명령과 함께 -s, --spin-down-on-error
	옵션을 사용할 수 있습니다. 이는 오류 발생 시 수동으로 `down`을 실행하는 것과
	동일합니다.

	아무것도 수정되지 않습니다.

  diff
	마지막 `sync` 이후 수정되어 패리티 데이터를 재계산해야 하는 모든 파일을
	나열합니다.

	이 명령은 파일 데이터를 확인하지 않고, 파일 타임스탬프, 크기 및
	아이노드(inode)만 확인합니다.

	모든 변경된 파일을 나열한 후, 다음과 같이 그룹화된 변경 사항 요약이
	제시됩니다:
		equal - 이전과 변경되지 않은 파일.
		added - 이전에 없던 추가된 파일.
		removed - 제거된 파일.
		updated - 크기 또는 타임스탬프가 다른 파일, 즉 수정된 파일.
		moved - 동일한 디스크의 다른 디렉토리로 이동된 파일.
			이들은 이름, 크기, 타임스탬프 및 아이노드가 동일하지만
			디렉토리가 다른 것으로 식별됩니다.
		copied - 동일하거나 다른 디스크에 복사된 파일. 다른 디스크로
			실제로 이동된 경우 `removed`에도 포함된다는 점에 유의하십시오.
			이들은 이름, 크기 및 타임스탬프가 동일한 것으로 식별됩니다.
			하위 초 타임스탬프(sub-second timestamp)가 0인 경우,
			이름뿐만 아니라 전체 경로가 일치해야 합니다.
		restored - 아이노드는 다르지만 이름, 크기 및 타임스탬프가 일치하는 파일.
			이들은 일반적으로 삭제 후 복원된 파일입니다.

	`sync`가 필요한 경우, 프로세스 반환 코드는 기본 0 대신 2입니다.
	반환 코드 1은 일반적인 오류 조건에 사용됩니다.

	아무것도 수정되지 않습니다.

  sync
	패리티 정보를 업데이트합니다. 디스크 어레이의 모든 수정된 파일을
	읽고 해당 패리티 데이터를 업데이트합니다.

	이미 수행된 작업을 잃지 않고 Ctrl+C를 눌러 언제든지 이 프로세스를
	중지할 수 있습니다.
	다음 실행 시 `sync` 프로세스는 중단된 곳에서 재개됩니다.

	이 프로세스 중에 무단 또는 입출력 오류가 발견되면,
	해당 블록은 bad로 표시됩니다.

	파일은 경로 및/또는 아이노드로 식별되며 크기와 타임스탬프로
	확인됩니다.
	파일 크기 또는 타임스탬프가 다르면 전체 파일에 대해 패리티 데이터가
	재계산됩니다.
	파일이 동일한 디스크에서 이동되거나 이름이 변경되고 동일한 아이노드를
	유지하면 패리티는 재계산되지 않습니다.
	파일이 다른 디스크로 이동되면 패리티는 재계산되지만, 이전에 계산된
	해시 정보는 유지됩니다.

	`content` 및 `parity` 파일은 필요한 경우 수정됩니다.
	어레이의 파일은 수정되지 않습니다.

  scrub
	어레이를 스크럽하여 데이터 및 패리티 디스크의 무단 또는 입출력 오류를
	확인합니다.

	각 호출은 이전에 10일 이내에 스크럽된 데이터를 제외하고 어레이의
	약 8%를 확인합니다.
	이는 일주일에 한 번 스크럽하면 모든 데이터 비트가 적어도 3개월마다
	한 번씩 확인됨을 의미합니다.

	-p, --plan 옵션을 사용하여 다른 스크럽 계획 또는 양을 정의할 수 있으며,
	다음 값을 허용합니다:
	bad - bad로 표시된 블록 스크럽.
	new - 동기화되었지만 아직 스크럽되지 않은 블록 스크럽.
	full - 모든 것 스크럽.
	0-100 - 지정된 비율의 블록 스크럽.

	백분율 양을 지정하면, -o, --older-than 옵션을 사용하여 블록이
	얼마나 오래되었는지 정의할 수도 있습니다.
	가장 오래된 블록이 먼저 스크럽되어 최적의 확인을 보장합니다.
	동기화되었지만 아직 스크럽되지 않은 블록만 스크럽하려면,
	`-p new` 옵션을 사용하십시오.

	스크럽 상태의 세부 정보를 얻으려면 `status` 명령을 사용하십시오.

	발견된 모든 무단 또는 입출력 오류에 대해, 해당 블록은 `content` 파일에
	bad로 표시됩니다.
	이러한 bad 블록은 `status`에 나열되며 `fix -e`로 수정할 수 있습니다.
	수정 후, 다음 스크럽 시에 다시 확인되며, 수정된 것으로 발견되면 bad
	표시는 제거됩니다.
	bad 블록만 스크럽하려면 `scrub -p bad` 명령을 사용할 수 있습니다.

	동기화되지 않은 데이터로 인한 보고된 오류를 피하기 위해 동기화된
	어레이에서만 `scrub`을 실행하는 것이 좋습니다. 이러한 오류는 무단
	오류가 아닌 것으로 인식되며, 블록은 bad로 표시되지 않지만,
	이러한 오류는 명령의 출력에 보고됩니다.

	`content` 파일은 각 블록의 마지막 확인 시간을 업데이트하고 bad 블록을
	표시하기 위해 수정됩니다.
	`parity` 파일은 수정되지 않습니다.
	어레이의 파일은 수정되지 않습니다.

  fix
	모든 파일과 패리티 데이터를 수정합니다.

	모든 파일과 패리티 데이터는 마지막 `sync`에 저장된 스냅샷
	상태와 비교됩니다.
	차이가 발견되면 저장된 스냅샷으로 되돌려집니다.

	**경고!** `fix` 명령은 오류와 의도적인 수정 사이를 구별하지
	않습니다. 파일 상태를 무조건 마지막 `sync`로 되돌립니다.

	다른 옵션이 지정되지 않으면 전체 어레이가 처리됩니다.
	필터 옵션을 사용하여 처리할 파일 또는 디스크의 하위 집합을 선택하십시오.

	`sync` 및 `scrub` 중에 bad로 표시된 블록만 수정하려면,
	-e, --filter-error 옵션을 사용하십시오.
	다른 필터 옵션과 달리, 이 옵션은 최신 `sync` 이후 변경되지 않은
	파일에만 수정을 적용합니다.

	SnapRAID는 수정할 수 없는 모든 파일에 `.unrecoverable` 확장자를
	추가하여 이름을 변경합니다.

	수정하기 전에, 전체 어레이를 스캔하여 마지막 `sync` 이후 이동된
	파일을 찾습니다.
	이 파일들은 이름과 디렉토리를 무시하고 타임스탬프로 식별되며,
	필요한 경우 복구 프로세스에 사용됩니다.
	일부 파일을 어레이 외부로 이동한 경우, -i, --import 옵션을 사용하여
	추가로 스캔할 디렉토리를 지정할 수 있습니다.

	파일은 아이노드가 아닌 경로로만 식별됩니다.

	`content` 파일은 수정되지 않습니다.
	`parity` 파일은 필요한 경우 수정됩니다.
	어레이의 파일은 필요한 경우 수정됩니다.

  check
	모든 파일과 패리티 데이터를 확인합니다.

	`fix`처럼 작동하지만, 복구를 시뮬레이션할 뿐이며 어레이에
	어떤 변경 사항도 기록되지 않습니다.

	이 명령은 주로 복구 프로세스 후 또는 기타 특별한 조건에서와 같이
	수동 확인을 위한 것입니다.
	주기적이고 예약된 확인을 위해서는 `scrub`을 사용하십시오.

	-a, --audit-only 옵션을 사용하면 파일 데이터만 확인하고
	패리티 데이터는 무시하여 실행 속도를 높일 수 있습니다.

	파일은 아이노드가 아닌 경로로만 식별됩니다.

	아무것도 수정되지 않습니다.

  list
	마지막 `sync` 시점에 어레이에 포함된 모든 파일을 나열합니다.

	-v 또는 --verbose를 사용하면 하위 초 시간도 표시됩니다.

	아무것도 수정되지 않습니다.

  dup
	모든 중복 파일을 나열합니다. 두 파일의 해시가 일치하면 동일한 것으로
	간주됩니다. 파일 데이터는 읽지 않고, 미리 계산된 해시만
	사용됩니다.

	아무것도 수정되지 않습니다.

  pool
	`pooling` 디렉토리에서 디스크 어레이의 모든 파일에 대한 가상 뷰를
	생성하거나 업데이트합니다.

	파일은 복사되지 않고 심볼릭 링크를 사용하여 연결됩니다.

	업데이트 시, 모든 기존 심볼릭 링크와 빈 하위 디렉토리는 삭제되고
	어레이의 새 뷰로 대체됩니다. 다른 일반 파일은 제자리에 남습니다.

	풀 디렉토리 외부에서는 아무것도 수정되지 않습니다.

  devices
	어레이에서 사용되는 저수준(low-level) 장치를 출력합니다.

	이 명령은 어레이의 장치 연결을 표시하며, 주로 스크립트 인터페이스를
	위한 것입니다.

	처음 두 열은 저수준 장치 ID 및 경로입니다.
	다음 두 열은 고수준(high-level) 장치 ID 및 경로입니다.
	마지막 열은 어레이의 디스크 이름입니다.

	대부분의 경우, 어레이의 각 디스크에 대해 하나의 저수준 장치가
	있지만, 일부 더 복잡한 구성에서는 단일 어레이 디스크에 의해 사용되는
	여러 저수준 장치가 있을 수 있습니다.

	아무것도 수정되지 않습니다.

  touch
	하위 초 타임스탬프가 0으로 설정된 모든 파일에 임의의 하위 초 타임스탬프를
	설정합니다.

	이는 타임스탬프를 거의 고유하게 만들어 가능한 중복을 줄이므로,
	SnapRAID가 이동되거나 복사된 파일을 인식하는 능력을 향상시킵니다.

	더 구체적으로, 하위 초 타임스탬프가 0이 아닌 경우, 이동되거나 복사된
	파일은 이름, 크기 및 타임스탬프가 일치하면 그렇게 식별됩니다.
	하위 초 타임스탬프가 0인 경우, 전체 경로, 크기 및 타임스탬프가
	모두 일치하는 경우에만 복사본으로 간주됩니다.

	초 단위 정밀도의 타임스탬프는 수정되지 않으므로, 파일의 모든 날짜와
	시간은 보존됩니다.

  rehash
	전체 어레이의 재해시(rehash)를 예약합니다.

	이 명령은 사용되는 해시 종류를 변경하며, 일반적으로 32비트 시스템에서
	64비트 시스템으로 업그레이드할 때 MurmurHash3에서 더 빠른 SpookyHash로
	전환하기 위해 사용됩니다.

	이미 최적의 해시를 사용하고 있다면, 이 명령은 아무것도 하지 않고
	조치가 필요하지 않음을 알려줍니다.

	재해시는 즉시 수행되지 않고 `sync` 및 `scrub` 중에 점진적으로
	진행됩니다.

	`status`를 사용하여 재해시 상태를 확인할 수 있습니다.

	재해시 중에도 SnapRAID는 전체 기능을 유지하며, 유일한 예외는
	`dup`가 다른 해시를 사용하는 중복 파일을 감지할 수 없다는 것입니다.

Options
	SnapRAID는 다음 옵션을 제공합니다:

	-c, --conf CONFIG
		사용할 설정 파일을 선택합니다. 지정하지 않으면 Unix에서는
		`/usr/local/etc/snapraid.conf` 파일이 존재하면 사용하고,
		그렇지 않으면 `/etc/snapraid.conf`를 사용합니다.
		Windows에서는 `snapraid.exe`와 같은 디렉토리에 있는
		`snapraid.conf` 파일을 사용합니다.

	-f, --filter PATTERN
		`check` 및 `fix`에서 처리할 파일을 필터링합니다.
		지정된 패턴과 일치하는 파일만 처리됩니다.
		이 옵션은 여러 번 사용될 수 있습니다.
		패턴 사양에 대한 자세한 내용은 PATTERN 섹션을 참조하십시오.
		Unix에서는 글로빙 문자가 사용되는 경우 따옴표로 묶어야 합니다.
		이 옵션은 `check` 및 `fix`에서만 사용할 수 있습니다.
		`sync` 및 `scrub`은 항상 전체 어레이를 처리하므로 사용할 수 없습니다.

	-d, --filter-disk NAME
		`check`, `fix`, `up`, 및 `down`에서 처리할 디스크를 필터링합니다.
		설정 파일에 정의된 디스크 이름을 지정해야 합니다.
		또한 `parity`, `2-parity`, `3-parity` 등의 이름으로 패리티 디스크를
		지정하여 특정 패리티 디스크로 작업을 제한할 수 있습니다.
		여러 --filter, --filter-disk, --filter-missing 옵션을 결합하면,
		모든 필터와 일치하는 파일만 선택됩니다.
		이 옵션은 여러 번 사용될 수 있습니다.
		이 옵션은 `check`, `fix`, `up`, 및 `down`에서만 사용할 수 있습니다.
		`sync` 및 `scrub`은 항상 전체 어레이를 처리하므로 사용할 수 없습니다.

	-m, --filter-missing
		`check` 및 `fix`에서 처리할 파일을 필터링합니다.
		어레이에서 누락되거나 삭제된 파일만 처리됩니다.
		`fix`와 함께 사용하면, 이 옵션은 `undelete` 명령 역할을 합니다.
		여러 --filter, --filter-disk, --filter-missing 옵션을 결합하면,
		모든 필터와 일치하는 파일만 선택됩니다.
		이 옵션은 `check` 및 `fix`에서만 사용할 수 있습니다.
		`sync` 및 `scrub`은 항상 전체 어레이를 처리하므로 사용할 수 없습니다.

	-e, --filter-error
		`check` 및 `fix`에서 오류가 있는 파일을 처리합니다.
		`status`에 나열된 대로 `sync` 및 `scrub` 중에 무단 또는 입출력 오류가
		표시된 블록을 가진 파일만 처리합니다.
		이 옵션은 `check` 및 `fix`에서만 사용할 수 있습니다.

	-p, --plan PERC|bad|new|full
		스크럽 계획을 선택합니다. PERC가 0에서 100 사이의 숫자 값인 경우,
		스크럽할 블록의 백분율로 해석됩니다.
		백분율 대신 계획을 지정할 수 있습니다:
		`bad`는 bad 블록을 스크럽하고, `new`는 아직 스크럽되지 않은
		막 동기화된 블록을 스크럽하며, `full`은 모든 것을 스크럽합니다.
		이 옵션은 `scrub`에서만 사용할 수 있습니다.

	-o, --older-than DAYS
		`scrub`에서 처리할 어레이의 가장 오래된 부분을 선택합니다.
		DAYS는 블록이 스크럽되어야 하는 최소 일령(days)이며,
		기본값은 10입니다.
		bad로 표시된 블록은 이 옵션에 관계없이 항상 스크럽됩니다.
		이 옵션은 `scrub`에서만 사용할 수 있습니다.

	-a, --audit-only
		`check`에서 패리티 데이터를 확인하지 않고 파일의 해시를
		확인합니다.
		파일 데이터만 확인하는 데 관심이 있다면, 이 옵션은 확인 프로세스의
		속도를 상당히 높일 수 있습니다.
		이 옵션은 `check`에서만 사용할 수 있습니다.

	-h, --pre-hash
		`sync`에서 패리티 계산 전에 추가 확인을 위해 모든 새 데이터에 대한
		예비 해시 단계를 실행합니다.
		일반적으로 `sync`에서는 예비 해시가 수행되지 않으며, 새 데이터는
		패리티 계산 직전에 처음 읽을 때 해시됩니다.
		이 프로세스는 모든 디스크가 회전하고 CPU가 바쁜, 시스템이
		과부하 상태일 때 발생합니다.
		이는 기계의 극한 조건이며, 잠재된 하드웨어 문제가 있는 경우
		데이터가 아직 해시되지 않았기 때문에 무단 오류가 감지되지 않고
		지나갈 수 있습니다.
		이러한 위험을 피하려면, `pre-hash` 모드를 활성화하여 모든 데이터를
		두 번 읽어 무결성을 보장할 수 있습니다.
		이 옵션은 또한 어레이 내에서 이동된 파일을 확인하여 이동 작업이
		성공했는지 확인하고, 필요한 경우 계속 진행하기 전에 fix 작업을
		실행할 수 있도록 합니다.
		이 옵션은 `sync`에서만 사용할 수 있습니다.

	-i, --import DIR
		지정된 디렉토리에서 마지막 `sync` 이후 어레이에서 삭제된 파일을
		가져옵니다.
		이러한 파일이 여전히 있는 경우, 이들은 `check` 및 `fix`에 의해
		복구 프로세스를 개선하는 데 사용될 수 있습니다.
		파일은 하위 디렉토리를 포함하여 읽히며, 이름에 관계없이
		식별됩니다.
		이 옵션은 `check` 및 `fix`에서만 사용할 수 있습니다.

	-s, --spin-down-on-error
		오류 발생 시, 0이 아닌 상태 코드로 종료하기 전에 관리되는 모든
		디스크를 회전 중지합니다. 이는 중단된 작업 후에 드라이브가 계속
		활성 상태로 회전하는 것을 방지하여 불필요한 열 축적 및 전력
		소비를 방지하는 데 도움이 됩니다. 명령이 실패하더라도 디스크가
		안전하게 중지되도록 이 옵션을 사용하십시오.

	-w, --bw-limit RATE
		모든 디스크에 대한 전역 대역폭 제한을 적용합니다. RATE는
		초당 바이트 수입니다. K, M, 또는 G와 같은 승수(예: --bw-limit 1G)를
		지정할 수 있습니다.

	-A, --stats
		추가 정보를 보여주는 확장된 상태 보기를 활성화합니다.
		화면에는 두 개의 그래프가 표시됩니다:
		첫 번째 그래프는 각 디스크에 대한 버퍼링된 스트라이프 수와 함께
		해당 디스크에서 현재 액세스 중인 파일의 경로를 보여줍니다.
		일반적으로 가장 느린 디스크는 사용 가능한 버퍼가 없으며,
		이는 달성 가능한 최대 대역폭을 결정합니다.
		두 번째 그래프는 지난 100초 동안 대기하는 데 소비된 시간의
		백분율을 보여줍니다. 가장 느린 디스크가 대부분의 대기 시간을
		유발할 것으로 예상되며, 다른 디스크는 버퍼링된 스트라이프를
		사용할 수 있으므로 대기 시간이 거의 또는 전혀 없어야 합니다.
		이 그래프는 또한 해시 계산 및 RAID 계산을 위해 소비된 시간을
		보여줍니다.
		모든 계산은 디스크 작업과 병렬로 실행됩니다.
		따라서 적어도 하나의 디스크에 대해 측정 가능한 대기 시간이
		있는 한, 이는 CPU가 워크로드에 충분히 빠르다는 것을 나타냅니다.

	-Z, --force-zero
		이전에 0이 아니었던 크기가 0인 파일의 동기화라는 안전하지 않은
		작업을 강제합니다.
		SnapRAID가 이러한 조건을 감지하면, 이 옵션을 지정하지 않는 한
		진행을 중지합니다.
		이는 시스템 충돌 후 일부 액세스된 파일이 잘렸을 때 쉽게 감지할
		수 있도록 합니다.
		이는 ext3/ext4 파일 시스템을 사용하는 Linux에서 가능한 조건입니다.
		이 옵션은 `sync`에서만 사용할 수 있습니다.

	-E, --force-empty
		원래 디스크에 있던 모든 파일이 누락된 디스크의 동기화라는
		안전하지 않은 작업을 강제합니다.
		SnapRAID가 디스크에 원래 있던 모든 파일이 누락되거나 다시
		작성되었음을 감지하면, 이 옵션을 지정하지 않는 한 진행을
		중지합니다.
		이는 데이터 파일 시스템이 마운트되지 않았을 때 쉽게 감지할
		수 있도록 합니다.
		이 옵션은 `sync`에서만 사용할 수 있습니다.

	-U, --force-uuid
		UUID가 변경된 디스크를 사용하여 동기화, 확인 및 수정을 강제하는
		안전하지 않은 작업입니다.
		SnapRAID가 일부 디스크의 UUID가 변경되었음을 감지하면,
		이 옵션을 지정하지 않는 한 진행을 중지합니다.
		이는 디스크가 잘못된 마운트 지점에 마운트되었을 때 감지할
		수 있도록 합니다.
		그러나 단일 패리티를 사용하는 경우 하나의 UUID 변경이 허용되며,
		여러 패리티를 사용하는 경우 더 많은 변경이 허용됩니다. 이는
		복구 후 디스크를 교체할 때의 일반적인 경우이기 때문입니다.
		이 옵션은 `sync`, `check`, 또는 `fix`에서만 사용할 수 있습니다.

	-D, --force-device
		액세스할 수 없는 디스크 또는 동일한 물리적 장치에 있는 디스크로
		수정을 강제하는 안전하지 않은 작업입니다.
		예를 들어, 두 개의 데이터 디스크를 잃고 첫 번째 디스크만
		복구하기 위해 예비 디스크가 있는 경우, 두 번째 액세스할 수 없는
		디스크를 무시할 수 있습니다.
		또는 이미 사용 중인 디스크에 남은 여유 공간에 디스크를 복구하려는
		경우, 동일한 물리적 장치를 공유합니다.
		이 옵션은 `fix`에서만 사용할 수 있습니다.

	-N, --force-nocopy
		`sync`, `check`, 및 `fix`에서 복사 감지 발견법(heuristic)을
		비활성화합니다.
		이 옵션이 없으면 SnapRAID는 이름, 크기 및 타임스탬프와 같은
		동일한 속성을 가진 파일이 동일한 데이터를 가진 복사본이라고
		가정합니다.
		이는 한 디스크에서 다른 디스크로 복사되거나 이동된 파일을
		식별하고, 이미 계산된 해시 정보를 재사용하여 무단 오류를
		감지하거나 누락된 파일을 복구할 수 있도록 합니다.
		일부 드문 경우에 이 동작은 오탐(false positives) 또는 많은
		해시 확인으로 인한 느린 프로세스를 초래할 수 있으며, 이 옵션을
		사용하면 이러한 문제를 해결할 수 있습니다.
		이 옵션은 `sync`, `check`, 및 `fix`에서만 사용할 수 있습니다.

	-F, --force-full
		`sync`에서 패리티의 전체 재계산을 강제합니다.
		이 옵션은 새 패리티 수준을 추가하거나, 더 최근의 패리티 데이터를
		사용하여 이전 content 파일로 되돌렸을 때 사용할 수 있습니다.
		처음부터 패리티를 다시 생성하는 대신, 이 옵션을 사용하면
		content 파일에 있는 해시를 재사용하여 데이터를 검증하고
		기존 패리티 데이터를 사용하여 `sync` 프로세스 중에 데이터 보호를
		유지할 수 있습니다.
		이 옵션은 `sync`에서만 사용할 수 있습니다.

	-R, --force-realloc
		`sync`에서 파일의 전체 재할당 및 패리티 재빌드를 강제합니다.
		이 옵션은 content 파일에 있는 해시를 재사용하여 데이터를
		검증하면서 단편화를 제거하고 모든 파일을 완전히 재할당하는 데
		사용될 수 있습니다.
		이 옵션은 `sync`에서만 사용할 수 있습니다.
		**경고!** 이 옵션은 전문가 전용이며, 사용하지 않는 것이
		강력히 권장됩니다.
		`sync` 작업 중에는 데이터 보호가 없습니다.

	-l, --log FILE
		지정된 파일에 자세한 로그를 기록합니다.
		이 옵션을 지정하지 않으면 예상치 못한 오류가 화면에 출력되어,
		많은 오류가 발생하는 경우 과도한 출력이 발생할 수 있습니다.
		-l, --log가 지정되면 SnapRAID가 중지되는 치명적인 오류만
		화면에 출력됩니다.
		경로가 '>>'로 시작하면 파일이 추가 모드로 열립니다.
		이름의 '%D'와 '%T'는 YYYYMMDD 및 HHMMSS 형식의 날짜 및
		시간으로 대체됩니다. Windows 배치 파일에서는 '%' 문자를
		두 배로 늘려야 합니다(예: result-%%D.log). '>>'를 사용하려면
		이름을 따옴표로 묶어야 합니다(예: `">>result.log"`).
		로그를 표준 출력 또는 표준 오류로 출력하려면 각각 `">&1"` 및 `">&2"`를
		사용할 수 있습니다.
		로그 태그 설명은 snapraid_log.txt 파일 또는 man 페이지를 참조하십시오.

	-L, --error-limit NUMBER
		실행을 중지하기 전에 새로운 오류 제한을 설정합니다.
		기본적으로 SnapRAID는 100개 이상의 입출력 오류가 발생하면 중지됩니다.
		이는 디스크가 실패할 가능성이 있음을 나타냅니다.
		이 옵션은 `sync` 및 `scrub`에 영향을 미치며, 첫 번째 디스크 오류
		세트 후에 계속 진행하여 작업을 완료하려고 시도할 수 있도록
		허용합니다.
		그러나 `check` 및 `fix`는 항상 첫 번째 오류에서 중지됩니다.

	-S, --start BLKSTART
		지정된 블록 번호부터 처리를 시작합니다.
		이는 손상된 디스크의 경우 특정 블록을 다시 확인하거나 수정하는 데
		유용할 수 있습니다.
		이 옵션은 주로 고급 수동 복구를 위한 것입니다.

	-B, --count BLKCOUNT
		지정된 수의 블록만 처리합니다.
		이 옵션은 주로 고급 수동 복구를 위한 것입니다.

	-C, --gen-conf CONTENT
		기존 content 파일에서 더미 설정 파일을 생성합니다.
		설정 파일은 표준 출력으로 작성되며 기존 파일을 덮어쓰지 않습니다.
		이 설정 파일에는 전체 시스템을 잃을 경우 디스크 마운트 지점을
		재구성하는 데 필요한 정보도 포함되어 있습니다.

	-v, --verbose
		화면에 더 많은 정보를 출력합니다.
		한 번 지정하면 제외된 파일 및 추가 통계를 출력합니다.
		이 옵션은 로그 파일에는 영향을 미치지 않습니다.

	-q, --quiet
		화면에 더 적은 정보를 출력합니다.
		한 번 지정하면 진행률 표시줄을 제거하고, 두 번 지정하면
		실행 중인 작업을 제거하며, 세 번 지정하면 정보 메시지를
		제거하고, 네 번 지정하면 상태 메시지를 제거합니다.
		치명적인 오류는 항상 화면에 출력됩니다.
		이 옵션은 로그 파일에는 영향을 미치지 않습니다.

	-H, --help
		간단한 도움말 화면을 출력합니다.

	-V, --version
		프로그램 버전을 출력합니다.

Configuration
	SnapRAID는 디스크 어레이의 위치와 패리티 정보를 저장할 위치를
	알기 위해 설정 파일이 필요합니다.

	Unix에서는 `/usr/local/etc/snapraid.conf` 파일이 존재하면 사용하고,
	그렇지 않으면 `/etc/snapraid.conf`를 사용합니다.
	Windows에서는 `snapraid.exe`와 같은 디렉토리에 있는
	`snapraid.conf` 파일을 사용합니다.

	다음 옵션이 포함되어야 합니다(대소문자 구분):

  parity FILE [,FILE] ...
	패리티 정보를 저장하는 데 사용할 파일을 정의합니다.
	패리티는 RAID5와 유사하게 단일 디스크 오류로부터 보호를
	가능하게 합니다.

	여러 파일을 지정할 수 있으며, 이들은 서로 다른 디스크에
	있어야 합니다.
	하나의 파일이 더 이상 커질 수 없을 때 다음 파일이 사용됩니다.
	총 사용 가능한 공간은 어레이에서 가장 큰 데이터 디스크보다
	적어도 커야 합니다.

	나중에 추가 패리티 파일을 추가할 수 있지만, 순서를 바꾸거나
	제거할 수는 없습니다.

	패리티 디스크를 패리티용으로 예약하면 단편화되지 않아 성능이
	향상됩니다.

	Windows에서는 디스크가 가득 찼다는 경고를 피하기 위해 각 디스크에
	256MB가 사용되지 않은 채로 남습니다.

	이 옵션은 필수이며 한 번만 사용할 수 있습니다.

  (2,3,4,5,6)-parity FILE [,FILE] ...
	추가 패리티 정보를 저장하는 데 사용할 파일을 정의합니다.

	지정된 각 패리티 수준에 대해 하나의 추가 보호 수준이
	활성화됩니다:

	* 2-parity는 RAID6 이중 패리티를 활성화합니다.
	* 3-parity는 삼중 패리티를 활성화합니다.
	* 4-parity는 쿼드(4중) 패리티를 활성화합니다.
	* 5-parity는 펜타(5중) 패리티를 활성화합니다.
	* 6-parity는 헥사(6중) 패리티를 활성화합니다.

	각 패리티 수준은 모든 이전 패리티 수준의 존재를
	필요로 합니다.

	`parity` 옵션과 동일한 고려 사항이 적용됩니다.

	이 옵션은 선택 사항이며 한 번만 사용할 수 있습니다.

  z-parity FILE [,FILE] ...
	삼중 패리티를 저장하는 대체 파일 및 형식을 정의합니다.

	이 옵션은 '3-parity'의 대안이며, 주로 SSSE3 명령어 세트를 지원하지
	않는 ARM 또는 AMD Phenom, Athlon, Opteron과 같은 저가형 CPU를
	위한 것입니다. 이러한 경우 더 나은 성능을 제공합니다.

	이 형식은 ZFS RAIDZ3에서 사용되는 것과 유사하지만 더 빠릅니다.
	ZFS와 마찬가지로 삼중 패리티 이상에서는 작동하지 않습니다.

	'3-parity'를 사용할 때 성능 향상을 위해 'z-parity' 형식을 사용하는
	것이 권장되는 경우 경고를 받게 됩니다.

	원하는 z-parity 또는 3-parity 파일로 설정 파일을 조정하고
	'fix'를 사용하여 다시 생성함으로써 한 형식에서 다른 형식으로
	변환할 수 있습니다.

  content FILE
	디스크 어레이에 있는 모든 파일의 목록과 체크섬을 저장하는 데 사용할
	파일을 정의합니다.

	데이터, 패리티 또는 사용 가능한 다른 디스크에 배치할 수 있습니다.
	데이터 디스크를 사용하는 경우, 이 파일은 `sync` 프로세스에서
	자동으로 제외됩니다.

	이 옵션은 필수이며 동일한 파일의 여러 복사본을 저장하기 위해
	여러 번 사용될 수 있습니다.

	사용된 각 패리티 디스크에 대해 최소한 하나의 복사본을
	저장해야 하며, 하나를 더 추가해야 합니다. 추가 복사본을
	사용해도 해롭지 않습니다.

  data NAME DIR
	어레이의 데이터 디스크의 이름과 마운트 지점을 정의합니다.
	NAME은 디스크를 식별하는 데 사용되며 고유해야 합니다. DIR은
	파일 시스템에서 디스크의 마운트 지점입니다.

	NAME을 고정된 상태로 유지하는 한, 필요에 따라 마운트 지점을
	변경할 수 있습니다.

	어레이의 각 데이터 디스크에 대해 하나의 옵션을 사용해야 합니다.

	나중에 설정 파일에서 직접 NAME을 변경하고 'sync' 명령을
	실행하여 디스크의 이름을 바꿀 수 있습니다.
	이름 변경의 경우, 디스크의 저장된 UUID를 사용하여 연결됩니다.

  nohidden
	모든 숨겨진 파일 및 디렉토리를 제외합니다.
	Unix에서는 숨겨진 파일은 '.'으로 시작하는 파일입니다.
	Windows에서는 숨김 속성을 가진 파일입니다.

  exclude/include PATTERN
	sync 프로세스에서 제외하거나 포함할 파일 또는 디렉토리 패턴을
	정의합니다.
	모든 패턴은 지정된 순서대로 처리됩니다.

	일치하는 첫 번째 패턴이 `exclude` 패턴이면 파일은 제외됩니다.
	`include` 패턴이면 파일은 포함됩니다.
	일치하는 패턴이 없으면, 지정된 마지막 패턴이 `include`이면
	파일은 제외되고, `exclude`이면 포함됩니다.

	패턴 사양에 대한 자세한 내용은 PATTERN 섹션을 참조하십시오.

	이 옵션은 여러 번 사용될 수 있습니다.

  blocksize SIZE_IN_KIBIBYTES
	패리티의 기본 블록 크기를 키비바이트(kibibyte) 단위로 정의합니다.
	1키비바이트는 1024바이트입니다.

	기본 블록 크기는 256이며, 대부분의 경우에 작동해야 합니다.

	**경고!** 이 옵션은 전문가 전용이며, 이 값을 변경하지 않는 것이
	강력히 권장됩니다. 나중에 이 값을 변경하려면 전체 패리티를
	다시 생성해야 합니다!

	다른 블록 크기를 사용하는 이유는 수백만 개의 작은 파일이 많은
	경우입니다.

	각 파일에 대해, 몇 바이트만 있어도 전체 패리티 블록이 할당되며,
	파일이 많으면 상당한 미사용 패리티 공간이 발생할 수 있습니다.
	패리티 디스크를 완전히 채우면 데이터 디스크에 더 이상 파일을
	추가할 수 없습니다.
	그러나 낭비된 패리티는 데이터 디스크 전체에 걸쳐 축적되지 않습니다.
	데이터 디스크의 많은 파일로 인해 발생하는 낭비된 공간은 다른
	데이터 디스크가 아닌 해당 데이터 디스크의 데이터 양만 제한합니다.

	대략적으로, 각 파일에 대해 블록 크기의 절반이 낭비된다고 가정할 수
	있습니다. 예를 들어, 100,000개의 파일과 256KiB 블록 크기로
	12.8GB의 패리티가 낭비되며, 이는 데이터 디스크에서 12.8GB의 사용 가능한
	공간이 줄어들 수 있음을 의미합니다.

	`status`를 사용하여 각 디스크의 낭비된 공간의 양을 확인할 수 있습니다.
	이는 데이터 디스크에 비워 두거나 어레이에 포함되지 않은 파일에
	사용해야 하는 공간의 양입니다.
	이 값이 음수이면 패리티를 거의 채우고 있음을 의미하며, 여전히
	낭비할 수 있는 공간을 나타냅니다.

	이 문제를 피하려면 패리티에 대해 더 큰 파티션을 사용할 수 있습니다.
	예를 들어, 패리티 파티션이 데이터 디스크보다 12.8GB 더 큰 경우,
	각 데이터 디스크에 최대 100,000개의 파일을 낭비되는 공간 없이
	처리할 수 있는 충분한 추가 공간이 있습니다.

	Linux에서 더 큰 패리티 파티션을 얻는 트릭은 다음 명령으로 포맷하는
	것입니다:

		:mkfs.ext4 -m 0 -T largefile4 DEVICE

	이로 인해 약 1.5%의 추가 공간이 발생하며, 4TB 디스크의 경우 약 60GB로,
	낭비되는 공간 없이 각 데이터 디스크에 약 460,000개의 파일을
	허용합니다.

  hashsize SIZE_IN_BYTES
	저장된 블록의 해시 크기를 바이트 단위로 정의합니다.

	기본 해시 크기는 16바이트(128비트)이며, 대부분의 경우에 작동해야 합니다.

	**경고!** 이 옵션은 전문가 전용이며, 이 값을 변경하지 않는 것이
	강력히 권장됩니다. 나중에 이 값을 변경하려면 전체 패리티를
	다시 생성해야 합니다!

	다른 해시 크기를 사용하는 이유는 시스템의 메모리가 제한적인 경우입니다.
	경험상 SnapRAID는 어레이의 16TB 데이터당 일반적으로 1GiB의 RAM을
	필요로 합니다.

	구체적으로, 데이터의 해시를 저장하기 위해 SnapRAID는 대략
	TS*(1+HS)/BS 바이트의 RAM을 필요로 합니다.
	여기서 TS는 디스크 어레이의 총 크기(바이트), BS는 블록 크기(바이트),
	HS는 해시 크기(바이트)입니다.

	예를 들어, 4TB 디스크 8개, 블록 크기 256KiB
	(1KiB = 1024바이트), 해시 크기 16인 경우 다음과 같습니다:

	:RAM = (8 * 4 * 10^12) * (1+16) / (256 * 2^10) = 1.93 GiB

	해시 크기를 8로 전환하면 다음과 같습니다:

	:RAM = (8 * 4 * 10^12) * (1+8) / (256 * 2^10) = 1.02 GiB

	블록 크기를 512로 전환하면 다음과 같습니다:

	:RAM = (8 * 4 * 10^12) * (1+16) / (512 * 2^10) = 0.96 GiB

	해시 크기를 8로, 블록 크기를 512로 모두 전환하면 다음과 같습니다:

	:RAM = (8 * 4 * 10^12) * (1+8) / (512 * 2^10) = 0.51 GiB

  autosave SIZE_IN_GIGABYTES
	지정된 GB 양이 처리된 후 동기화 또는 스크럽 시 상태를 자동으로 저장합니다.
	이 옵션은 기계 충돌 또는 기타 이벤트로 인해 중단된 경우 긴 `sync`
	명령을 처음부터 다시 시작하는 것을 방지하는 데 유용합니다.

  temp_limit TEMPERATURE_CELSIUS
	허용되는 최대 디스크 온도를 섭씨로 설정합니다. 지정되면 SnapRAID는
	smartctl 도구를 사용하여 주기적으로 모든 디스크의 온도를 확인합니다.
	SnapRAID가 작동하는 동안 현재 디스크 온도가 표시됩니다.
	어떤 디스크라도 이 제한을 초과하면 모든 작업이 중지되고, 디스크는
	`temp_sleep` 옵션으로 정의된 기간 동안 회전 중지됩니다(대기 모드로
	전환됨). 절전 기간 후 작업이 재개되며, 온도 제한에 다시 도달하면
	다시 일시 중지될 수 있습니다.

	작동 중에 SnapRAID는 각 디스크의 가열 곡선을 분석하고 활동이 계속되면
	도달할 것으로 예상되는 장기 정상 온도를 추정합니다.
	추정은 디스크 온도가 네 번 증가한 후에만 수행되어, 신뢰할 수 있는
	추세를 설정하기에 충분한 데이터 포인트가 확보되도록 합니다.
	이 예측된 정상 온도는 현재 값 옆에 괄호 안에 표시되며, 시스템의
	냉각이 적절한지 평가하는 데 도움이 됩니다. 이 추정 온도는 정보 제공
	목적일 뿐이며 SnapRAID의 동작에는 영향을 미치지 않습니다.
	프로그램의 동작은 오로지 실제 측정된 디스크 온도에 기반합니다.

	이 분석을 수행하려면 SnapRAID는 시스템 온도에 대한 참조가 필요합니다.
	먼저 사용 가능한 하드웨어 센서에서 읽으려고 시도합니다.
	시스템 센서에 액세스할 수 없는 경우, 실행 시작 시 측정된 가장 낮은
	디스크 온도를 대체 참조로 사용합니다.

	일반적으로 SnapRAID는 가장 뜨거운 디스크의 온도만 표시합니다.
	모든 디스크의 온도를 표시하려면 -A 또는 --stats 옵션을 사용하십시오.

  temp_sleep TIME_IN_MINUTES
	온도 제한에 도달했을 때의 대기 시간(분)을 설정합니다. 이 기간 동안
	디스크는 회전 중지 상태를 유지합니다. 기본값은 5분입니다.

  pool DIR
	`pool` 명령을 사용하여 디스크 어레이의 가상 뷰가 생성되는 풀링
	디렉토리를 정의합니다.

	디렉토리는 이미 존재해야 합니다.

  share UNC_DIR
	디스크에 원격으로 액세스하는 데 필요한 Windows UNC 경로를 정의합니다.

	이 옵션이 지정되면 풀 디렉토리에 생성된 심볼릭 링크는 이 UNC 경로를
	사용하여 디스크에 액세스합니다.
	이 옵션이 없으면 생성된 심볼릭 링크는 로컬 경로만 사용하며, 이는
	네트워크를 통해 풀 디렉토리를 공유하는 것을 허용하지 않습니다.

	심볼릭 링크는 지정된 UNC 경로를 사용하여 형성되며, `data` 옵션에
	지정된 디스크 이름이 추가되고, 마지막으로 파일 디렉토리와 이름이
	추가됩니다.

	이 옵션은 Windows에만 필요합니다.

  smartctl DISK/PARITY OPTIONS...
	각 디스크에 대한 SMART 속성을 얻기 위한 사용자 정의 smartctl 옵션을
	정의합니다. 이는 RAID 컨트롤러 및 일부 자동 감지할 수 없는 USB 디스크에
	필요할 수 있습니다. %s 자리 표시자는 장치 이름으로 대체되지만,
	RAID 컨트롤러와 같은 고정된 장치에서는 선택 사항입니다.

	DISK는 `data` 옵션에 지정된 것과 동일한 디스크 이름입니다.
	PARITY는 `parity`, `2-parity`, `3-parity`, `4-parity`, `5-parity`,
	`6-parity`, 또는 `z-parity` 중 하나의 패리티 이름입니다.

	지정된 OPTIONS에서 `%s` 문자열은 장치 이름으로 대체됩니다.
	RAID 컨트롤러의 경우 장치가 고정되어 있을 가능성이 높으므로
	`%s`를 사용할 필요가 없을 수 있습니다.

	가능한 옵션은 smartmontools 설명서를 참조하십시오:

		:https://www.smartmontools.org/wiki/Supported_RAID-Controllers
		:https://www.smartmontools.org/wiki/Supported_USB-Devices

	예:

		:smartctl parity -d sat %s

  smartignore DISK/PARITY ATTR [ATTR...]
	디스크 실패 확률을 계산할 때 지정된 SMART 속성을 무시합니다.
	이 옵션은 디스크가 특정 속성에 대해 특이하거나 오해의 소지가 있는
	값을 보고하는 경우에 유용합니다.

	DISK는 `data` 옵션에 지정된 것과 동일한 디스크 이름입니다.
	PARITY는 `parity`, `2-parity`, `3-parity`, `4-parity`, `5-parity`,
	`6-parity`, 또는 `z-parity` 중 하나의 패리티 이름입니다.
	특수 값 *는 모든 디스크에서 속성을 무시하는 데 사용될 수 있습니다.

	예를 들어, 모든 디스크에서 `Current Pending Sector Count` 속성을
	무시하려면:

		:smartignore * 197

	첫 번째 패리티 디스크에서만 무시하려면:

		:smartignore parity 197

  Examples
	Unix의 일반적인 설정 예는 다음과 같습니다:

		:parity /mnt/diskp/snapraid.parity
		:content /mnt/diskp/snapraid.content
		:content /var/snapraid/snapraid.content
		:data d1 /mnt/disk1/
		:data d2 /mnt/disk2/
		:data d3 /mnt/disk3/
		:exclude /lost+found/
		:exclude /tmp/
		:smartctl d1 -d sat %s
		:smartctl d2 -d usbjmicron %s
		:smartctl parity -d areca,1/1 /dev/sg0
		:smartctl 2-parity -d areca,2/1 /dev/sg0

	Windows의 일반적인 설정 예는 다음과 같습니다:

		:parity E:\snapraid.parity
		:content E:\snapraid.content
		:content C:\snapraid\snapraid.content
		:data d1 G:\array\
		:data d2 H:\array\
		:data d3 I:\array\
		:exclude Thumbs.db
		:exclude \$RECYCLE.BIN
		:exclude \System Volume Information
		:smartctl d1 -d sat %s
		:smartctl d2 -d usbjmicron %s
		:smartctl parity -d areca,1/1 /dev/arcmsr0
		:smartctl 2-parity -d areca,2/1 /dev/arcmsr0

Pattern
	패턴은 포함하거나 제외할 파일을 필터링하는 유연한 방법을 제공합니다.
	글로빙(globbing) 문자를 사용하면 모든 경로를 일일이 나열하지 않고도
	특정 파일 이름이나 전체 디렉토리 구조와 일치하는 규칙을 정의할 수 있습니다.

	물음표 `?`는 디렉토리 구분 기호를 제외한 모든 단일 문자와 일치합니다.
	이는 패턴을 단일 디렉토리 수준으로 제한하면서 가변 문자가 포함된
	파일 이름을 일치시키는 데 유용합니다.

	단일 별표 `*`는 모든 문자 시퀀스와 일치하지만, 물음표와 마찬가지로
	디렉토리 경계를 넘지 않습니다. 슬래시에서 멈추므로 단일 경로 구성 요소
	내에서의 일치에 적합합니다. 이는 쉘 글로빙에서 익숙한 표준 와일드카드
	동작입니다.

	이중 별표 `**`는 더 강력하며 디렉토리 구분 기호를 포함한 모든 문자
	시퀀스와 일치합니다. 이를 통해 패턴이 여러 디렉토리 수준에서 일치할 수
	있습니다. `**`가 패턴 내에 직접 포함된 경우, 주변 리터럴 텍스트 사이의
	슬래시를 포함하여 0개 이상의 문자와 일치할 수 있습니다.

	`**`의 가장 중요한 용도는 특수 형식인 `/**/`입니다. 이는 0개 이상의
	전체 디렉토리 수준과 일치하므로 정확한 경로 구조를 모르더라도
	디렉토리 트리의 모든 깊이에서 파일과 일치시킬 수 있습니다.
	예를 들어, `src/**/main.js` 패턴은 `src/main.js`(0개의 디렉토리 건너뜀),
	`src/ui/main.js`(1개의 디렉토리 건너뜀), `src/ui/components/main.js`
	(2개의 디렉토리 건너뜀)와 일치합니다.

	대괄호 `[]`를 사용하는 문자 클래스는 지정된 세트 또는 범위에서
	단일 문자와 일치합니다. 다른 단일 문자 패턴과 마찬가지로 디렉토리
	구분 기호와는 일치하지 않습니다. 클래스는 범위 및 느낌표를 사용한
	부정을 지원합니다.

	기억해야 할 근본적인 차이점은 `*`, `?` 및 문자 클래스는 모두
	디렉토리 경계를 준수하고 단일 경로 구성 요소 내에서만 일치하는 반면,
	`**`는 디렉토리 구분 기호를 가로질러 일치할 수 있는 유일한 패턴이라는 것입니다.

	네 가지 유형의 패턴이 있습니다:

	=FILE
		FILE이라는 이름의 모든 파일을 선택합니다.
		이 패턴은 디렉토리가 아닌 파일에만 적용됩니다.

	=DIR/
		DIR이라는 이름의 모든 디렉토리와 그 안의 모든 것을 선택합니다.
		이 패턴은 파일이 아닌 디렉토리에만 적용됩니다.

	=/PATH/FILE
		지정된 정확한 파일 경로를 선택합니다. 이 패턴은 디렉토리가 아닌
		파일에만 적용됩니다.

	=/PATH/DIR/
		지정된 정확한 디렉토리 경로와 그 안의 모든 것을 선택합니다.
		이 패턴은 파일이 아닌 디렉토리에만 적용됩니다.

	/로 시작하는 절대 경로를 지정하면 로컬 파일 시스템의 루트 디렉토리가
	아닌 어레이 루트 디렉토리에 적용됩니다.

	Windows에서는 정방향 슬래시 / 대신 역슬래시 \를 사용할 수 있습니다.
	Windows 시스템 디렉토리, 접합점(junctions), 마운트 지점 및 기타
	Windows 특수 디렉토리는 파일로 취급됩니다. 즉, 이들을 제외하려면
	디렉토리 규칙이 아닌 파일 규칙을 사용해야 합니다.

	파일 이름에 '*', '?', '[',
	또는 ']' 문자가 포함된 경우, 글로빙 문자로 해석되는 것을 피하기 위해
	이스케이프해야 합니다. Unix에서는 이스케이프 문자가 '\'이고,
	Windows에서는 '^'입니다.
	패턴이 명령줄에 있는 경우, 명령 셸에 의해 해석되는 것을 피하기 위해
	이스케이프 문자를 두 배로 늘려야 합니다.

	설정 파일에서는 처리할 파일을 필터링하기 위해 다른 전략을 사용할 수
	있습니다.
	가장 간단한 접근 방식은 원하지 않는 모든 파일과 디렉토리를 제거하기
	위해 `exclude` 규칙만 사용하는 것입니다. 예를 들어:

		:# `*.unrecoverable`이라는 이름의 모든 파일 제외
		:exclude *.unrecoverable
		:# 루트 디렉토리 `/lost+found` 제외
		:exclude /lost+found/
		:# `tmp`라는 이름의 모든 하위 디렉토리 제외
		:exclude tmp/

	반대 접근 방식은 `include` 규칙만 사용하여 처리하려는 파일만
	정의하는 것입니다. 예를 들어:

		:# 일부 디렉토리만 포함
		:include /movies/
		:include /musics/
		:include /pictures/

	최종 접근 방식은 `exclude` 및 `include` 규칙을 혼합하는 것입니다.
	이 경우 규칙의 순서가 중요합니다. 앞선 규칙이 뒤의 규칙보다
	우선합니다.
	단순화를 위해 모든 `exclude` 규칙을 먼저 나열한 다음 모든
	`include` 규칙을 나열할 수 있습니다. 예를 들어:

		:# `*.unrecoverable`이라는 이름의 모든 파일 제외
		:exclude *.unrecoverable
		:# `tmp`라는 이름의 모든 하위 디렉토리 제외
		:exclude tmp/
		:# 일부 디렉토리만 포함
		:include /movies/
		:include /musics/
		:include /pictures/

	명령줄에서 -f 옵션을 사용할 때 `include` 패턴만 사용할 수 있습니다.
	예를 들어:

		:# .mp3 파일만 확인.
		:# Unix에서는 셸에 의한 글로빙 확장을 피하기 위해 따옴표를 사용합니다.
		:snapraid -f "*.mp3" check

	Unix에서는 명령줄에서 글로빙 문자를 사용할 때 셸이 확장하는 것을
	방지하기 위해 따옴표로 묶어야 합니다.

Ignore File
	설정 파일의 전역 규칙 외에도, 배열 내의 모든 디렉토리에 `.snapraidignore`
	파일을 배치하여 분산된 제외 규칙을 정의할 수 있습니다.

	`.snapraidignore`에 정의된 규칙은 설정 파일의 규칙 다음에 적용됩니다.
	이는 해당 규칙들이 더 높은 우선순위를 가지며, 전역 설정에 의해 이전에
	포함되었던 파일들을 제외하는 데 사용될 수 있음을 의미합니다. 사실상
	로컬 규칙이 일치하면, 전역 포함 설정과 관계없이 해당 파일은 제외됩니다.

	`.snapraidignore`의 패턴 로직은 전역 설정을 따르지만, 패턴은 해당 파일이
	위치한 디렉토리를 기준으로 고정됩니다:

	=FILE
		이 디렉토리 또는 그 하위에서 FILE이라는 이름의 모든 파일을 선택합니다.
		이는 전역 패턴과 동일한 글로빙(globbing) 규칙을 따릅니다.

	=DIR/
		이 디렉토리 또는 그 하위에서 DIR이라는 이름의 모든 디렉토리와
		그 안의 모든 항목을 선택합니다.

	=/PATH/FILE
		`.snapraidignore` 파일의 위치를 기준으로 지정된 정확한 파일을
		선택합니다.

	=/PATH/DIR/
		`.snapraidignore` 파일의 위치를 기준으로 지정된 정확한 디렉토리와
		그 안의 모든 항목을 선택합니다.

	전역 설정과 달리, `.snapraidignore` 파일은 제외 규칙만 지원합니다.
	`include` 패턴이나 부정(!)은 사용할 수 없습니다.

	예를 들어, `/mnt/disk1/projects/`에 `.snapraidignore`가 있는 경우:

		:# /mnt/disk1/projects/output.bin만 제외
		:/output.bin
		:# projects/ 내부의 'build'라는 이름의 모든 디렉토리 제외
		:build/
		:# projects/ 또는 그 하위 폴더의 모든 .tmp 파일 제외
		:*.tmp

Content
	SnapRAID는 content 파일에 파일 목록과 체크섬을 저장합니다.

	이것은 디스크 어레이에 있는 모든 파일의 목록과 무결성을 확인하기 위한
	모든 체크섬을 나열하는 이진 파일입니다.

	이 파일은 `sync` 및 `scrub` 명령에 의해 읽고 쓰여지며,
	`fix`, `check`, 및 `status` 명령에 의해 읽혀집니다.

Parity
	SnapRAID는 패리티 파일에 어레이의 패리티 정보를 저장합니다.

	이들은 `content` 파일에 정의된 모든 블록의 계산된 패리티를 포함하는
	이진 파일입니다.

	이 파일들은 `sync` 및 `fix` 명령에 의해 읽고 쓰여지며,
	`scrub` 및 `check` 명령에 의해서만 읽혀집니다.

Encoding
	Unix의 SnapRAID는 인코딩을 무시합니다. 파일 시스템에서 사용되는
	것과 동일한 인코딩으로 파일 이름을 읽고 저장합니다.

	Windows에서는 파일 시스템에서 읽은 모든 이름이 UTF-8 형식으로
	변환되고 처리됩니다.

	파일 이름이 올바르게 출력되도록 하려면, `chcp 65001` 명령으로
	Windows 콘솔을 UTF-8 모드로 설정하고 콘솔 글꼴로 `Lucida Console`과
	같은 TrueType 글꼴을 사용해야 합니다.
	이는 출력되는 파일 이름에만 영향을 미치며, 콘솔 출력을 파일로
	리디렉션하는 경우 결과 파일은 항상 UTF-8 형식입니다.

Copyright
	This file is Copyright (C) 2025 Andrea Mazzoleni

See Also
	snapraid_log(1), rsync(1)
