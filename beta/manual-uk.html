<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A backup program for disk arrays. It stores parity information of your data and it recovers from up to six disk failures">
    <meta name="keywords" content="snapraid snapshot raid backup disk array redundancy parity">    
    <title>SnapRAID Manual</title>
    <style>html,body{background-color:#020617;color:#f8fafc;}</style>
    <link rel="stylesheet" href="style.css">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">    
    <script src="script.js"></script>

<!-- Google Analytics 4 -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W1Z5FKHYQ4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-W1Z5FKHYQ4');
</script>

<!-- Google Universal Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body>
    <header>
        <div class="container nav-container">
            <a href="index" class="logo">
                <img src="favicon-32x32.png"/>
                SnapRAID
            </a>
            <nav>
                <input type="checkbox" id="menu-toggle">
                <label for="menu-toggle" class="menu-icon"><svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></label>
                <ul>
                    <li><a href="index" >Home</a></li>
                    <li><a href="ui" >UI & Daemon</a></li>
                    <li><a href="howitworks" >How it Works</a></li>
                    <li><a href="manual" class="active">Manual</a></li>
                    <li><a href="compare" >Compare</a></li>
                    <li><a href="design" >Design</a></li>
                    <li><a href="faq" >FAQ</a></li>
                    <li><a href="support" >Support</a></li>
                    <li><a href="download" class="nav-cta">Download</a></li>
                </ul>
            </nav>
        </div>
    </header>


    <div class="container manual-layout">
        <aside class="manual-sidebar">
            <h4>Languages</h4>
            <select id="language-selector" style="width: 100%; padding: 5px; background: var(--bg-surface); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; margin-bottom: 2rem;">
                <option value="manualHTML%">English</option>
                <option value="manual-de">German</option>
                <option value="manual-es">Spanish</option>
                <option value="manual-fr">French</option>
                <option value="manual-it">Italian</option>
                <option value="manual-ja">Japanse</option>
                <option value="manual-ko">Korean</option>
                <option value="manual-pl">Polish</option>
                <option value="manual-pt">Portuguese</option>
                <option value="manual-ro">Romanian</option>
                <option value="manual-ru">Russian</option>
                <option value="manual-sv">Swedish</option>
                <option value="manual-uk">Ukranian</option>
                <option value="manual-zh">Simplified Chinese</option>.

            </select>

            <h4>Contents</h4>
            <ul id="manual-toc-list">
                <!-- Populated by JavaScript -->
            </ul>
        </aside>

        <main id="manual-container">
            
            <div class="manual-doc">

<div class="manual-section-level-1">
<h1 id="sec1" class="manual-title-level-1">
Короткий опис
</h1>
<pre>
snapraid [-c, --conf CONFIG]
&nbsp;&nbsp;&nbsp;&nbsp;[-f, --filter PATTERN] [-d, --filter-disk NAME]
&nbsp;&nbsp;&nbsp;&nbsp;[-m, --filter-missing] [-e, --filter-error]
&nbsp;&nbsp;&nbsp;&nbsp;[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR]
&nbsp;&nbsp;&nbsp;&nbsp;[-p, --plan PERC|bad|new|full]
&nbsp;&nbsp;&nbsp;&nbsp;[-o, --older-than DAYS] [-l, --log FILE]
&nbsp;&nbsp;&nbsp;&nbsp;[-s, --spin-down-on-error] [-w, --bw-limit RATE]
&nbsp;&nbsp;&nbsp;&nbsp;[-Z, --force-zero] [-E, --force-empty]
&nbsp;&nbsp;&nbsp;&nbsp;[-U, --force-uuid] [-D, --force-device]
&nbsp;&nbsp;&nbsp;&nbsp;[-N, --force-nocopy] [-F, --force-full]
&nbsp;&nbsp;&nbsp;&nbsp;[-R, --force-realloc]
&nbsp;&nbsp;&nbsp;&nbsp;[-S, --start BLKSTART] [-B, --count BLKCOUNT]
&nbsp;&nbsp;&nbsp;&nbsp;[-L, --error-limit NUMBER]
&nbsp;&nbsp;&nbsp;&nbsp;[-A, --stats]
&nbsp;&nbsp;&nbsp;&nbsp;[-v, --verbose] [-q, --quiet]
&nbsp;&nbsp;&nbsp;&nbsp;status|smart|probe|up|down|diff|sync|scrub|fix|check
&nbsp;&nbsp;&nbsp;&nbsp;|list|dup|pool|devices|touch|rehash
</pre>
<pre>
snapraid [-V, --version] [-H, --help] [-C, --gen-conf CONTENT]
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec2" class="manual-title-level-1">
Опис
</h1>
<p>SnapRAID — це програма резервного копіювання, розроблена для
дискових масивів, яка зберігає інформацію парності для
відновлення даних у випадку відмови до шести дисків.
</p><p>В першу чергу призначена для домашніх медіацентрів з великими
файлами, що рідко змінюються, SnapRAID пропонує кілька функцій:
</p><ul>
<li>
Ви можете використовувати диски, вже заповнені файлами, без
необхідності їх переформатування, отримуючи доступ до них
як зазвичай.
</li>
<li>
Усі ваші дані хешуються для забезпечення цілісності даних
та запобігання прихованому пошкодженню.
</li>
<li>
Коли кількість дисків, що відмовили, перевищує кількість
дисків парності, втрата даних обмежується дисками, що
постраждали; дані на інших дисках залишаються доступними.
</li>
<li>
Якщо ви випадково видалили файли на диску, можливе
відновлення.
</li>
<li>
Диски можуть мати різний розмір.
</li>
<li>
Ви можете додавати диски в будь-який час.
</li>
<li>
SnapRAID не блокує ваші дані; ви можете припинити його
використання в будь-який час без переформатування або
переміщення даних.
</li>
<li>
Для доступу до файлу потрібно розкрутити лише один диск, що
заощаджує електроенергію та зменшує шум.
</li>
</ul>
<p>Для отримання додаткової інформації відвідайте офіційний сайт
SnapRAID:
</p><pre>
https://www.snapraid.it/
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec3" class="manual-title-level-1">
Обмеження
</h1>
<p>SnapRAID є гібридом між RAID та програмою резервного копіювання,
прагнучи поєднати найкращі переваги обох. Однак, він має деякі
обмеження, які слід врахувати перед його використанням.
</p><p>Основне обмеження полягає в тому, що якщо диск виходить з ладу,
а ви нещодавно не виконували синхронізацію, ви можете не
змогти повністю відновити дані.
Конкретніше, ви можете втратити можливість відновлення даних
обсягом до розміру змінених або видалених файлів з моменту
останньої операції синхронізації.
Це відбувається, навіть якщо змінені або видалені файли не
знаходяться на диску, що вийшов з ладу. Ось чому SnapRAID
краще підходить для даних, які рідко змінюються.
</p><p>З іншого боку, щойно додані файли не перешкоджають відновленню
вже існуючих файлів. Ви втратите лише нещодавно додані файли,
якщо вони знаходяться на диску, що вийшов з ладу.
</p><p>Інші обмеження SnapRAID:
</p><ul>
<li>
З SnapRAID у вас все ще є окремі файлові системи для
кожного диска. З RAID ви отримуєте одну велику файлову
систему.
</li>
<li>
SnapRAID не використовує чергування (striping) даних.
З RAID ви отримуєте прискорення завдяки чергуванню.
</li>
<li>
SnapRAID не підтримує відновлення в реальному часі.
З RAID вам не потрібно припиняти роботу, коли диск
виходить з ладу.
</li>
<li>
SnapRAID може відновлювати дані лише з обмеженої кількості
дисків, що вийшли з ладу. З резервним копіюванням ви
можете відновити дані навіть після повної відмови
всього дискового масиву.
</li>
<li>
Зберігаються лише імена файлів, часові мітки, символічні
та жорсткі посилання. Права доступу, власність та
розширені атрибути не зберігаються.
</li>
</ul>
</div>
<div class="manual-section-level-1">
<h1 id="sec4" class="manual-title-level-1">
Початок роботи
</h1>
<p>Щоб використовувати SnapRAID, спершу потрібно вибрати один диск
у вашому дисковому масиві, щоб присвятити його інформації
`парності`. З одним диском для парності ви зможете відновити
дані після відмови одного диска, подібно до RAID5.
</p><p>Якщо ви хочете відновити дані після більшої кількості
дисків, що відмовили, подібно до RAID6, ви повинні зарезервувати
додаткові диски для парності. Кожен додатковий диск парності
дозволяє відновити дані після відмови ще одного диска.
</p><p>Як диски парності ви повинні вибрати найбільші диски в масиві,
оскільки інформація парності може зрости до розміру найбільшого
диска даних у масиві.
</p><p>Ці диски будуть присвячені зберіганню файлів `парності`. Ви
не повинні зберігати на них свої дані.
</p><p>Потім ви повинні визначити диски `даних`, які ви хочете
захистити за допомогою SnapRAID. Захист є більш ефективним,
якщо ці диски містять дані, що рідко змінюються. З цієї причини
краще НЕ включати диск Windows C:\ або каталоги Unix /home,
/var та /tmp.
</p><p>Список файлів зберігається у файлах `content` (вміст), які
зазвичай зберігаються на дисках даних, парності або завантажувальних
дисках.
Цей файл містить деталі вашої резервної копії, включаючи
всі контрольні суми для перевірки її цілісності.
Файл `content` зберігається в кількох копіях, і кожна копія
повинна бути на окремому диску, щоб гарантувати, що навіть у
разі відмови кількох дисків, принаймні одна копія буде доступна.
</p><p>Наприклад, припустимо, вас цікавить лише один рівень захисту
парності, а ваші диски розташовані за адресами:
</p><pre>
/mnt/diskp &lt;- вибраний диск для парності
/mnt/disk1 &lt;- перший диск для захисту
/mnt/disk2 &lt;- другий диск для захисту
/mnt/disk3 &lt;- третій диск для захисту
</pre>
<p>Ви повинні створити конфігураційний файл /etc/snapraid.conf з
наступними опціями:
</p><pre>
parity /mnt/diskp/snapraid.parity
content /var/snapraid/snapraid.content
content /mnt/disk1/snapraid.content
content /mnt/disk2/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
</pre>
<p>Якщо ви працюєте в Windows, ви повинні використовувати формат
шляху Windows, з літерами дисків та зворотними скісними рисками
замість прямих.
</p><pre>
parity E:\snapraid.parity
content C:\snapraid\snapraid.content
content F:\array\snapraid.content
content G:\array\snapraid.content
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
</pre>
<p>Якщо у вас багато дисків і закінчилися літери дисків, ви можете
монтувати диски безпосередньо у вкладені папки. Див:
</p><pre>
https://www.google.com/search?q=Windows+mount+point
</pre>
<p>На цьому етапі ви готові запустити команду `sync` для побудови
інформації парності.
</p><pre>
snapraid sync
</pre>
<p>Цей процес може зайняти кілька годин вперше, залежно від розміру
даних, які вже є на дисках. Якщо диски порожні, процес
відбувається миттєво.
</p><p>Ви можете зупинити його в будь-який час, натиснувши Ctrl+C,
і під час наступного запуску він відновить роботу з місця,
де був перерваний.
</p><p>Коли ця команда завершиться, ваші дані БЕЗПЕЧНІ.
</p><p>Тепер ви можете почати використовувати свій масив як вам подобається
і періодично оновлювати інформацію парності, запускаючи команду `sync`.
</p><div class="manual-section-level-2">
<h2 id="sec4-1" class="manual-title-level-2">
Скрабування (Scrubbing)
</h2>
<p>Щоб періодично перевіряти дані та парність на наявність помилок,
ви можете запустити команду `scrub`.
</p><pre>
snapraid scrub
</pre>
<p>Ця команда порівнює дані у вашому масиві з хешем, обчисленим
під час команди `sync`, для перевірки цілісності.
</p><p>Кожен запуск команди перевіряє приблизно 8% масиву, виключаючи
дані, які вже були скрабовані протягом попередніх 10 днів.
Ви можете використовувати опцію -p, --plan, щоб вказати іншу
кількість, і опцію -o, --older-than, щоб вказати інший вік
у днях.
Наприклад, щоб перевірити 5% масиву на блоки старші за 20 днів,
використовуйте:
</p><pre>
snapraid -p 5 -o 20 scrub
</pre>
<p>Якщо під час процесу виявлено приховані помилки або помилки
введення/виведення, відповідні блоки позначаються як погані у
файлі `content` і перераховуються у команді `status`.
</p><pre>
snapraid status
</pre>
<p>Щоб їх виправити, ви можете використовувати команду `fix`,
фільтруючи погані блоки за допомогою опції -e, --filter-error:
</p><pre>
snapraid -e fix
</pre>
<p>Під час наступного `scrub` помилки зникнуть зі звіту `status`,
якщо вони справді виправлені. Щоб зробити це швидше, ви можете
використовувати -p bad, щоб скрабувати лише блоки, позначені
як погані.
</p><pre>
snapraid -p bad scrub
</pre>
<p>Запуск `scrub` на несинхронізованому масиві може повідомити
про помилки, спричинені видаленими або зміненими файлами.
Ці помилки відображаються у виведенні `scrub`, але пов'язані
блоки не позначаються як погані.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec4-2" class="manual-title-level-2">
Об'єднання (Pooling)
</h2>
<p>Примітка: Функція об'єднання, описана нижче, була замінена
інструментом mergefs, який тепер є рекомендованою опцією для
користувачів Linux у спільноті SnapRAID. Mergefs забезпечує
більш гнучкий та ефективний спосіб об'єднання кількох дисків
в єдину уніфіковану точку монтування, дозволяючи безперешкодний
доступ до файлів у вашому масиві без використання символічних
посилань. Він добре інтегрується з SnapRAID для захисту
парності і зазвичай використовується в налаштуваннях, таких
як OpenMediaVault (OMV) або користувацьких конфігураціях NAS.
</p><p>Щоб відобразити всі файли у вашому масиві в одному дереві
каталогів, ви можете ввімкнути функцію `pooling` (об'єднання).
Вона створює віртуальне представлення всіх файлів у вашому
масиві лише для читання, використовуючи символічні посилання.
</p><p>Ви можете налаштувати каталог `pooling` у конфігураційному
файлі за допомогою:
</p><pre>
pool /pool
</pre>
<p>або, якщо ви працюєте в Windows, за допомогою:
</p><pre>
pool C:\pool
</pre>
<p>а потім запустити команду `pool` для створення або оновлення
віртуального представлення.
</p><pre>
snapraid pool
</pre>
<p>Якщо ви використовуєте платформу Unix і хочете надати спільний
доступ до цього каталогу через мережу для машин Windows або
Unix, ви повинні додати наступні опції до вашого
/etc/samba/smb.conf:
</p><pre>
# У глобальному розділі smb.conf
unix extensions = no
</pre>
<pre>
# У розділі спільного доступу smb.conf
[pool]
comment = Pool
path = /pool
read only = yes
guest ok = yes
wide links = yes
follow symlinks = yes
</pre>
<p>У Windows спільний доступ до символічних посилань через мережу
вимагає від клієнтів віддаленого їх розпізнавання. Щоб
увімкнути це, окрім спільного доступу до каталогу pool, ви
також повинні надати спільний доступ до всіх дисків незалежно,
використовуючи імена дисків, визначені у конфігураційному
файлі, як точки спільного доступу. Ви також повинні вказати у
опції `share` конфігураційного файлу шлях Windows UNC, який
потрібен віддаленим клієнтам для доступу до цих спільних дисків.
</p><p>Наприклад, працюючи з сервера з іменем `darkstar`, ви можете
використовувати опції:
</p><pre>
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
pool C:\pool
share \\darkstar
</pre>
<p>і надати спільний доступ до наступних каталогів через мережу:
</p><pre>
\\darkstar\pool -&gt; C:\pool
\\darkstar\d1 -&gt; F:\array
\\darkstar\d2 -&gt; G:\array
\\darkstar\d3 -&gt; H:\array
</pre>
<p>щоб дозволити віддаленим клієнтам отримати доступ до всіх файлів
за адресою \\darkstar\pool.
</p><p>Вам також може знадобитися налаштувати віддалені клієнти, щоб
увімкнути доступ до віддалених символічних посилань за допомогою
команди:
</p><pre>
fsutil behavior set SymlinkEvaluation L2L:1 R2R:1 L2R:1 R2L:1
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec4-3" class="manual-title-level-2">
Відновлення видалених файлів (Undeleting)
</h2>
<p>SnapRAID функціонує більше як програма резервного копіювання,
ніж система RAID, і його можна використовувати для відновлення
або повернення файлів до їх попереднього стану за допомогою
опції -f, --filter:
</p><pre>
snapraid fix -f FILE
</pre>
<p>або для каталогу:
</p><pre>
snapraid fix -f DIR/
</pre>
<p>Ви також можете використовувати його для відновлення лише випадково
видалених файлів усередині каталогу за допомогою опції -m,
--filter-missing, яка відновлює лише відсутні файли,
залишаючи всі інші недоторканими.
</p><pre>
snapraid fix -m -f DIR/
</pre>
<p>Або для відновлення всіх видалених файлів на всіх дисках за допомогою:
</p><pre>
snapraid fix -m
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec4-4" class="manual-title-level-2">
Відновлення (Recovering)
</h2>
<p>Сталося найгірше, і ви втратили один або кілька дисків!
</p><p>НЕ ПАНІКУЙТЕ! Ви зможете їх відновити!
</p><p>Перше, що ви повинні зробити, це уникнути подальших змін у
вашому дисковому масиві. Вимкніть будь-які віддалені
підключення до нього та будь-які заплановані процеси,
включаючи будь-яку заплановану нічну синхронізацію або
скрабування SnapRAID.
</p><p>Потім виконайте наступні кроки.
</p><div class="manual-section-level-3">
<h3 id="sec4-4-1" class="manual-title-level-3">
КРОК 1 -&gt; Переналаштування
</h3>
<p>Вам потрібен деякий простір для відновлення, в ідеалі на
додаткових запасних дисках, але зовнішній USB-диск або
віддалений диск підійде.
</p><p>Змініть конфігураційний файл SnapRAID, щоб опція `data` або
`parity` диска, що вийшов з ладу, вказувала на місце розташування
з достатньою кількістю вільного місця для відновлення файлів.
</p><p>Наприклад, якщо диск `d1` вийшов з ладу, змініть з:
</p><pre>
data d1 /mnt/disk1/
</pre>
<p>на:
</p><pre>
data d1 /mnt/new_spare_disk/
</pre>
<p>Якщо диск, який потрібно відновити, є диском парності, оновіть
відповідну опцію `parity`.
Якщо у вас кілька дисків, що вийшли з ладу, оновіть усі їхні
конфігураційні опції.
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-2" class="manual-title-level-3">
КРОК 2 -&gt; Виправлення (Fix)
</h3>
<p>Запустіть команду fix, зберігаючи журнал у зовнішньому файлі
за допомогою:
</p><pre>
snapraid -d NAME -l fix.log fix
</pre>
<p>Де NAME — це ім'я диска, наприклад `d1` у нашому попередньому
прикладі.
Якщо диск, який потрібно відновити, є диском парності,
використовуйте імена `parity`, `2-parity`, тощо.
Якщо у вас кілька дисків, що вийшли з ладу, використовуйте
кілька опцій -d, щоб вказати їх усі.
</p><p>Ця команда займе багато часу.
</p><p>Переконайтеся, що у вас є кілька гігабайт вільного місця для
зберігання файлу fix.log.
Запустіть її з диска з достатньою кількістю вільного місця.
</p><p>Тепер ви відновили все, що можна відновити. Якщо деякі файли
частково або повністю неможливо відновити, вони будуть перейменовані
з додаванням розширення `.unrecoverable`.
</p><p>Ви можете знайти детальний список усіх невідновлюваних блоків
у файлі fix.log, перевіривши всі рядки, що починаються з
`unrecoverable:`.
</p><p>Якщо ви не задоволені відновленням, ви можете повторити його
стільки разів, скільки забажаєте.
</p><p>Наприклад, якщо ви видалили файли з масиву після останньої
`sync`, це може призвести до того, що деякі файли не будуть
відновлені.
У цьому випадку ви можете повторити `fix`, використовуючи
опцію -i, --import, вказавши, де ці файли знаходяться зараз,
щоб знову включити їх у процес відновлення.
</p><p>Якщо ви задоволені відновленням, ви можете продовжити, але
зауважте, що після синхронізації ви більше не зможете повторити
команду `fix`!
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-3" class="manual-title-level-3">
КРОК 3 -&gt; Перевірка (Check)
</h3>
<p>Як обережну перевірку, ви можете тепер запустити команду
`check`, щоб переконатися, що на відновленому диску все
правильно.
</p><pre>
snapraid -d NAME -a check
</pre>
<p>Де NAME — це ім'я диска, наприклад `d1` у нашому попередньому
прикладі.
</p><p>Опції -d та -a вказують SnapRAID перевіряти лише вказаний
диск та ігнорувати всі дані парності.
</p><p>Ця команда займе багато часу, але якщо ви не надто обережні,
ви можете її пропустити.
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-4" class="manual-title-level-3">
КРОК 4 -&gt; Синхронізація (Sync)
</h3>
<p>Запустіть команду `sync`, щоб повторно синхронізувати масив
з новим диском.
</p><pre>
snapraid sync
</pre>
<p>Якщо все відновлено, ця команда виконується миттєво.
</p></div>
</div>
</div>
<div class="manual-section-level-1">
<h1 id="sec5" class="manual-title-level-1">
Команди
</h1>
<p>SnapRAID надає кілька простих команд, які дозволяють:
</p><ul>
<li>
Вивести статус масиву -&gt; `status`
</li>
<li>
Керувати дисками -&gt; `smart`, `probe`, `up`, `down`
</li>
<li>
Створити резервну копію/знімок -&gt; `sync`
</li>
<li>
Періодично перевіряти дані -&gt; `scrub`
</li>
<li>
Відновити останню резервну копію/знімок -&gt; `fix`.
</li>
</ul>
<p>Команди повинні бути написані малими літерами.
</p><div class="manual-section-level-2">
<h2 id="sec5-1" class="manual-title-level-2">
status
</h2>
<p>Виводить зведення стану дискового масиву.
</p><p>Включає інформацію про фрагментацію парності, вік блоків без
перевірки та всі записані приховані помилки, виявлені під
час скрабування.
</p><p>Представлена інформація стосується останнього часу, коли ви
запустили `sync`. Пізніші модифікації не враховуються.
</p><p>Якщо виявлено погані блоки, перераховуються їхні номери блоків.
Щоб їх виправити, ви можете використовувати команду `fix -e`.
</p><p>Також показує графік, що представляє останній час, коли
кожен блок був скрабований або синхронізований. Скрабовані
блоки позначаються символом '*', блоки, синхронізовані,
але ще не скрабовані, - 'o'.
</p><p>Нічого не змінюється.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-2" class="manual-title-level-2">
smart
</h2>
<p>Виводить звіт SMART усіх дисків у системі.
</p><p>Включає оцінку ймовірності відмови протягом наступного року,
дозволяючи вам планувати планову заміну дисків, які
виявляють підозрілі атрибути.
</p><p>Ця оцінка ймовірності отримана шляхом кореляції атрибутів
SMART дисків з даними Backblaze, доступними за адресою:
</p><pre>
https://www.backblaze.com/hard-drive-test-data.html
</pre>
<p>Якщо SMART повідомляє, що диск виходить з ладу, для цього
диска виводиться `FAIL` або `PREFAIL`, і SnapRAID повертає
помилку. У цьому випадку настійно рекомендується негайна
заміна диска.
</p><p>Інші можливі рядки стану:
</p><div class="manual-tag-list">
<div class="manual-tag-entry">
<div class="manual-tag-name">
logfail
</div><div class="manual-tag-description">
У минулому деякі атрибути були нижчими за
поріг.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
logerr
</div><div class="manual-tag-description">
Журнал помилок пристрою містить помилки.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
selferr
</div><div class="manual-tag-description">
Журнал самотестування пристрою містить помилки.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>Якщо вказано опцію -v, --verbose, надається глибший
статистичний аналіз. Цей аналіз може допомогти вам вирішити,
чи потрібна вам більша або менша парність.
</p><p>Ця команда використовує інструмент `smartctl` і еквівалентна
запуску `smartctl -a` на всіх пристроях.
</p><p>Якщо ваші пристрої не виявляються автоматично правильно, ви
можете вказати користувацьку команду, використовуючи опцію
`smartctl` у конфігураційному файлі.
</p><p>Нічого не змінюється.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-3" class="manual-title-level-2">
probe
</h2>
<p>Виводить стан ЖИВЛЕННЯ всіх дисків у системі.
</p><p>`Standby` означає, що диск не обертається. `Active` означає,
що диск обертається.
</p><p>Ця команда використовує інструмент `smartctl` і еквівалентна
запуску `smartctl -n standby -i` на всіх пристроях.
</p><p>Якщо ваші пристрої не виявляються автоматично правильно, ви
можете вказати користувацьку команду, використовуючи опцію
`smartctl` у конфігураційному файлі.
</p><p>Нічого не змінюється.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-4" class="manual-title-level-2">
up
</h2>
<p>Розкручує всі диски масиву.
</p><p>Ви можете розкрутити лише певні диски, використовуючи
опцію -d, --filter-disk.
</p><p>Одночасне розкручування всіх дисків вимагає багато енергії.
Переконайтеся, що ваш блок живлення може це витримати.
</p><p>Нічого не змінюється.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-5" class="manual-title-level-2">
down
</h2>
<p>Зупиняє всі диски масиву.
</p><p>Ця команда використовує інструмент `smartctl` і еквівалентна
запуску `smartctl -s standby,now` на всіх пристроях.
</p><p>Ви можете зупинити лише певні диски, використовуючи
опцію -d, --filter-disk.
</p><p>Для автоматичної зупинки при помилці ви можете
використовувати опцію -s, --spin-down-on-error з будь-якою
іншою командою, що еквівалентно ручному запуску `down`
при виникненні помилки.
</p><p>Нічого не змінюється.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-6" class="manual-title-level-2">
diff
</h2>
<p>Виводить список усіх файлів, змінених з моменту останньої
`sync`, для яких необхідно перерахувати дані парності.
</p><p>Ця команда не перевіряє дані файлів, а лише часову мітку
файлу, розмір та inode.
</p><p>Після перерахування всіх змінених файлів представляється
зведення змін, згруповане за:
</p><div class="manual-tag-list">
<div class="manual-tag-entry">
<div class="manual-tag-name">
equal (рівні)
</div><div class="manual-tag-description">
Файли, незмінені з попереднього стану.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
added (додані)
</div><div class="manual-tag-description">
Файли, додані, яких не було раніше.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
removed (видалені)
</div><div class="manual-tag-description">
Файли, видалені.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
updated (оновлені)
</div><div class="manual-tag-description">
Файли з іншим розміром або часовою
міткою, що означає, що вони були змінені.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
moved (переміщені)
</div><div class="manual-tag-description">
Файли, переміщені в інший каталог
на тому ж диску. Вони ідентифікуються за тим же
іменем, розміром, часовою міткою та inode, але іншим
каталогом.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
copied (скопійовані)
</div><div class="manual-tag-description">
Файли, скопійовані на тому ж
або іншому диску. Зауважте, що якщо вони справді
переміщені на інший диск, вони також будуть враховані
як `removed`.
Вони ідентифікуються за тим же іменем, розміром
та часовою міткою. Якщо часова мітка з точністю
до долі секунди дорівнює нулю, повний шлях повинен
збігатися, а не лише ім'я.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
restored (відновлені)
</div><div class="manual-tag-description">
Файли з іншим inode, але
збігаються ім'я, розмір та часова мітка. Це
зазвичай файли, відновлені після видалення.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>Якщо потрібна `sync`, код повернення процесу дорівнює 2,
замість стандартного 0. Код повернення 1 використовується для
загальної умови помилки.
</p><p>Нічого не змінюється.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-7" class="manual-title-level-2">
sync
</h2>
<p>Оновлює інформацію парності. Всі змінені файли у дисковому
масиві зчитуються, і відповідні дані парності оновлюються.
</p><p>Ви можете зупинити цей процес у будь-який час, натиснувши
Ctrl+C, не втрачаючи вже виконану роботу.
Під час наступного запуску процес `sync` відновить роботу
з місця, де був перерваний.
</p><p>Якщо під час процесу виявлено приховані помилки або помилки
введення/виведення, відповідні блоки позначаються як погані.
</p><p>Файли ідентифікуються за шляхом та/або inode та перевіряються
за розміром та часовою міткою.
Якщо розмір або часова мітка файлу відрізняються, дані
парності перераховуються для всього файлу.
Якщо файл переміщено або перейменовано на тому ж диску,
зберігаючи той самий inode, парність не перераховується.
Якщо файл переміщено на інший диск, парність перераховується,
але раніше обчислена інформація хешу зберігається.
</p><p>Файли `content` та `parity` змінюються за потреби.
Файли в масиві НЕ змінюються.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-8" class="manual-title-level-2">
scrub
</h2>
<p>Скрабує масив, перевіряючи на наявність прихованих помилок
або помилок введення/виведення на дисках даних та парності.
</p><p>Кожен виклик перевіряє приблизно 8% масиву, виключаючи
дані, які вже були скрабовані протягом останніх 10 днів.
Це означає, що скрабування раз на тиждень забезпечує
перевірку кожного біта даних принаймні раз на три місяці.
</p><p>Ви можете визначити інший план скрабування або кількість
за допомогою опції -p, --plan, яка приймає:
bad - Скрабувати блоки, позначені як погані.
new - Скрабувати щойно синхронізовані блоки, які ще не були
</p><p>скрабовані.
</p><div class="manual-tag-list">
<div class="manual-tag-entry">
<div class="manual-tag-name">
full
</div><div class="manual-tag-description">
Скрабувати все.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
0-100
</div><div class="manual-tag-description">
Скрабувати вказаний відсоток блоків.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>Якщо ви вказуєте відсоткове значення, ви також можете
використовувати опцію -o, --older-than, щоб визначити,
яким має бути вік блоку.
Найстаріші блоки скрабуються першими, забезпечуючи оптимальну
перевірку.
Якщо ви хочете скрабувати лише щойно синхронізовані блоки,
які ще не були скрабовані, використовуйте опцію `-p new`.
</p><p>Щоб отримати деталі статусу скрабування, використовуйте команду
`status`.
</p><p>Для будь-якої знайденої прихованої помилки або помилки
введення/виведення відповідні блоки позначаються як погані
у файлі `content`.
Ці погані блоки перераховуються у `status` і можуть бути
виправлені за допомогою `fix -e`.
Після виправлення, під час наступного скрабування, вони будуть
повторно перевірені, і якщо виявиться, що вони виправлені,
позначка "поганий" буде видалена.
Щоб скрабувати лише погані блоки, ви можете використовувати
команду `scrub -p bad`.
</p><p>Рекомендується запускати `scrub` лише на синхронізованому
масиві, щоб уникнути повідомлень про помилки, спричинені
несинхронізованими даними. Ці помилки розпізнаються як
не приховані помилки, і блоки не позначаються як погані,
але такі помилки повідомляються у виведенні команди.
</p><p>Файл `content` змінюється для оновлення часу останньої перевірки
для кожного блоку та для позначення поганих блоків.
Файли `parity` НЕ змінюються.
Файли в масиві НЕ змінюються.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-9" class="manual-title-level-2">
fix
</h2>
<p>Виправляє всі файли та дані парності.
</p><p>Усі файли та дані парності порівнюються зі станом знімка,
збереженим під час останньої `sync`.
Якщо знайдено різницю, вона повертається до збереженого знімка.
</p><p>УВАГА! Команда `fix` не розрізняє помилки та навмисні
модифікації. Вона безумовно повертає стан файлу до останньої
`sync`.
</p><p>Якщо не вказано жодної іншої опції, обробляється весь масив.
Використовуйте опції фільтра, щоб вибрати підмножину файлів
або дисків для роботи.
</p><p>Щоб виправити лише блоки, позначені як погані під час `sync`
та `scrub`, використовуйте опцію -e, --filter-error.
На відміну від інших опцій фільтра, ця застосовує виправлення
лише до файлів, які не змінилися з моменту останньої `sync`.
</p><p>SnapRAID перейменовує всі файли, які не можуть бути виправлені,
додаючи розширення `.unrecoverable`.
</p><p>Перед виправленням сканується весь масив, щоб знайти будь-які
файли, переміщені з моменту останньої `sync`.
Ці файли ідентифікуються за їхньою часовою міткою, ігноруючи
їхнє ім'я та каталог, і використовуються в процесі відновлення,
якщо це необхідно.
Якщо ви перемістили деякі з них за межі масиву, ви можете
використовувати опцію -i, --import, щоб вказати додаткові
каталоги для сканування.
</p><p>Файли ідентифікуються лише за шляхом, а не за inode.
</p><p>Файл `content` НЕ змінюється.
Файли `parity` змінюються за потреби.
Файли в масиві змінюються за потреби.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-10" class="manual-title-level-2">
check
</h2>
<p>Перевіряє всі файли та дані парності.
</p><p>Працює як `fix`, але лише імітує відновлення, і жодні зміни
не записуються в масив.
</p><p>Ця команда в першу чергу призначена для ручної перевірки,
наприклад, після процесу відновлення або в інших особливих
умовах. Для періодичних та запланованих перевірок використовуйте
`scrub`.
</p><p>Якщо ви використовуєте опцію -a, --audit-only, перевіряється
лише хеш файлів, а дані парності ігноруються для швидшого
запуску.
</p><p>Файли ідентифікуються лише за шляхом, а не за inode.
</p><p>Нічого не змінюється.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-11" class="manual-title-level-2">
list
</h2>
<p>Виводить список усіх файлів, що містяться в масиві на момент
останньої `sync`.
</p><p>З -v або --verbose також показується час з точністю до
долі секунди.
</p><p>Нічого не змінюється.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-12" class="manual-title-level-2">
dup
</h2>
<p>Виводить список усіх дублікатів файлів. Два файли вважаються
рівними, якщо їхні хеші збігаються. Дані файлів не
зчитуються; використовуються лише попередньо обчислені хеші.
</p><p>Нічого не змінюється.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-13" class="manual-title-level-2">
pool
</h2>
<p>Створює або оновлює віртуальне представлення всіх файлів
у вашому дисковому масиві в каталозі `pooling`.
</p><p>Файли не копіюються, а пов'язуються за допомогою символічних
посилань.
</p><p>Під час оновлення всі існуючі символічні посилання та порожні
підкаталоги видаляються та замінюються новим
представленням масиву. Будь-які інші звичайні файли залишаються
на місці.
</p><p>Нічого не змінюється за межами каталогу pool.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-14" class="manual-title-level-2">
devices
</h2>
<p>Виводить низькорівневі пристрої, які використовуються масивом.
</p><p>Ця команда відображає асоціації пристроїв у масиві і в
основному призначена як інтерфейс для сценаріїв.
</p><p>Перші два стовпці — це низькорівневий ідентифікатор пристрою
та шлях.
Наступні два стовпці — це високорівневий ідентифікатор пристрою
та шлях.
Останній стовпець — це ім'я диска в масиві.
</p><p>У більшості випадків у вас є один низькорівневий пристрій для
кожного диска в масиві, але в деяких складніших конфігураціях
у вас може бути кілька низькорівневих пристроїв, які використовуються
одним диском у масиві.
</p><p>Нічого не змінюється.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-15" class="manual-title-level-2">
touch
</h2>
<p>Встановлює довільну часову мітку з точністю до долі секунди
для всіх файлів, у яких вона встановлена на нуль.
</p><p>Це покращує здатність SnapRAID розпізнавати переміщені та
скопійовані файли, оскільки робить часову мітку майже
унікальною, зменшуючи можливі дублікати.
</p><p>Зокрема, якщо часова мітка з точністю до долі секунди не
дорівнює нулю, переміщений або скопійований файл ідентифікується
як такий, якщо він збігається з іменем, розміром та часовою
міткою. Якщо часова мітка з точністю до долі секунди дорівнює
нулю, він вважається копією, лише якщо повний шлях, розмір та
часова мітка збігаються.
</p><p>Часова мітка з точністю до секунди не змінюється, тому
всі дати та час ваших файлів будуть збережені.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-16" class="manual-title-level-2">
rehash
</h2>
<p>Планує повторне хешування всього масиву.
</p><p>Ця команда змінює тип хешу, що використовується, як правило,
при оновленні з 32-розрядної системи на 64-розрядну, щоб
переключитися з MurmurHash3 на швидший SpookyHash.
</p><p>Якщо ви вже використовуєте оптимальний хеш, ця команда
нічого не робить і повідомляє, що жодних дій не потрібно.
</p><p>Повторне хешування не виконується негайно, а відбувається
поступово під час `sync` та `scrub`.
</p><p>Ви можете перевірити стан повторного хешування за допомогою
`status`.
</p><p>Під час повторного хешування SnapRAID зберігає повну
функціональність, за єдиним винятком, що `dup` не може
виявити дублікати файлів, використовуючи інший хеш.
</p></div>
</div>
<div class="manual-section-level-1">
<h1 id="sec6" class="manual-title-level-1">
Опції
</h1>
<p>SnapRAID надає наступні опції:
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-c, --conf CONFIG
</div><div class="manual-option-description">
Вибирає конфігураційний файл для використання. Якщо не
вказано, в Unix використовується файл `/usr/local/etc/snapraid.conf`,
якщо він існує, інакше `/etc/snapraid.conf`.
У Windows використовується файл `snapraid.conf` у тому
самому каталозі, що й `snapraid.exe`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-f, --filter PATTERN
</div><div class="manual-option-description">
Фільтрує файли для обробки у `check` та `fix`.
Обробляються лише файли, що відповідають вказаному
шаблону. Цю опцію можна використовувати кілька разів.
Дивіться розділ PATTERN для отримання додаткової
інформації про специфікації шаблонів.
В Unix переконайтеся, що символи глоббінгу взяті
в лапки, якщо вони використовуються.
Цю опцію можна використовувати лише з `check` та `fix`.
Її не можна використовувати з `sync` та `scrub`, оскільки
вони завжди обробляють весь масив.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-d, --filter-disk NAME
</div><div class="manual-option-description">
Фільтрує диски для обробки у `check`, `fix`, `up` та `down`.
Ви повинні вказати ім'я диска, як визначено у
конфігураційному файлі.
Ви також можете вказати диски парності з іменами:
`parity`, `2-parity`, `3-parity`, тощо, щоб обмежити
операції певним диском парності.
Якщо ви поєднуєте кілька опцій --filter, --filter-disk
та --filter-missing, вибираються лише файли, що
відповідають усім фільтрам.
Цю опцію можна використовувати кілька разів.
Цю опцію можна використовувати лише з `check`, `fix`,
`up` та `down`.
Її не можна використовувати з `sync` та `scrub`, оскільки
вони завжди обробляють весь масив.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-m, --filter-missing
</div><div class="manual-option-description">
Фільтрує файли для обробки у `check` та `fix`.
Обробляються лише файли, що відсутні або видалені з
масиву. При використанні з `fix` це діє як команда
`undelete` (відновлення видалених файлів).
Якщо ви поєднуєте кілька опцій --filter, --filter-disk
та --filter-missing, вибираються лише файли, що
відповідають усім фільтрам.
Цю опцію можна використовувати лише з `check` та `fix`.
Її не можна використовувати з `sync` та `scrub`, оскільки
вони завжди обробляють весь масив.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-e, --filter-error
</div><div class="manual-option-description">
Обробляє файли з помилками у `check` та `fix`.
Обробляє лише файли, які мають блоки, позначені
прихованими помилками або помилками введення/виведення
під час `sync` та `scrub`, як зазначено у `status`.
Цю опцію можна використовувати лише з `check` та `fix`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-p, --plan PERC|bad|new|full
</div><div class="manual-option-description">
Вибирає план скрабування. Якщо PERC є числовим
значенням від 0 до 100, воно інтерпретується як відсоток
блоків для скрабування.
Замість відсотка ви можете вказати план: `bad`
скрабує погані блоки, `new` скрабує блоки, які ще не
були скрабовані, і `full` скрабує все.
Цю опцію можна використовувати лише з `scrub`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-o, --older-than DAYS
</div><div class="manual-option-description">
Вибирає найстарішу частину масиву для обробки у `scrub`.
DAYS — це мінімальний вік у днях для блоку, який
повинен бути скрабований; за замовчуванням 10.
Блоки, позначені як погані, завжди скрабуються
незалежно від цієї опції.
Цю опцію можна використовувати лише з `scrub`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-a, --audit-only
</div><div class="manual-option-description">
У `check` перевіряє хеш файлів без перевірки даних
парності. Якщо вас цікавить лише перевірка даних файлів,
ця опція може значно прискорити процес перевірки.
Цю опцію можна використовувати лише з `check`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-h, --pre-hash
</div><div class="manual-option-description">
У `sync` запускає попередню фазу хешування всіх нових
даних для додаткової перевірки перед обчисленням
парності. Зазвичай у `sync` не виконується попереднє
хешування, а нові дані хешуються безпосередньо перед
обчисленням парності, коли вони зчитуються вперше.
Цей процес відбувається, коли система знаходиться під
великим навантаженням, усі диски обертаються та ЦП
зайнятий. Це екстремальна умова для машини, і якщо вона
має приховану апаратну проблему, приховані помилки
можуть залишитися невиявленими, оскільки дані ще не
були хешовані.
Щоб уникнути цього ризику, ви можете ввімкнути режим
`pre-hash`, щоб усі дані були зчитані двічі для
забезпечення їх цілісності.
Ця опція також перевіряє файли, переміщені в межах
масиву, щоб переконатися, що операція переміщення була
успішною, і, якщо необхідно, дозволяє запустити операцію
виправлення перед продовженням.
Цю опцію можна використовувати лише з `sync`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-i, --import DIR
</div><div class="manual-option-description">
Імпортує з вказаного каталогу будь-які файли, видалені
з масиву після останньої `sync`.
Якщо у вас все ще є такі файли, вони можуть бути
використані `check` та `fix` для покращення процесу
відновлення.
Файли зчитуються, включаючи підкаталоги, та
ідентифікуються незалежно від їхнього імені.
Цю опцію можна використовувати лише з `check` та `fix`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-s, --spin-down-on-error
</div><div class="manual-option-description">
При будь-якій помилці зупиняє всі керовані диски перед
завершенням з ненульовим кодом стану. Це запобігає
тому, щоб диски залишалися активними та оберталися
після перерваної операції, допомагаючи уникнути
зайвого нагрівання та споживання електроенергії.
Використовуйте цю опцію, щоб забезпечити безпечну
зупинку дисків, навіть коли команда завершується
помилкою.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-w, --bw-limit RATE
</div><div class="manual-option-description">
Застосовує глобальне обмеження пропускної здатності
для всіх дисків. RATE — це кількість байтів на секунду.
Ви можете вказати множник, такий як K, M або G (наприклад,
--bw-limit 1G).
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-A, --stats
</div><div class="manual-option-description">
Вмикає розширений перегляд стану, який показує
додаткову інформацію.
На екрані відображаються два графіки:
Перший графік показує кількість буферизованих смуг
(stripes) для кожного диска, разом зі шляхом до файлу,
до якого наразі здійснюється доступ на цьому диску.
Зазвичай найповільніший диск не матиме доступного
буфера, що визначає максимально досяжну пропускну
здатність.
Другий графік показує відсоток часу, витраченого на
очікування, за останні 100 секунд. Очікується, що
найповільніший диск спричинить більшу частину часу
очікування, тоді як інші диски повинні мати невеликий
час очікування або зовсім його не мати, оскільки
вони можуть використовувати свої буферизовані смуги.
Цей графік також показує час, витрачений на очікування
обчислення хешу та обчислень RAID.
Усі обчислення виконуються паралельно з операціями
диска. Тому, доки є вимірюваний час очікування
принаймні для одного диска, це вказує на те, що ЦП
достатньо швидкий, щоб справлятися з робочим навантаженням.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-Z, --force-zero
</div><div class="manual-option-description">
Форсує небезпечну операцію синхронізації файлу з
нульовим розміром, який раніше був ненульовим.
Якщо SnapRAID виявляє таку умову, він припиняє
продовження, якщо ви не вкажете цю опцію.
Це дозволяє легко виявити, коли після збою системи
деякі доступні файли були обрізані.
Це можлива умова в Linux з файловими системами
ext3/ext4.
Цю опцію можна використовувати лише з `sync`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-E, --force-empty
</div><div class="manual-option-description">
Форсує небезпечну операцію синхронізації диска, на
якому відсутні всі оригінальні файли.
Якщо SnapRAID виявляє, що всі файли, які спочатку
були на диску, відсутні або перезаписані, він
припиняє продовження, якщо ви не вкажете цю опцію.
Це дозволяє легко виявити, коли файлова система
даних не змонтована.
Цю опцію можна використовувати лише з `sync`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-U, --force-uuid
</div><div class="manual-option-description">
Форсує небезпечну операцію синхронізації, перевірки
та виправлення з дисками, які змінили свій UUID.
Якщо SnapRAID виявляє, що деякі диски змінили UUID,
він припиняє продовження, якщо ви не вкажете цю опцію.
Це дозволяє виявити, коли ваші диски змонтовані
в неправильних точках монтування.
Однак, дозволено мати одну зміну UUID з однією парністю
і більше з множинною парністю, оскільки це нормальний
випадок при заміні дисків після відновлення.
Цю опцію можна використовувати лише з `sync`, `check`
або `fix`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-D, --force-device
</div><div class="manual-option-description">
Форсує небезпечну операцію виправлення з недоступними
дисками або з дисками на тому ж фізичному пристрої.
Наприклад, якщо ви втратили два диски даних і маєте
запасний диск для відновлення лише першого, ви можете
ігнорувати другий недоступний диск.
Або, якщо ви хочете відновити диск у вільному місці,
залишеному на вже використовуваному диску, що
використовує той самий фізичний пристрій.
Цю опцію можна використовувати лише з `fix`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-N, --force-nocopy
</div><div class="manual-option-description">
У `sync`, `check` та `fix` вимикає евристику
виявлення копій. Без цієї опції SnapRAID припускає,
що файли з однаковими атрибутами, такими як ім'я,
розмір та часова мітка, є копіями з тими ж даними.
Це дозволяє ідентифікувати скопійовані або
переміщені файли з одного диска на інший і повторно
використовує вже обчислену інформацію хешу для
виявлення прихованих помилок або для відновлення
відсутніх файлів.
У деяких рідкісних випадках ця поведінка може
призвести до хибних спрацьовувань або повільного
процесу через багато перевірок хешу, і ця опція
дозволяє вирішити такі проблеми.
Цю опцію можна використовувати лише з `sync`, `check`
та `fix`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-F, --force-full
</div><div class="manual-option-description">
У `sync` форсує повне переобчислення парності.
Цю опцію можна використовувати, коли ви додаєте
новий рівень парності або якщо ви повернулися до
старого файлу вмісту, використовуючи більш
нові дані парності.
Замість створення парності з нуля, це дозволяє
повторно використовувати хеші, присутні у файлі
вмісту, для перевірки даних та підтримки захисту
даних під час процесу `sync`, використовуючи
існуючі дані парності.
Цю опцію можна використовувати лише з `sync`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-R, --force-realloc
</div><div class="manual-option-description">
У `sync` форсує повне перерозподілення файлів
та перебудову парності.
Цю опцію можна використовувати для повного
перерозподілу всіх файлів, усуваючи фрагментацію,
повторно використовуючи хеші, присутні у файлі
вмісту, для перевірки даних.
Цю опцію можна використовувати лише з `sync`.
УВАГА! Ця опція лише для експертів, і
настійно не рекомендується її використовувати.
Ви НЕ маєте захисту даних під час операції `sync`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-l, --log FILE
</div><div class="manual-option-description">
Записує детальний журнал у вказаний файл.
Якщо ця опція не вказана, несподівані помилки
виводяться на екран, що потенційно призводить до
надмірного виведення у випадку багатьох помилок.
Коли вказано -l, --log, на екран виводяться лише
фатальні помилки, які спричиняють зупинку SnapRAID.
Якщо шлях починається з '&gt;&gt;', файл відкривається
у режимі доповнення. Входження '%D' та '%T' в
імені замінюються датою та часом у форматі YYYYMMDD
та HHMMSS. У пакетних файлах Windows ви повинні
подвоїти символ '%', наприклад, result-%%D.log.
Щоб використовувати '&gt;&gt;', ви повинні взяти ім'я
в лапки, наприклад, `"&gt;&gt;result.log"`.
Щоб вивести журнал на стандартний вивід або
стандартну помилку, ви можете використовувати
`"&gt;&amp;1"` та `"&gt;&amp;2"` відповідно.
Дивіться файл snapraid_log.txt або man-сторінку
для описів тегів журналу.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-L, --error-limit NUMBER
</div><div class="manual-option-description">
Встановлює новий ліміт помилок перед зупинкою
виконання. За замовчуванням SnapRAID зупиняється,
якщо зустрічає більше 100 помилок введення/виведення,
що вказує на ймовірну відмову диска.
Ця опція впливає на `sync` та `scrub`, яким
дозволено продовжувати після першого набору
помилок диска, щоб спробувати завершити
свої операції. Однак `check` та `fix` завжди
зупиняються при першій помилці.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-S, --start BLKSTART
</div><div class="manual-option-description">
Починає обробку з вказаного номера блоку.
Це може бути корисно для повторної спроби
перевірки або виправлення певних блоків у
випадку пошкодженого диска.
Ця опція в основному для розширеного ручного
відновлення.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-B, --count BLKCOUNT
</div><div class="manual-option-description">
Обробляє лише вказану кількість блоків.
Ця опція в основному для розширеного ручного
відновлення.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-C, --gen-conf CONTENT
</div><div class="manual-option-description">
Генерує фіктивний конфігураційний файл з існуючого
файлу вмісту.
Конфігураційний файл записується на стандартний
вивід і не перезаписує існуючий.
Цей конфігураційний файл також містить інформацію,
необхідну для реконструкції точок монтування диска
у випадку втрати всієї системи.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-v, --verbose
</div><div class="manual-option-description">
Виводить більше інформації на екран.
Якщо вказано один раз, виводить виключені файли
та додаткову статистику.
Ця опція не впливає на файли журналу.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-q, --quiet
</div><div class="manual-option-description">
Виводить менше інформації на екран.
Якщо вказано один раз, видаляє індикатор прогресу;
двічі — поточні операції; тричі — інформаційні
повідомлення; чотири рази — повідомлення про
статус. Фатальні помилки завжди виводяться на
екран. Ця опція не впливає на файли журналу.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-H, --help
</div><div class="manual-option-description">
Виводить короткий довідковий екран.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-V, --version
</div><div class="manual-option-description">
Виводить версію програми.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
</div>
<div class="manual-section-level-1">
<h1 id="sec7" class="manual-title-level-1">
Конфігурація
</h1>
<p>SnapRAID вимагає конфігураційний файл, щоб знати, де
розташований ваш дисковий масив і де зберігати інформацію
парності.
</p><p>В Unix використовується файл `/usr/local/etc/snapraid.conf`,
якщо він існує, інакше `/etc/snapraid.conf`.
У Windows використовується файл `snapraid.conf` у тому
самому каталозі, що й `snapraid.exe`.
</p><p>Він повинен містити наступні опції (чутливі до регістру):
</p><div class="manual-section-level-2">
<h2 id="sec7-1" class="manual-title-level-2">
parity FILE [,FILE] ...
</h2>
<p>Визначає файли, які потрібно використовувати для зберігання
інформації парності. Парність забезпечує захист від
відмови одного диска, подібно до RAID5.
</p><p>Ви можете вказати кілька файлів, які повинні бути на
різних дисках. Коли файл більше не може зростати,
використовується наступний.
Загальний доступний простір повинен бути принаймні
таким же великим, як найбільший диск даних у масиві.
</p><p>Ви можете додати додаткові файли парності пізніше,
але ви не можете їх переупорядковувати або видаляти.
</p><p>Збереження дисків парності зарезервованими для парності
забезпечує, що вони не стають фрагментованими, покращуючи
продуктивність.
</p><p>У Windows 256 МБ залишається невикористаними на кожному
диску, щоб уникнути попередження про повні диски.
</p><p>Ця опція є обов'язковою і може бути використана лише один раз.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-2" class="manual-title-level-2">
(2,3,4,5,6)-parity FILE [,FILE] ...
</h2>
<p>Визначає файли, які потрібно використовувати для зберігання
додаткової інформації парності.
</p><p>Для кожного вказаного рівня парності вмикається один
додатковий рівень захисту:
</p><ul>
<li>
2-parity вмикає подвійну парність RAID6.
</li>
<li>
3-parity вмикає потрійну парність.
</li>
<li>
4-parity вмикає четверну парність.
</li>
<li>
5-parity вмикає п'ятерну парність.
</li>
<li>
6-parity вмикає шестерну парність.
</li>
</ul>
<p>Кожен рівень парності вимагає наявності всіх попередніх
рівнів парності.
</p><p>Застосовуються ті самі міркування, що й для опції 'parity'.
</p><p>Ці опції є необов'язковими і можуть бути використані лише
один раз.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-3" class="manual-title-level-2">
z-parity FILE [,FILE] ...
</h2>
<p>Визначає альтернативний файл та формат для зберігання
потрійної парності.
</p><p>Ця опція є альтернативою '3-parity', в першу чергу
призначена для ЦП низького класу, таких як ARM або
AMD Phenom, Athlon та Opteron, які не підтримують
набір інструкцій SSSE3. У таких випадках вона
забезпечує кращу продуктивність.
</p><p>Цей формат схожий, але швидший, ніж той, що використовується
ZFS RAIDZ3. Як і ZFS, він не працює далі потрійної парності.
</p><p>При використанні '3-parity' ви будете попереджені,
якщо рекомендується використовувати формат 'z-parity'
для покращення продуктивності.
</p><p>Можна конвертувати з одного формату в інший, налаштувавши
конфігураційний файл з бажаним файлом z-parity або
3-parity та використовуючи 'fix' для його відтворення.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-4" class="manual-title-level-2">
content FILE
</h2>
<p>Визначає файл, який потрібно використовувати для зберігання
списку та контрольних сум усіх файлів, присутніх у
вашому дисковому масиві.
</p><p>Він може бути розміщений на диску, що використовується для
даних, парності або будь-якому іншому доступному диску.
Якщо ви використовуєте диск даних, цей файл автоматично
виключається з процесу `sync`.
</p><p>Ця опція є обов'язковою і може бути використана кілька
разів для збереження кількох копій одного і того ж
файлу.
</p><p>Ви повинні зберігати принаймні одну копію для кожного
використаного диска парності плюс одну. Використання
додаткових копій не зашкодить.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-5" class="manual-title-level-2">
data NAME DIR
</h2>
<p>Визначає ім'я та точку монтування дисків даних у
масиві. NAME використовується для ідентифікації диска
і має бути унікальним. DIR — це точка монтування
диска у файловій системі.
</p><p>Ви можете змінювати точку монтування за потреби,
поки ви зберігаєте NAME фіксованим.
</p><p>Ви повинні використовувати одну опцію для кожного
диска даних у масиві.
</p><p>Ви можете перейменувати диск пізніше, змінивши NAME
безпосередньо у конфігураційному файлі, а потім
запустивши команду 'sync'. У випадку перейменування
асоціація здійснюється за допомогою збереженого
UUID дисків.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-6" class="manual-title-level-2">
nohidden
</h2>
<p>Виключає всі приховані файли та каталоги.
В Unix приховані файли — це ті, що починаються з `.`.
У Windows це ті, що мають прихований атрибут.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-7" class="manual-title-level-2">
exclude/include PATTERN
</h2>
<p>Визначає шаблони файлів або каталогів для виключення
або включення у процес синхронізації.
Усі шаблони обробляються у вказаному порядку.
</p><p>Якщо перший шаблон, який збігається, є `exclude` (виключити),
файл виключається. Якщо він є `include` (включити),
файл включається.
Якщо жоден шаблон не збігається, файл виключається,
якщо останній вказаний шаблон є `include`, або
включається, якщо останній вказаний шаблон є `exclude`.
</p><p>Дивіться розділ PATTERN для отримання додаткової
інформації про специфікації шаблонів.
</p><p>Цю опцію можна використовувати кілька разів.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-8" class="manual-title-level-2">
blocksize SIZE_IN_KIBIBYTES
</h2>
<p>Визначає основний розмір блоку в кібібайтах для парності.
Один кібібайт дорівнює 1024 байтам.
</p><p>Розмір блоку за замовчуванням становить 256, що має
працювати для більшості випадків.
</p><p>УВАГА! Ця опція лише для експертів, і настійно
не рекомендується змінювати це значення. Щоб змінити
це значення в майбутньому, вам потрібно буде
перестворити всю парність!
</p><p>Причина використовувати інший розмір блоку полягає
в тому, якщо у вас є багато невеликих файлів, порядку
мільйонів.
</p><p>Для кожного файлу, навіть якщо це лише кілька байтів,
виділяється цілий блок парності, і з багатьма файлами
це може призвести до значного невикористаного місця
парності. Коли ви повністю заповнюєте диск парності,
вам не дозволяється додавати більше файлів на диски
даних. Однак, витрачена парність не накопичується
між дисками даних. Витрачене місце внаслідок великої
кількості файлів на диску даних обмежує лише кількість
даних на цьому диску даних, а не на інших.
</p><p>Як наближення, ви можете припустити, що половина
розміру блоку витрачається для кожного файлу.
Наприклад, зі 100 000 файлами та розміром блоку 256 КіБ
ви витратите 12,8 ГБ парності, що може призвести до
того, що на диску даних буде на 12,8 ГБ менше місця.
</p><p>Ви можете перевірити кількість витраченого місця на
кожному диску за допомогою `status`. Це кількість
місця, яку ви повинні залишити вільною на дисках даних
або використовувати для файлів, не включених у масив.
Якщо це значення від'ємне, це означає, що ви
наближаєтеся до заповнення парності, і воно
представляє місце, яке ви ще можете витратити.
</p><p>Щоб уникнути цієї проблеми, ви можете використовувати
більший розділ для парності. Наприклад, якщо розділ
парності на 12,8 ГБ більший за диски даних, у вас є
достатньо додаткового місця для обробки до 100 000
файлів на кожному диску даних без будь-якого
витраченого місця.
</p><p>Хитрість, щоб отримати більший розділ парності в
Linux, полягає в тому, щоб відформатувати його
командою:
</p><pre>
mkfs.ext4 -m 0 -T largefile4 DEVICE
</pre>
<p>Це призводить до приблизно 1,5% додаткового місця,
приблизно 60 ГБ для диска 4 ТБ, що дозволяє
приблизно 460 000 файлів на кожному диску даних
без будь-якого витраченого місця.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-9" class="manual-title-level-2">
hashsize SIZE_IN_BYTES
</h2>
<p>Визначає розмір хешу в байтах для збережених блоків.
</p><p>Розмір хешу за замовчуванням становить 16 байтів
(128 біт), що має працювати для більшості випадків.
</p><p>УВАГА! Ця опція лише для експертів, і настійно
не рекомендується змінювати це значення. Щоб змінити
це значення в майбутньому, вам потрібно буде
перестворити всю парність!
</p><p>Причина використовувати інший розмір хешу полягає
в тому, якщо ваша система має обмежену пам'ять.
Як правило, SnapRAID зазвичай вимагає 1 ГіБ ОЗП
на кожні 16 ТБ даних у масиві.
</p><p>Зокрема, для зберігання хешів даних SnapRAID
вимагає приблизно $TS \times (1+HS) / BS$ байтів
ОЗП, де TS — загальний розмір вашого дискового масиву
у байтах, BS — розмір блоку у байтах, а HS —
розмір хешу у байтах.
</p><p>Наприклад, з 8 дисками по 4 ТБ, розміром блоку 256 КіБ
(1 КіБ = 1024 байта) та розміром хешу 16, ви отримуєте:
</p><pre>
RAM = $(8 \times 4 \times 10^{12}) \times (1+16) / (256 \times 2^{10}) = 1.93$ ГіБ
</pre>
<p>Перехід до розміру хешу 8, ви отримуєте:
</p><pre>
RAM = $(8 \times 4 \times 10^{12}) \times (1+8) / (256 \times 2^{10}) = 1.02$ ГіБ
</pre>
<p>Перехід до розміру блоку 512, ви отримуєте:
</p><pre>
RAM = $(8 \times 4 \times 10^{12}) \times (1+16) / (512 \times 2^{10}) = 0.96$ ГіБ
</pre>
<p>Перехід до розміру хешу 8 та розміру блоку 512, ви отримуєте:
</p><pre>
RAM = $(8 \times 4 \times 10^{12}) \times (1+8) / (512 \times 2^{10}) = 0.51$ ГіБ
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-10" class="manual-title-level-2">
autosave SIZE_IN_GIGABYTES
</h2>
<p>Автоматично зберігає стан під час синхронізації або
скрабування після обробки вказаної кількості ГБ.
Ця опція корисна, щоб уникнути перезапуску довгих
команд `sync` з нуля, якщо вони були перервані
збоєм машини або будь-якою іншою подією.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-11" class="manual-title-level-2">
temp_limit TEMPERATURE_CELSIUS
</h2>
<p>Встановлює максимальну дозволену температуру диска
в Цельсіях. Якщо вказано, SnapRAID періодично перевіряє
температуру всіх дисків за допомогою інструменту
smartctl. Поточні температури дисків відображаються
під час роботи SnapRAID. Якщо будь-який диск перевищує
цей ліміт, усі операції зупиняються, і диски
зупиняються (переходять у режим очікування) на час,
визначений опцією `temp_sleep`. Після періоду
очікування операції відновлюються, потенційно
знову призупиняючись, якщо ліміт температури знову
досягнутий.
</p><p>Під час роботи SnapRAID також аналізує криву
нагрівання кожного диска та оцінює довгострокову
стабільну температуру, якої вони, як очікується,
досягнуть, якщо активність продовжиться.
Оцінка виконується лише після того, як температура
диска підвищилася чотири рази, що гарантує наявність
достатньої кількості даних для встановлення
надійного тренду. Ця прогнозована стабільна
температура відображається в дужках поруч із
поточним значенням і допомагає оцінити, чи
достатнє охолодження системи. Ця оцінювана
температура є лише інформаційною і не впливає на
поведінку SnapRAID. Дії програми базуються
виключно на фактично виміряних температурах
дисків.
</p><p>Для виконання цього аналізу SnapRAID потрібна
довідкова інформація про температуру системи.
Спочатку він намагається зчитати її з доступних
апаратних датчиків. Якщо до системного датчика
неможливо отримати доступ, він використовує
найнижчу температуру диска, виміряну на початку
запуску, як резервну довідкову інформацію.
</p><p>Зазвичай SnapRAID показує лише температуру
найгарячішого диска. Щоб відобразити температуру
всіх дисків, використовуйте опцію -A або --stats.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-12" class="manual-title-level-2">
temp_sleep TIME_IN_MINUTES
</h2>
<p>Встановлює час очікування, у хвилинах, коли
досягнуто ліміту температури. Протягом цього
періоду диски залишаються зупиненими.
За замовчуванням 5 хвилин.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-13" class="manual-title-level-2">
pool DIR
</h2>
<p>Визначає каталог об'єднання, де створюється
віртуальне представлення дискового масиву за
допомогою команди `pool`.
</p><p>Каталог повинен вже існувати.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-14" class="manual-title-level-2">
share UNC_DIR
</h2>
<p>Визначає шлях Windows UNC, необхідний для
віддаленого доступу до дисків.
</p><p>Якщо ця опція вказана, символічні посилання,
створені в каталозі pool, використовують цей
шлях UNC для доступу до дисків.
Без цієї опції згенеровані символічні посилання
використовують лише локальні шляхи, що не
дозволяє спільно використовувати каталог pool
через мережу.
</p><p>Символічні посилання формуються за допомогою
вказаного шляху UNC, додаючи ім'я диска, як
зазначено в опції `data`, і, нарешті,
додаючи каталог та ім'я файлу.
</p><p>Ця опція потрібна лише для Windows.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-15" class="manual-title-level-2">
smartctl DISK/PARITY OPTIONS...
</h2>
<p>Визначає користувацькі опції smartctl для
отримання атрибутів SMART для кожного диска.
Це може знадобитися для RAID-контролерів та
деяких USB-дисків, які не можуть бути
автоматично виявлені. Заповнювач %s
замінюється іменем пристрою, але він
необов'язковий для фіксованих пристроїв,
таких як RAID-контролери.
</p><p>DISK — це те саме ім'я диска, вказане в опції `data`.
PARITY — це одне з імен парності: `parity`,
`2-parity`, `3-parity`, `4-parity`, `5-parity`,
`6-parity` або `z-parity`.
</p><p>У вказаних OPTIONS рядок `%s` замінюється
іменем пристрою. Для RAID-контролерів пристрій
ймовірно фіксований, і вам може не знадобитися
використовувати `%s`.
</p><p>Зверніться до документації smartmontools
для можливих опцій:
</p><pre>
https://www.smartmontools.org/wiki/Supported_RAID-Controllers
https://www.smartmontools.org/wiki/Supported_USB-Devices
</pre>
<p>Наприклад:
</p><pre>
smartctl parity -d sat %s
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-16" class="manual-title-level-2">
smartignore DISK/PARITY ATTR [ATTR...]
</h2>
<p>Ігнорує вказаний атрибут SMART при обчисленні
ймовірності відмови диска. Ця опція корисна,
якщо диск повідомляє незвичайні або
оманливі значення для певного атрибута.
</p><p>DISK — це те саме ім'я диска, вказане в опції `data`.
PARITY — це одне з імен парності: `parity`,
`2-parity`, `3-parity`, `4-parity`, `5-parity`,
`6-parity` або `z-parity`.
Спеціальне значення * можна використовувати
для ігнорування атрибута на всіх дисках.
</p><p>Наприклад, щоб ігнорувати атрибут `Current Pending Sector Count`
на всіх дисках:
</p><pre>
smartignore * 197
</pre>
<p>Щоб ігнорувати його лише на першому диску парності:
</p><pre>
smartignore parity 197
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-17" class="manual-title-level-2">
Приклади
</h2>
<p>Приклад типової конфігурації для Unix:
</p><pre>
parity /mnt/diskp/snapraid.parity
content /mnt/diskp/snapraid.content
content /var/snapraid/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
exclude /lost+found/
exclude /tmp/
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/sg0
smartctl 2-parity -d areca,2/1 /dev/sg0
</pre>
<p>Приклад типової конфігурації для Windows:
</p><pre>
parity E:\snapraid.parity
content E:\snapraid.content
content C:\snapraid\snapraid.content
data d1 G:\array\
data d2 H:\array\
data d3 I:\array\
exclude Thumbs.db
exclude \$RECYCLE.BIN
exclude \System Volume Information
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/arcmsr0
smartctl 2-parity -d areca,2/1 /dev/arcmsr0
</pre>
</div>
</div>
<div class="manual-section-level-1">
<h1 id="sec8" class="manual-title-level-1">
Шаблон (Pattern)
</h1>
<p>Шаблони забезпечують гнучкий спосіб фільтрації файлів для включення або
виключення. Використовуючи символи підстановки (globbing), ви можете визначити правила, які
відповідають конкретним іменам файлів або цілим структурам каталогів без
ручного перерахування кожного шляху.
</p><p>Знак питання `?` відповідає будь-якому одному символу, крім роздільника
каталогів. Це робить його корисним для зіставлення імен файлів із змінними
символами, при цьому шаблон обмежується одним рівнем каталогу.
</p><p>Одинарна зірочка `*` відповідає будь-якій послідовності символів, але, як і
знак питання, вона ніколи не перетинає межі каталогів. Вона зупиняється на
прямій косій рисці, що робить її придатною для зіставлення всередині одного
компонента шляху. Це стандартна поведінка підстановочних знаків, знайома
з командної оболонки (shell globbing).
</p><p>Подвійна зірочка `**` є потужнішою, вона відповідає будь-якій послідовності
символів, включаючи роздільники каталогів. Це дозволяє шаблонам відповідати
кільком рівням каталогів. Коли `**` з'являється безпосередньо в шаблоні,
вона може відповідати нулю або більше символам, включаючи косі риски між
оточуючим літеральним текстом.
</p><p>Найважливішим використанням `**` є спеціальна форма `/**/`. Вона відповідає
нулю або більше повним рівням каталогів, що дозволяє зіставляти файли
на будь-якій глибині в дереві каталогів, не знаючи точної структури шляху.
Наприклад, шаблон `src/**/main.js` відповідає `src/main.js` (пропуск
нуля каталогів), `src/ui/main.js` (пропуск одного каталогу) та
`src/ui/components/main.js` (пропуск двох каталогів).
</p><p>Класи символів із використанням квадратних дужок `[]` відповідають одному символу з
визначеного набору або діапазону. Як і інші односимвольні шаблони, вони
не відповідають роздільникам каталогів. Класи підтримують діапазони та заперечення за допомогою
знаку оклику.
</p><p>Фундаментальна відмінність, яку слід пам'ятати, полягає в тому, що `*`, `?` та класи символів
усі дотримуються меж каталогів і відповідають лише в межах одного компонента
шляху, тоді як `**` — єдиний шаблон, який може відповідати через роздільники
каталогів.
</p><p>Існує чотири різні типи шаблонів:
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
FILE
</div><div class="manual-option-description">
Вибирає будь-який файл з ім'ям FILE.
Цей шаблон застосовується тільки до файлів, а не до директорій.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
DIR/
</div><div class="manual-option-description">
Вибирає будь-яку директорію з ім'ям DIR і все, що знаходиться всередині.
Цей шаблон застосовується тільки до директорій, а не до файлів.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/FILE
</div><div class="manual-option-description">
Вибирає точно вказаний шлях до файлу. Цей шаблон застосовується
тільки до файлів, а не до директорій.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/DIR/
</div><div class="manual-option-description">
Вибирає точно вказаний шлях до директорії і все, що знаходиться
всередині. Цей шаблон застосовується тільки до директорій, а не до файлів.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>Коли ви вказуєте абсолютний шлях, що починається
з /, він застосовується до кореневого каталогу
масиву, а не до кореневого каталогу локальної
файлової системи.
</p><p>У Windows ви можете використовувати зворотну
скісну риску \ замість прямої скісної риски /.
Системні каталоги Windows, з'єднання, точки
монтування та інші спеціальні каталоги Windows
розглядаються як файли, що означає, що для
їх виключення ви повинні використовувати правило
файлу, а не правило каталогу.
</p><p>Якщо ім'я файлу містить символи '*', '?', '[',
або ']', ви повинні екранувати їх, щоб уникнути
їх інтерпретації як символу глоббінгу.
В Unix символом екранування є '\'; у Windows — '^'.
Коли шаблон знаходиться в командному рядку,
ви повинні подвоїти символ екранування, щоб
запобігти його інтерпретації командною оболонкою.
</p><p>У конфігураційному файлі ви можете використовувати
різні стратегії для фільтрації файлів, які потрібно
обробити.
Найпростіший підхід — використовувати лише
правила `exclude` для видалення всіх файлів та
каталогів, які ви не хочете обробляти.
Наприклад:
</p><pre>
# Виключає будь-який файл з іменем `*.unrecoverable`
exclude *.unrecoverable
# Виключає кореневий каталог `/lost+found`
exclude /lost+found/
# Виключає будь-який підкаталог з іменем `tmp`
exclude tmp/
</pre>
<p>Протилежний підхід — визначити лише файли,
які ви хочете обробити, використовуючи лише
правила `include`. Наприклад:
</p><pre>
# Включає лише деякі каталоги
include /movies/
include /musics/
include /pictures/
</pre>
<p>Останній підхід — змішувати правила `exclude`
та `include`. У цьому випадку порядок правил
важливий. Раніші правила мають пріоритет
над пізнішими.
Для спрощення ви можете спочатку перерахувати
всі правила `exclude`, а потім усі правила `include`.
Наприклад:
</p><pre>
# Виключає будь-який файл з іменем `*.unrecoverable`
exclude *.unrecoverable
# Виключає будь-який підкаталог з іменем `tmp`
exclude tmp/
# Включає лише деякі каталоги
include /movies/
include /musics/
include /pictures/
</pre>
<p>У командному рядку, використовуючи опцію -f,
ви можете використовувати лише шаблони `include`.
Наприклад:
</p><pre>
# Перевіряє лише файли .mp3.
# В Unix використовуйте лапки, щоб уникнути
# розширення глоббінгу оболонкою.
snapraid -f "*.mp3" check
</pre>
<p>В Unix, при використанні символів глоббінгу в
командному рядку, ви повинні взяти їх у лапки,
щоб запобігти їх розширенню оболонкою.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec9" class="manual-title-level-1">
Ігнорування файлів (Ignore File)
</h1>
<p>На додаток до глобальних правил у файлі конфігурації, ви можете розміщувати
файли `.snapraidignore` в будь-якому каталозі всередині масиву для визначення
децентралізованих правил виключення.
</p><p>Правила, визначені в `.snapraidignore`, застосовуються після правил у файлі
конфігурації. Це означає, що вони мають вищий пріоритет і можуть бути використані
для виключення файлів, які раніше були включені глобальною конфігурацією.
Фактично, якщо локальне правило збігається, файл виключається незалежно від
глобальних налаштувань включення.
</p><p>Логіка шаблонів у `.snapraidignore` повторює глобальну конфігурацію, але
прив'язує шаблони до каталогу, в якому знаходиться файл:
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
FILE
</div><div class="manual-option-description">
Вибирає будь-який файл із ім'ям FILE у цьому каталозі або нижче.
Це відповідає тим самим правилам підстановки, що і в глобальному шаблоні.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
DIR/
</div><div class="manual-option-description">
Вибирає будь-який каталог із ім'ям DIR та весь його вміст, що
знаходиться в цьому каталозі або нижче.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/FILE
</div><div class="manual-option-description">
Вибирає точно вказаний файл відносно розташування
файлу `.snapraidignore`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/DIR/
</div><div class="manual-option-description">
Вибирає точно вказаний каталог та весь його вміст відносно
розташування файлу `.snapraidignore`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>На відміну від глобальної конфігурації, файли `.snapraidignore` підтримують
лише правила виключення; ви не можете використовувати шаблони `include` або заперечення (!).
</p><p>Наприклад, якщо у вас є `.snapraidignore` у `/mnt/disk1/projects/`:
</p><pre>
# Виключає ТІЛЬКИ /mnt/disk1/projects/output.bin
/output.bin
# Виключає будь-який каталог із назвою 'build' всередині projects/
build/
# Виключає будь-який .tmp файл всередині projects/ або його підпапок
*.tmp
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec10" class="manual-title-level-1">
Вміст (Content)
</h1>
<p>SnapRAID зберігає список та контрольні суми
ваших файлів у файлі вмісту.
</p><p>Це бінарний файл, який перераховує всі файли,
присутні у вашому дисковому масиві, разом з
усіма контрольними сумами для перевірки їх
цілісності.
</p><p>Цей файл зчитується та записується командами
`sync` та `scrub` та зчитується командами `fix`,
`check` та `status`.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec11" class="manual-title-level-1">
Парність (Parity)
</h1>
<p>SnapRAID зберігає інформацію парності вашого
масиву у файлах парності.
</p><p>Це бінарні файли, що містять обчислену
парність усіх блоків, визначених у файлі
`content`.
</p><p>Ці файли зчитуються та записуються командами
`sync` та `fix` і лише зчитуються командами
`scrub` та `check`.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec12" class="manual-title-level-1">
Кодування (Encoding)
</h1>
<p>SnapRAID в Unix ігнорує будь-яке кодування.
Він зчитує та зберігає імена файлів з
тим самим кодуванням, що використовується
файловою системою.
</p><p>У Windows усі імена, зчитані з файлової
системи, конвертуються та обробляються
у форматі UTF-8.
</p><p>Щоб імена файлів відображалися правильно,
ви повинні встановити консоль Windows
у режим UTF-8 за допомогою команди
`chcp 65001` та використовувати шрифт
TrueType, такий як `Lucida Console`, як
шрифт консолі.
Це впливає лише на надруковані імена
файлів; якщо ви перенаправляєте вивід
консолі у файл, отриманий файл завжди
буде у форматі UTF-8.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec13" class="manual-title-level-1">
Авторське право (Copyright)
</h1>
<p>Цей файл захищений авторським правом (C) 2025 Andrea Mazzoleni
</p></div>
<div class="manual-section-level-1">
<h1 id="sec14" class="manual-title-level-1">
Див. також (See Also)
</h1>
<p>snapraid_log(1), snapraidd(1)
</p></div>


            </div>
        </main>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container footer-content">
            <div class="footer-col">
                <h3>SnapRAID</h3>
                <p>Copyright &copy; 2026 Andrea Mazzoleni</p>
                <p class="license">Distributed under GPL v3 License</p>
            </div>
            <div class="footer-col">
                <h4>Community</h4>
                <ul>
                    <li><a href="https://www.reddit.com/r/Snapraid/">Reddit r/snapraid</a></li>
                    <li><a href="https://sourceforge.net/p/snapraid/discussion/1677233/">SourceForge Forum</a></li>
                    <li><a href="https://github.com/amadvance/snapraid/">GitHub</a></li>
                </ul>
            </div>
        </div>
    </footer>
</body>
</html>


