<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A backup program for disk arrays. It stores parity information of your data and it recovers from up to six disk failures">
    <meta name="keywords" content="snapraid snapshot raid backup disk array redundancy parity">    
    <title>SnapRAID Manual</title>
    <style>html,body{background-color:#020617;color:#f8fafc;}</style>
    <link rel="stylesheet" href="style.css">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">    
    <script src="script.js"></script>

<!-- Google Analytics 4 -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W1Z5FKHYQ4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-W1Z5FKHYQ4');
</script>

<!-- Google Universal Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body>
    <header>
        <div class="container nav-container">
            <a href="index" class="logo">
                <img src="favicon-32x32.png"/>
                SnapRAID
            </a>
            <nav>
                <input type="checkbox" id="menu-toggle">
                <label for="menu-toggle" class="menu-icon"><svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></label>
                <ul>
                    <li><a href="index" >Home</a></li>
                    <li><a href="ui" >UI & Daemon</a></li>
                    <li><a href="howitworks" >How it Works</a></li>
                    <li><a href="manual" class="active">Manual</a></li>
                    <li><a href="compare" >Compare</a></li>
                    <li><a href="design" >Design</a></li>
                    <li><a href="faq" >FAQ</a></li>
                    <li><a href="support" >Support</a></li>
                    <li><a href="download" class="nav-cta">Download</a></li>
                </ul>
            </nav>
        </div>
    </header>


    <div class="container manual-layout">
        <aside class="manual-sidebar">
            <h4>Languages</h4>
            <select id="language-selector" style="width: 100%; padding: 5px; background: var(--bg-surface); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; margin-bottom: 2rem;">
                <option value="manualHTML%">English</option>
                <option value="manual-de">German</option>
                <option value="manual-es">Spanish</option>
                <option value="manual-fr">French</option>
                <option value="manual-it">Italian</option>
                <option value="manual-ja">Japanse</option>
                <option value="manual-ko">Korean</option>
                <option value="manual-pl">Polish</option>
                <option value="manual-pt">Portuguese</option>
                <option value="manual-ro">Romanian</option>
                <option value="manual-ru">Russian</option>
                <option value="manual-sv">Swedish</option>
                <option value="manual-uk">Ukranian</option>
                <option value="manual-zh">Simplified Chinese</option>.

            </select>

            <h4>Contents</h4>
            <ul id="manual-toc-list">
                <!-- Populated by JavaScript -->
            </ul>
        </aside>

        <main id="manual-container">
            
            <div class="manual-doc">

<div class="manual-section-level-1">
<h1 id="sec1" class="manual-title-level-1">
Synopsis
</h1>
<pre>
snapraid [-c, --conf CONFIG]
&nbsp;&nbsp;&nbsp;&nbsp;[-f, --filter PATTERN] [-d, --filter-disk NAME]
&nbsp;&nbsp;&nbsp;&nbsp;[-m, --filter-missing] [-e, --filter-error]
&nbsp;&nbsp;&nbsp;&nbsp;[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR]
&nbsp;&nbsp;&nbsp;&nbsp;[-p, --plan PERC|bad|new|full]
&nbsp;&nbsp;&nbsp;&nbsp;[-o, --older-than DAYS] [-l, --log FILE]
&nbsp;&nbsp;&nbsp;&nbsp;[-s, --spin-down-on-error] [-w, --bw-limit RATE]
&nbsp;&nbsp;&nbsp;&nbsp;[-Z, --force-zero] [-E, --force-empty]
&nbsp;&nbsp;&nbsp;&nbsp;[-U, --force-uuid] [-D, --force-device]
&nbsp;&nbsp;&nbsp;&nbsp;[-N, --force-nocopy] [-F, --force-full]
&nbsp;&nbsp;&nbsp;&nbsp;[-R, --force-realloc]
&nbsp;&nbsp;&nbsp;&nbsp;[-S, --start BLKSTART] [-B, --count BLKCOUNT]
&nbsp;&nbsp;&nbsp;&nbsp;[-L, --error-limit NUMBER]
&nbsp;&nbsp;&nbsp;&nbsp;[-A, --stats]
&nbsp;&nbsp;&nbsp;&nbsp;[-v, --verbose] [-q, --quiet]
&nbsp;&nbsp;&nbsp;&nbsp;status|smart|probe|up|down|diff|sync|scrub|fix|check
&nbsp;&nbsp;&nbsp;&nbsp;|list|dup|pool|devices|touch|rehash
</pre>
<pre>
snapraid [-V, --version] [-H, --help] [-C, --gen-conf CONTENT]
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec2" class="manual-title-level-1">
Beskrivning
</h1>
<p>SnapRAID är ett säkerhetskopieringsprogram designat för disk-arrayer,
som lagrar paritetsinformation för dataåterställning vid upp till sex
diskfel.
</p><p>SnapRAID är i första hand avsett för hemmamediabibliotek med stora,
sällan ändrade filer, och erbjuder flera funktioner:
</p><ul>
<li>
Du kan använda diskar som redan är fyllda med filer utan
att behöva formatera om dem, och du får åtkomst till dem som vanligt.
</li>
<li>
All din data hashberäknas för att säkerställa dataintegritet och
förhindra tyst korruption.
</li>
<li>
När antalet felaktiga diskar överskrider paritetsantalet,
begränsas dataförlusten till de drabbade diskarna; data på
andra diskar förblir åtkomlig.
</li>
<li>
Om du oavsiktligt raderar filer på en disk är återställning
möjlig.
</li>
<li>
Diskar kan ha olika storlekar.
</li>
<li>
Du kan lägga till diskar när som helst.
</li>
<li>
SnapRAID låser inte in din data; du kan sluta använda det
när som helst utan omformatering eller dataflytt.
</li>
<li>
För att få åtkomst till en fil behöver endast en enda disk snurra,
vilket sparar ström och minskar buller.
</li>
</ul>
<p>För mer information, besök den officiella SnapRAID-webbplatsen:
</p><pre>
https://www.snapraid.it/
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec3" class="manual-title-level-1">
Begränsningar
</h1>
<p>SnapRAID är en hybrid mellan ett RAID- och ett säkerhetskopieringsprogram,
som syftar till att kombinera de bästa fördelarna med båda. Den har dock
vissa begränsningar som du bör överväga innan du använder den.
</p><p>Huvudbegränsningen är att om en disk misslyckas och du inte nyligen har
synkat, kanske du inte kan återställa fullständigt.
Mer specifikt, kanske du inte kan återställa upp till storleken på
de ändrade eller raderade filerna sedan den senaste synkroniseringsoperationen.
Detta inträffar även om de ändrade eller raderade filerna inte finns på
den felaktiga disken. Det är därför SnapRAID passar bättre för
data som sällan ändras.
</p><p>Å andra sidan förhindrar nyligen tillagda filer inte återställning av redan
befintliga filer. Du kommer bara att förlora de nyligen tillagda filerna om de
finns på den felaktiga disken.
</p><p>Andra SnapRAID-begränsningar är:
</p><ul>
<li>
Med SnapRAID har du fortfarande separata filsystem för varje disk.
Med RAID får du ett enda stort filsystem.
</li>
<li>
SnapRAID stripas inte data.
Med RAID får du en hastighetsökning med striping.
</li>
<li>
SnapRAID stöder inte återställning i realtid.
Med RAID behöver du inte sluta arbeta när en disk misslyckas.
</li>
<li>
SnapRAID kan bara återställa data från ett begränsat antal diskfel.
Med en säkerhetskopia kan du återställa från ett fullständigt
fel på hela disk-arrayen.
</li>
<li>
Endast filnamn, tidsstämplar, symboliska länkar och hårda länkar sparas.
Behörigheter, ägarskap och utökade attribut sparas inte.
</li>
</ul>
</div>
<div class="manual-section-level-1">
<h1 id="sec4" class="manual-title-level-1">
Kom igång
</h1>
<p>För att använda SnapRAID måste du först välja en disk i din disk-array
som ska dediceras till `parity`-information. Med en disk för paritet,
kommer du att kunna återställa från ett enda diskfel, liknande RAID5.
</p><p>Om du vill återställa från fler diskfel, liknande RAID6,
måste du reservera ytterligare diskar för paritet. Varje ytterligare
paritetsdisk möjliggör återställning från ett diskfel till.
</p><p>Som paritetsdiskar måste du välja de största diskarna i arrayen,
eftersom paritetsinformationen kan växa till storleken av den största
datadisken i arrayen.
</p><p>Dessa diskar kommer att dediceras till att lagra `parity`-filerna.
Du bör inte lagra din data på dem.
</p><p>Sedan måste du definiera de `data`-diskar som du vill skydda
med SnapRAID. Skyddet är mer effektivt om dessa diskar
innehåller data som sällan ändras. Av denna anledning är det bäst att
INTE inkludera Windows C:\-disken eller Unix /home, /var och /tmp
katalogerna.
</p><p>Listan över filer sparas i `content`-filerna, som vanligtvis
lagras på data-, paritets- eller startdiskarna.
Denna fil innehåller detaljerna för din säkerhetskopia, inklusive alla
checksummor för att verifiera dess integritet.
`content`-filen lagras i flera kopior, och varje kopia måste
finnas på en annan disk för att säkerställa att, även vid flera
diskfel, minst en kopia är tillgänglig.
</p><p>Anta till exempel att du bara är intresserad av en paritetsnivå
av skydd, och dina diskar finns på:
</p><pre>
/mnt/diskp &lt;- vald disk för paritet
/mnt/disk1 &lt;- första disken att skydda
/mnt/disk2 &lt;- andra disken att skydda
/mnt/disk3 &lt;- tredje disken att skydda
</pre>
<p>Du måste skapa konfigurationsfilen /etc/snapraid.conf med
följande alternativ:
</p><pre>
parity /mnt/diskp/snapraid.parity
content /var/snapraid/snapraid.content
content /mnt/disk1/snapraid.content
content /mnt/disk2/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
</pre>
<p>Om du använder Windows bör du använda Windows sökvägsformat, med
enhetsbeteckningar och omvända snedstreck istället för snedstreck.
</p><pre>
parity E:\snapraid.parity
content C:\snapraid\snapraid.content
content F:\array\snapraid.content
content G:\array\snapraid.content
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
</pre>
<p>Om du har många diskar och får slut på enhetsbeteckningar kan du montera
diskar direkt i undermappar. Se:
</p><pre>
https://www.google.com/search?q=Windows+mount+point
</pre>
<p>Vid denna punkt är du redo att köra kommandot `sync` för att bygga
paritetsinformationen.
</p><pre>
snapraid sync
</pre>
<p>Denna process kan ta flera timmar första gången, beroende på storleken
på datan som redan finns på diskarna. Om diskarna är tomma är
processen omedelbar.
</p><p>Du kan stoppa det när som helst genom att trycka Ctrl+C, och vid nästa körning
återupptas det där det avbröts.
</p><p>När detta kommando är klart är din data SÄKER.
</p><p>Nu kan du börja använda din array som du vill och periodiskt
uppdatera paritetsinformationen genom att köra kommandot `sync`.
</p><div class="manual-section-level-2">
<h2 id="sec4-1" class="manual-title-level-2">
Skrubbning (Scrubbing)
</h2>
<p>För att periodiskt kontrollera data och paritet för fel kan du
köra kommandot `scrub`.
</p><pre>
snapraid scrub
</pre>
<p>Detta kommando jämför data i din array med den hash som beräknades
under kommandot `sync` för att verifiera integriteten.
</p><p>Varje körning av kommandot kontrollerar ungefär 8% av arrayen, exklusive data
som redan skrubbats under de föregående 10 dagarna.
Du kan använda alternativet -p, --plan för att specificera en annan mängd
och alternativet -o, --older-than för att specificera en annan ålder i dagar.
Till exempel, för att kontrollera 5% av arrayen för block äldre än 20 dagar, använd:
</p><pre>
snapraid -p 5 -o 20 scrub
</pre>
<p>Om tysta eller input/output-fel hittas under processen,
markeras de motsvarande blocken som dåliga i `content`-filen
och listas i kommandot `status`.
</p><pre>
snapraid status
</pre>
<p>För att fixa dem kan du använda kommandot `fix`, filtrera efter dåliga block med
alternativet -e, --filter-error:
</p><pre>
snapraid -e fix
</pre>
<p>Vid nästa `scrub` kommer felen att försvinna från `status`-rapporten
om de verkligen är fixade. För att göra det snabbare kan du använda -p bad för att skrubba
endast block markerade som dåliga.
</p><pre>
snapraid -p bad scrub
</pre>
<p>Att köra `scrub` på en osynkad array kan rapportera fel orsakade av
borttagna eller modifierade filer. Dessa fel rapporteras i `scrub`-
utdata, men de relaterade blocken markeras inte som dåliga.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec4-2" class="manual-title-level-2">
Poolning
</h2>
<p>Obs: Poolningsfunktionen som beskrivs nedan har ersatts av verktyget
mergefs, som nu är det rekommenderade alternativet för Linux-användare i
SnapRAID-communityt. Mergefs ger ett mer flexibelt och effektivt
sätt att poola flera enheter till en enda enhetlig monteringspunkt,
vilket möjliggör sömlös åtkomst till filer över din array utan att förlita sig
på symboliska länkar. Det integreras väl med SnapRAID för paritetsskydd
och används ofta i installationer som OpenMediaVault (OMV)
eller anpassade NAS-konfigurationer.
</p><p>För att visa alla filer i din array i samma katalogträd,
kan du aktivera funktionen `pooling`. Den skapar en skrivskyddad virtuell
vy av alla filer i din array med hjälp av symboliska länkar.
</p><p>Du kan konfigurera `pooling`-katalogen i konfigurationsfilen med:
</p><pre>
pool /pool
</pre>
<p>eller, om du använder Windows, med:
</p><pre>
pool C:\pool
</pre>
<p>och kör sedan kommandot `pool` för att skapa eller uppdatera den virtuella vyn.
</p><pre>
snapraid pool
</pre>
<p>Om du använder en Unix-plattform och vill dela denna katalog
över nätverket till antingen Windows- eller Unix-maskiner, bör du lägga till
följande alternativ till din /etc/samba/smb.conf:
</p><pre>
# I den globala sektionen av smb.conf
unix extensions = no
</pre>
<pre>
# I delningssektionen av smb.conf
[pool]
comment = Pool
path = /pool
read only = yes
guest ok = yes
wide links = yes
follow symlinks = yes
</pre>
<p>I Windows kräver delning av symboliska länkar över ett nätverk att klienter
löser dem på distans. För att aktivera detta måste du, förutom att dela pool-katalogen,
även dela alla diskar oberoende, med hjälp av de disk-namn
som definieras i konfigurationsfilen som delningspunkter. Du måste också specificera
i alternativet `share` i konfigurationsfilen den Windows UNC-sökväg som
fjärrklienter behöver använda för att få åtkomst till dessa delade diskar.
</p><p>Till exempel, om du arbetar från en server som heter `darkstar`, kan du använda
alternativen:
</p><pre>
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
pool C:\pool
share \\darkstar
</pre>
<p>och dela följande kataloger över nätverket:
</p><pre>
\\darkstar\pool -&gt; C:\pool
\\darkstar\d1 -&gt; F:\array
\\darkstar\d2 -&gt; G:\array
\\darkstar\d3 -&gt; H:\array
</pre>
<p>för att tillåta fjärrklienter att få åtkomst till alla filer på \\darkstar\pool.
</p><p>Du kan också behöva konfigurera fjärrklienter för att möjliggöra åtkomst till
fjärrsymboliska länkar med kommandot:
</p><pre>
fsutil behavior set SymlinkEvaluation L2L:1 R2R:1 L2R:1 R2L:1
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec4-3" class="manual-title-level-2">
Ångra radering (Undeleting)
</h2>
<p>SnapRAID fungerar mer som ett säkerhetskopieringsprogram än ett RAID-system, och det
kan användas för att återställa eller ångra radering av filer till deras tidigare tillstånd
med hjälp av alternativet -f, --filter:
</p><pre>
snapraid fix -f FIL
</pre>
<p>eller för en katalog:
</p><pre>
snapraid fix -f KATALOG/
</pre>
<p>Du kan också använda det för att återställa endast oavsiktligt raderade filer inuti
en katalog med hjälp av alternativet -m, --filter-missing, som återställer
endast saknade filer, och lämnar alla andra orörda.
</p><pre>
snapraid fix -m -f KATALOG/
</pre>
<p>Eller för att återställa alla raderade filer på alla enheter med:
</p><pre>
snapraid fix -m
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec4-4" class="manual-title-level-2">
Återställning
</h2>
<p>Det värsta har hänt, och du har förlorat en eller flera diskar!
</p><p>FÅ INTE PANIK! Du kommer att kunna återställa dem!
</p><p>Det första du måste göra är att undvika ytterligare ändringar i din disk-array.
Inaktivera alla fjärranslutningar till den och alla schemalagda processer, inklusive
alla schemalagda SnapRAID nattliga sync- eller scrub-körningar.
</p><p>Fortsätt sedan med följande steg.
</p><div class="manual-section-level-3">
<h3 id="sec4-4-1" class="manual-title-level-3">
STEG 1 -&gt; Omkonfigurera
</h3>
<p>Du behöver lite utrymme för att återställa, helst på ytterligare
reservdiskar, men en extern USB-disk eller fjärrdisk räcker.
</p><p>Ändra SnapRAID-konfigurationsfilen för att få alternativet `data` eller `parity`
för den felaktiga disken att peka på en plats med tillräckligt tomt
utrymme för att återställa filerna.
</p><p>Om till exempel disk `d1` har misslyckats, ändra från:
</p><pre>
data d1 /mnt/disk1/
</pre>
<p>till:
</p><pre>
data d1 /mnt/new_spare_disk/
</pre>
<p>Om disken som ska återställas är en paritetsdisk, uppdatera det lämpliga `parity`-
alternativet.
Om du har flera felaktiga diskar, uppdatera alla deras konfigurationsalternativ.
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-2" class="manual-title-level-3">
STEG 2 -&gt; Fixa
</h3>
<p>Kör kommandot fix och lagra loggen i en extern fil med:
</p><pre>
snapraid -d NAMN -l fix.log fix
</pre>
<p>Där NAMN är namnet på disken, till exempel `d1` i vårt tidigare exempel.
Om disken som ska återställas är en paritetsdisk, använd namnen `parity`, `2-parity`,
etc.
Om du har flera felaktiga diskar, använd flera -d-alternativ för att specificera alla
av dem.
</p><p>Detta kommando kommer att ta lång tid.
</p><p>Se till att du har några gigabyte ledigt för att lagra fix.log-filen.
Kör den från en disk med tillräckligt med ledigt utrymme.
</p><p>Nu har du återställt allt som är återställningsbart. Om vissa filer är delvis
eller helt icke-återställningsbara, kommer de att döpas om genom att lägga till tillägget
`.unrecoverable`.
</p><p>Du kan hitta en detaljerad lista över alla icke-återställningsbara block i fix.log-filen
genom att kontrollera alla rader som börjar med `unrecoverable:`.
</p><p>Om du inte är nöjd med återställningen kan du försöka igen hur många
gånger du vill.
</p><p>Om du till exempel har tagit bort filer från arrayen efter den senaste
`sync`, kan detta leda till att vissa filer inte återställs.
I detta fall kan du försöka igen `fix` med alternativet -i, --import,
specificera var dessa filer nu finns för att inkludera dem igen i
återställningsprocessen.
</p><p>Om du är nöjd med återställningen kan du fortsätta,
men notera att efter synkronisering kan du inte försöka igen kommandot `fix`
längre!
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-3" class="manual-title-level-3">
STEG 3 -&gt; Kontrollera
</h3>
<p>Som en försiktighetsåtgärd kan du nu köra ett `check`-kommando för att säkerställa att
allt är korrekt på den återställda disken.
</p><pre>
snapraid -d NAMN -a check
</pre>
<p>Där NAMN är namnet på disken, till exempel `d1` i vårt tidigare exempel.
</p><p>Alternativen -d och -a talar om för SnapRAID att endast kontrollera den specificerade disken
och ignorera all paritetsdata.
</p><p>Detta kommando kommer att ta lång tid, men om du inte är alltför försiktig,
kan du hoppa över det.
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-4" class="manual-title-level-3">
STEG 4 -&gt; Synkronisera
</h3>
<p>Kör kommandot `sync` för att synkronisera arrayen igen med den nya disken.
</p><pre>
snapraid sync
</pre>
<p>Om allt är återställt är detta kommando omedelbart.
</p></div>
</div>
</div>
<div class="manual-section-level-1">
<h1 id="sec5" class="manual-title-level-1">
Kommandon
</h1>
<p>SnapRAID tillhandahåller några enkla kommandon som låter dig:
</p><ul>
<li>
Skriva ut statusen för arrayen -&gt; `status`
</li>
<li>
Kontrollera diskarna -&gt; `smart`, `probe`, `up`, `down`
</li>
<li>
Göra en säkerhetskopia/ögonblicksbild -&gt; `sync`
</li>
<li>
Periodiskt kontrollera data -&gt; `scrub`
</li>
<li>
Återställa den senaste säkerhetskopian/ögonblicksbilden -&gt; `fix`.
</li>
</ul>
<p>Kommandon måste skrivas med gemener.
</p><div class="manual-section-level-2">
<h2 id="sec5-1" class="manual-title-level-2">
status
</h2>
<p>Skriver ut en sammanfattning av tillståndet för disk-arrayen.
</p><p>Det inkluderar information om paritetsfragmentering, hur gamla
blocken är utan kontroll, och alla registrerade tysta
fel som påträffats under skrubbning.
</p><p>Informationen som presenteras hänvisar till den senaste tidpunkten du
körde `sync`. Senare modifieringar beaktas inte.
</p><p>Om dåliga block upptäcktes, listas deras blocknummer.
För att fixa dem kan du använda kommandot `fix -e`.
</p><p>Det visar också ett diagram som representerar den senaste tidpunkten då varje block
skrubbades eller synkroniserades. Skrubbade block visas med '*',
block synkroniserade men ännu inte skrubbade med 'o'.
</p><p>Inget ändras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-2" class="manual-title-level-2">
smart
</h2>
<p>Skriver ut en SMART-rapport över alla diskar i systemet.
</p><p>Det inkluderar en uppskattning av sannolikheten för fel under det kommande
året, vilket gör att du kan planera underhållsersättningar av diskar som visar
misstänkta attribut.
</p><p>Denna sannolikhetsuppskattning erhålls genom att korrelera SMART-attributen
för diskarna med Backblaze-data som finns tillgänglig på:
</p><pre>
https://www.backblaze.com/hard-drive-test-data.html
</pre>
<p>Om SMART rapporterar att en disk håller på att misslyckas, skrivs `FAIL` eller `PREFAIL` ut
för den disken, och SnapRAID returnerar med ett fel.
I detta fall rekommenderas omedelbar ersättning av disken starkt.
</p><p>Andra möjliga statussträngar är:
</p><div class="manual-tag-list">
<div class="manual-tag-entry">
<div class="manual-tag-name">
logfail
</div><div class="manual-tag-description">
Tidigare var vissa attribut lägre än
tröskelvärdet.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
logerr
</div><div class="manual-tag-description">
Enhetens fellogg innehåller fel.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
selferr
</div><div class="manual-tag-description">
Enhetens självtestlogg innehåller fel.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>Om alternativet -v, --verbose specificeras, tillhandahålls en djupare statistisk analys.
Denna analys kan hjälpa dig att bestämma om du behöver mer
eller mindre paritet.
</p><p>Detta kommando använder verktyget `smartctl` och är ekvivalent med att köra
`smartctl -a` på alla enheter.
</p><p>Om dina enheter inte upptäcks automatiskt korrekt kan du specificera
ett anpassat kommando med hjälp av alternativet `smartctl` i konfigurations-
filen.
</p><p>Inget ändras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-3" class="manual-title-level-2">
probe
</h2>
<p>Skriver ut STRÖM-tillståndet för alla diskar i systemet.
</p><p>`Standby` betyder att disken inte snurrar. `Active` betyder
att disken snurrar.
</p><p>Detta kommando använder verktyget `smartctl` och är ekvivalent med att köra
`smartctl -n standby -i` på alla enheter.
</p><p>Om dina enheter inte upptäcks automatiskt korrekt kan du specificera
ett anpassat kommando med hjälp av alternativet `smartctl` i konfigurations-
filen.
</p><p>Inget ändras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-4" class="manual-title-level-2">
up
</h2>
<p>Snurrar upp alla diskar i arrayen.
</p><p>Du kan snurra upp endast specifika diskar med hjälp av alternativet -d, --filter-disk.
</p><p>Att snurra upp alla diskar samtidigt kräver mycket ström.
Se till att din strömförsörjning kan klara det.
</p><p>Inget ändras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-5" class="manual-title-level-2">
down
</h2>
<p>Snurrar ner alla diskar i arrayen.
</p><p>Detta kommando använder verktyget `smartctl` och är ekvivalent med att köra
`smartctl -s standby,now` på alla enheter.
</p><p>Du kan snurra ner endast specifika diskar med hjälp av alternativet -d, --filter-disk
alternativet.
</p><p>För att automatiskt snurra ner vid fel kan du använda alternativet -s, --spin-down-on-error
med alla andra kommandon, vilket är ekvivalent med att köra `down` manuellt
när ett fel inträffar.
</p><p>Inget ändras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-6" class="manual-title-level-2">
diff
</h2>
<p>Listar alla filer som modifierats sedan den senaste `sync` och som behöver få
sin paritetsdata omberäknad.
</p><p>Detta kommando kontrollerar inte filens data, utan endast filens tidsstämpel,
storlek och inode.
</p><p>Efter att ha listat alla ändrade filer presenteras en sammanfattning av ändringarna,
grupperade efter:
</p><div class="manual-tag-list">
<div class="manual-tag-entry">
<div class="manual-tag-name">
equal
</div><div class="manual-tag-description">
Filer oförändrade från tidigare.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
added
</div><div class="manual-tag-description">
Filer tillagda som inte fanns tidigare.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
removed
</div><div class="manual-tag-description">
Filer borttagna.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
updated
</div><div class="manual-tag-description">
Filer med en annan storlek eller tidsstämpel, vilket innebär att de
modifierades.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
moved
</div><div class="manual-tag-description">
Filer flyttade till en annan katalog på samma disk.
De identifieras genom att ha samma namn, storlek, tidsstämpel
och inode, men en annan katalog.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
copied
</div><div class="manual-tag-description">
Filer kopierade på samma eller en annan disk. Observera att om
de verkligen flyttas till en annan disk, kommer de också att
räknas i `removed`.
De identifieras genom att ha samma namn, storlek och
tidsstämpel. Om undertidsstämpeln är noll,
måste hela sökvägen matcha, inte bara namnet.
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
restored
</div><div class="manual-tag-description">
Filer med en annan inode men matchande namn, storlek och tidsstämpel.
Dessa är vanligtvis filer som återställts efter att ha raderats.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>Om en `sync` krävs är processens returkod 2, istället för standard 0.
Returkoden 1 används för ett generiskt feltillstånd.
</p><p>Inget ändras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-7" class="manual-title-level-2">
sync
</h2>
<p>Uppdaterar paritetsinformationen. Alla modifierade filer
i disk-arrayen läses, och motsvarande paritets-
data uppdateras.
</p><p>Du kan stoppa denna process när som helst genom att trycka Ctrl+C,
utan att förlora det arbete som redan utförts.
Vid nästa körning kommer `sync`-processen att återupptas där
den avbröts.
</p><p>Om tysta eller input/output-fel hittas under processen,
markeras de motsvarande blocken som dåliga.
</p><p>Filer identifieras med sökväg och/eller inode och kontrolleras med
storlek och tidsstämpel.
Om filstorleken eller tidsstämpeln skiljer sig åt, beräknas paritetsdata
om för hela filen.
Om filen flyttas eller döps om på samma disk, samtidigt som
samma inode behålls, beräknas inte pariteten om.
Om filen flyttas till en annan disk, beräknas pariteten om,
men den tidigare beräknade hash-informationen behålls.
</p><p>`content`- och `parity`-filerna modifieras vid behov.
Filerna i arrayen modifieras INTE.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-8" class="manual-title-level-2">
scrub
</h2>
<p>Skrubbar arrayen och söker efter tysta eller input/output-fel i data-
och paritetsdiskar.
</p><p>Varje anrop kontrollerar ungefär 8% av arrayen, exklusive
data som redan skrubbats under de senaste 10 dagarna.
Detta innebär att skrubbning en gång i veckan säkerställer att varje bit data kontrolleras
minst en gång var tredje månad.
</p><p>Du kan definiera en annan skrubbplan eller mängd med hjälp av alternativet -p, --plan
som accepterar:
bad - Skrubbar block markerade som dåliga.
new - Skrubbar nyligen synkroniserade block som ännu inte skrubbats.
full - Skrubbar allt.
0-100 - Skrubbar den specificerade procentandelen av block.
</p><p>Om du specificerar en procentsats kan du också använda alternativet -o, --older-than
för att definiera hur gammalt blocket ska vara.
De äldsta blocken skrubbas först, vilket säkerställer en optimal kontroll.
Om du bara vill skrubba de nyligen synkroniserade blocken som ännu inte skrubbats,
använd alternativet `-p new`.
</p><p>För att få detaljer om skrubbstatusen, använd kommandot `status`.
</p><p>För alla tysta eller input/output-fel som hittas, markeras de motsvarande blocken
som dåliga i `content`-filen.
Dessa dåliga block listas i `status` och kan fixas med `fix -e`.
Efter fixningen, vid nästa skrubb, kommer de att kontrolleras igen, och om de befinns
korrigerade, tas det dåliga märket bort.
För att skrubba endast de dåliga blocken kan du använda kommandot `scrub -p bad`.
</p><p>Det rekommenderas att köra `scrub` endast på en synkroniserad array för att undvika
rapporterade fel orsakade av osynkad data. Dessa fel känns igen
som att de inte är tysta fel, och blocken markeras inte som dåliga,
men sådana fel rapporteras i kommandots utdata.
</p><p>`content`-filen modifieras för att uppdatera tiden för den senaste kontrollen
för varje block och för att markera dåliga block.
`parity`-filerna modifieras INTE.
Filerna i arrayen modifieras INTE.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-9" class="manual-title-level-2">
fix
</h2>
<p>Fixar alla filer och paritetsdata.
</p><p>Alla filer och paritetsdata jämförs med ögonblicksbilds-
tillståndet som sparades i den senaste `sync`.
Om en skillnad hittas, återställs den till det lagrade ögonblicksbildstillståndet.
</p><p>VARNING! Kommandot `fix` skiljer inte mellan fel och
avsiktliga modifieringar. Det återställer ovillkorligen filtillståndet
till den senaste `sync`.
</p><p>Om inget annat alternativ specificeras, behandlas hela arrayen.
Använd filteralternativen för att välja en delmängd av filer eller diskar att arbeta med.
</p><p>För att fixa endast blocken markerade som dåliga under `sync` och `scrub`,
använd alternativet -e, --filter-error.
Till skillnad från andra filteralternativ tillämpar detta fixar endast på filer som är
oförändrade sedan den senaste `sync`.
</p><p>SnapRAID döper om alla filer som inte kan fixas genom att lägga till tillägget
`.unrecoverable`.
</p><p>Innan fixningen skannas hela arrayen för att hitta alla filer som flyttats
sedan den senaste `sync`-operationen.
Dessa filer identifieras av deras tidsstämpel, ignorera deras namn
och katalog, och används i återställningsprocessen vid behov.
Om du flyttade några av dem utanför arrayen kan du använda alternativet -i, --import
för att specificera ytterligare kataloger att skanna.
</p><p>Filer identifieras endast med sökväg, inte med inode.
</p><p>`content`-filen modifieras INTE.
`parity`-filerna modifieras vid behov.
Filerna i arrayen modifieras vid behov.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-10" class="manual-title-level-2">
check
</h2>
<p>Verifierar alla filer och paritetsdata.
</p><p>Det fungerar som `fix`, men det simulerar endast en återställning och inga ändringar
skrivs till arrayen.
</p><p>Detta kommando är i första hand avsett för manuell verifiering,
som efter en återställningsprocess eller under andra speciella förhållanden.
För periodiska och schemalagda kontroller, använd `scrub`.
</p><p>Om du använder alternativet -a, --audit-only, kontrolleras endast fil-
datan, och paritetsdatan ignoreras för en
snabbare körning.
</p><p>Filer identifieras endast med sökväg, inte med inode.
</p><p>Inget ändras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-11" class="manual-title-level-2">
list
</h2>
<p>Listar alla filer som finns i arrayen vid tidpunkten för den
senaste `sync`.
</p><p>Med -v eller --verbose visas även undertiden.
</p><p>Inget ändras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-12" class="manual-title-level-2">
dup
</h2>
<p>Listar alla dubblettfiler. Två filer antas vara lika om deras
hashar matchar. Filens data läses inte; endast de
förberäknade hasharna används.
</p><p>Inget ändras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-13" class="manual-title-level-2">
pool
</h2>
<p>Skapar eller uppdaterar en virtuell vy av alla
filer i din disk-array i `pooling`-katalogen.
</p><p>Filerna kopieras inte utan länkas med hjälp av
symboliska länkar.
</p><p>Vid uppdatering raderas alla befintliga symboliska länkar och tomma
underkataloger och ersätts med den nya
vyn av arrayen. Alla andra vanliga filer lämnas kvar.
</p><p>Inget ändras utanför pool-katalogen.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-14" class="manual-title-level-2">
devices
</h2>
<p>Skriver ut de lågnivåenheter som används av arrayen.
</p><p>Detta kommando visar enhetsassociationerna i arrayen
och är främst avsett som ett skriptgränssnitt.
</p><p>De två första kolumnerna är lågnivåenhetens ID och sökväg.
De nästa två kolumnerna är högnivåenhetens ID och sökväg.
Den sista kolumnen är diskens namn i arrayen.
</p><p>I de flesta fall har du en lågnivåenhet för varje disk i
arrayen, men i vissa mer komplexa konfigurationer kan du ha flera
lågnivåenheter som används av en enda disk i arrayen.
</p><p>Inget ändras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-15" class="manual-title-level-2">
touch
</h2>
<p>Anger en godtycklig undertidsstämpel för alla filer
som har den satt till noll.
</p><p>Detta förbättrar SnapRAIDs förmåga att känna igen flyttade
och kopierade filer, eftersom det gör tidsstämpeln nästan unik,
vilket minskar möjliga dubbletter.
</p><p>Mer specifikt, om undertidsstämpeln inte är noll,
identifieras en flyttad eller kopierad fil som sådan om den matchar
namn, storlek och tidsstämpel. Om undertidsstämpeln
är noll, betraktas den som en kopia endast om hela sökvägen,
storlek och tidsstämpel alla matchar.
</p><p>Tidsstämpeln med sekundprecision modifieras inte,
så alla datum och tider för dina filer bevaras.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-16" class="manual-title-level-2">
rehash
</h2>
<p>Schemalägger en omhashning av hela arrayen.
</p><p>Detta kommando ändrar den hash-typ som används, vanligtvis vid uppgradering
från ett 32-bitars system till ett 64-bitars system, för att byta från
MurmurHash3 till den snabbare SpookyHash.
</p><p>Om du redan använder den optimala hashen, gör detta kommando
ingenting och informerar dig om att ingen åtgärd behövs.
</p><p>Omhashningen utförs inte omedelbart utan sker
progressivt under `sync` och `scrub`.
</p><p>Du kan kontrollera omhashningstillståndet med hjälp av `status`.
</p><p>Under omhashningen bibehåller SnapRAID full funktionalitet,
med det enda undantaget att `dup` inte kan upptäcka dubbletter
med hjälp av en annan hash.
</p></div>
</div>
<div class="manual-section-level-1">
<h1 id="sec6" class="manual-title-level-1">
Alternativ
</h1>
<p>SnapRAID tillhandahåller följande alternativ:
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-c, --conf CONFIG
</div><div class="manual-option-description">
Väljer den konfigurationsfil som ska användas. Om den inte specificeras, i Unix
används filen `/usr/local/etc/snapraid.conf` om den finns,
annars `/etc/snapraid.conf`.
I Windows används filen `snapraid.conf` i samma
katalog som `snapraid.exe`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-f, --filter PATTERN
</div><div class="manual-option-description">
Filtrerar filerna att behandla i `check` och `fix`.
Endast filerna som matchar det specificerade mönstret behandlas.
Detta alternativ kan användas flera gånger.
Se avsnittet MÖNSTER för mer information om
mönsterspecifikationer.
I Unix, se till att globbing-tecken citeras om de används.
Detta alternativ kan endast användas med `check` och `fix`.
Det kan inte användas med `sync` och `scrub`, eftersom de alltid
behandlar hela arrayen.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-d, --filter-disk NAME
</div><div class="manual-option-description">
Filtrerar diskarna att behandla i `check`, `fix`, `up` och `down`.
Du måste specificera ett disk-namn som definieras i konfigurations-
filen.
Du kan också specificera paritetsdiskar med namnen: `parity`, `2-parity`,
`3-parity`, etc., för att begränsa operationer till en specifik paritetsdisk.
Om du kombinerar flera --filter, --filter-disk och --filter-missing alternativ,
väljs endast filer som matchar alla filter.
Detta alternativ kan användas flera gånger.
Detta alternativ kan endast användas med `check`, `fix`, `up` och `down`.
Det kan inte användas med `sync` och `scrub`, eftersom de alltid
behandlar hela arrayen.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-m, --filter-missing
</div><div class="manual-option-description">
Filtrerar filerna att behandla i `check` och `fix`.
Endast filerna som saknas eller har raderats från arrayen behandlas.
När det används med `fix`, fungerar detta som ett `undelete`-kommando.
Om du kombinerar flera --filter, --filter-disk och --filter-missing alternativ,
väljs endast filer som matchar alla filter.
Detta alternativ kan endast användas med `check` och `fix`.
Det kan inte användas med `sync` och `scrub`, eftersom de alltid
behandlar hela arrayen.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-e, --filter-error
</div><div class="manual-option-description">
Behandlar filerna med fel i `check` och `fix`.
Det behandlar endast filer som har block markerade med tysta
eller input/output-fel under `sync` och `scrub`, som listas i `status`.
Detta alternativ kan endast användas med `check` och `fix`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-p, --plan PERC|bad|new|full
</div><div class="manual-option-description">
Väljer skrubbplanen. Om PERC är ett numeriskt värde från 0 till 100,
tolkas det som procentandelen av block som ska skrubbas.
Istället för en procentsats kan du specificera en plan:
`bad` skrubbar dåliga block, `new` skrubbar block som ännu inte skrubbats,
och `full` skrubbar allt.
Detta alternativ kan endast användas med `scrub`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-o, --older-than DAYS
</div><div class="manual-option-description">
Väljer den äldsta delen av arrayen att behandla i `scrub`.
DAYS är den minsta åldern i dagar för ett block att skrubbas;
standard är 10.
Block markerade som dåliga skrubbas alltid oavsett detta alternativ.
Detta alternativ kan endast användas med `scrub`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-a, --audit-only
</div><div class="manual-option-description">
I `check`, verifierar hashen av filerna utan
att kontrollera paritetsdata.
Om du bara är intresserad av att kontrollera filens data, kan detta
alternativ avsevärt påskynda kontrollprocessen.
Detta alternativ kan endast användas med `check`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-h, --pre-hash
</div><div class="manual-option-description">
I `sync`, kör en preliminär hash-fas av all ny data
för ytterligare verifiering innan paritetsberäkningen.
Vanligtvis görs ingen preliminär hashning i `sync`, och den nya
datan hashberäknas precis innan paritetsberäkningen när den läses
för första gången.
Denna process sker när systemet är under
tung belastning, med alla diskar snurrande och en upptagen CPU.
Detta är ett extremt tillstånd för maskinen, och om den har ett
latent hårdvaruproblem, kan tysta fel gå obemärkt förbi
eftersom datan ännu inte har hashberäknats.
För att undvika denna risk kan du aktivera `pre-hash`-läget för att få
all data läst två gånger för att säkerställa dess integritet.
Detta alternativ verifierar också filer som flyttats inom arrayen
för att säkerställa att flyttoperationen lyckades och, om nödvändigt,
låter dig köra en fix-operation innan du fortsätter.
Detta alternativ kan endast användas med `sync`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-i, --import DIR
</div><div class="manual-option-description">
Importerar från den specificerade katalogen alla filer som raderats
från arrayen efter den senaste `sync`.
Om du fortfarande har sådana filer, kan de användas av `check`
och `fix` för att förbättra återställningsprocessen.
Filerna läses, inklusive i underkataloger, och identifieras
oavsett deras namn.
Detta alternativ kan endast användas med `check` och `fix`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-s, --spin-down-on-error
</div><div class="manual-option-description">
Vid något fel, snurrar ner alla hanterade diskar innan den avslutas med
en statuskod som inte är noll. Detta förhindrar att enheterna
förblir aktiva och snurrar efter en avbruten operation,
vilket hjälper till att undvika onödig värmeuppbyggnad och ström-
förbrukning. Använd detta alternativ för att säkerställa att diskar stoppas säkert
även när ett kommando misslyckas.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-w, --bw-limit RATE
</div><div class="manual-option-description">
Tillämpar en global bandbreddsbegränsning för alla diskar. RATE är
antalet byte per sekund. Du kan specificera en multiplikator
som K, M eller G (t.ex. --bw-limit 1G).
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-A, --stats
</div><div class="manual-option-description">
Aktiverar en utökad statusvy som visar ytterligare information.
Skärmen visar två diagram:
Det första diagrammet visar antalet buffrade strippar för varje
disk, tillsammans med filsökvägen för filen som för närvarande används
på den disken. Vanligtvis kommer den långsammaste disken att ha
ingen buffert tillgänglig, vilket bestämmer den maximalt uppnåeliga
bandbredden.
Det andra diagrammet visar procentandelen tid som spenderats i väntan
under de senaste 100 sekunderna. Den långsammaste disken förväntas
orsaka större delen av väntetiden, medan andra diskar bör ha
liten eller ingen väntetid eftersom de kan använda sina buffrade strippar.
Detta diagram visar också den tid som spenderats i väntan på hash-
beräkningar och RAID-beräkningar.
Alla beräkningar körs parallellt med diskoperationer.
Därför, så länge det finns mätbar väntetid för minst en disk,
indikerar det att CPU:n är snabb nog att
hålla jämna steg med arbetsbelastningen.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-Z, --force-zero
</div><div class="manual-option-description">
Tvingar den osäkra operationen att synkronisera en fil med noll
storlek som tidigare var icke-noll.
Om SnapRAID upptäcker ett sådant tillstånd, stoppar det att fortsätta
om du inte specificerar detta alternativ.
Detta gör att du enkelt kan upptäcka när, efter en systemkrasch,
vissa filer som användes trunkerades.
Detta är ett möjligt tillstånd i Linux med filsystemen ext3/ext4.
Detta alternativ kan endast användas med `sync`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-E, --force-empty
</div><div class="manual-option-description">
Tvingar den osäkra operationen att synkronisera en disk där alla
ursprungliga filer saknas.
Om SnapRAID upptäcker att alla filer som ursprungligen fanns
på disken saknas eller har skrivits om, stoppar det att fortsätta
om du inte specificerar detta alternativ.
Detta gör att du enkelt kan upptäcka när ett datafilsystem inte är
monterat.
Detta alternativ kan endast användas med `sync`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-U, --force-uuid
</div><div class="manual-option-description">
Tvingar den osäkra operationen att synkronisera, kontrollera och fixa
med diskar som har ändrat sin UUID.
Om SnapRAID upptäcker att vissa diskar har ändrat UUID,
stoppar det att fortsätta om du inte specificerar detta alternativ.
Detta gör att du kan upptäcka när dina diskar är monterade på fel
monteringspunkter.
Det är dock tillåtet att ha en enda UUID-ändring med
enkel paritet, och fler med multipel paritet, eftersom detta är
det normala fallet när man byter ut diskar efter en återställning.
Detta alternativ kan endast användas med `sync`, `check` eller
`fix`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-D, --force-device
</div><div class="manual-option-description">
Tvingar den osäkra operationen att fixa med otillgängliga diskar
eller med diskar på samma fysiska enhet.
Till exempel, om du förlorade två datadisker och har en reservdisk för att återställa
endast den första, kan du ignorera den andra otillgängliga disken.
Eller, om du vill återställa en disk i det lediga utrymme som finns kvar på en
redan använd disk, dela samma fysiska enhet.
Detta alternativ kan endast användas med `fix`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-N, --force-nocopy
</div><div class="manual-option-description">
I `sync`, `check` och `fix`, inaktiverar heuristiken för kopieringsdetektering.
Utan detta alternativ antar SnapRAID att filer med samma
attribut, såsom namn, storlek och tidsstämpel, är kopior med
samma data.
Detta möjliggör identifiering av kopierade eller flyttade filer från en disk
till en annan och återanvänder den redan beräknade hash-informationen
för att upptäcka tysta fel eller för att återställa saknade filer.
I vissa sällsynta fall kan detta beteende leda till falska positiva
eller en långsam process på grund av många hash-verifieringar, och detta
alternativ låter dig lösa sådana problem.
Detta alternativ kan endast användas med `sync`, `check` och `fix`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-F, --force-full
</div><div class="manual-option-description">
I `sync`, tvingar en fullständig omberäkning av pariteten.
Detta alternativ kan användas när du lägger till en ny paritetsnivå eller om
du återgick till en gammal content-fil med mer aktuell paritetsdata.
Istället för att återskapa pariteten från grunden låter detta dig
återanvända hasharna som finns i content-filen för att validera data
och bibehålla dataskyddet under `sync`-processen med hjälp av
den befintliga paritetsdatan.
Detta alternativ kan endast användas med `sync`.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-R, --force-realloc
</div><div class="manual-option-description">
I `sync`, tvingar en fullständig omallokering av filer och ombyggnad av pariteten.
Detta alternativ kan användas för att helt omallokera alla filer,
ta bort fragmentering, samtidigt som hasharna som finns i content-
filen återanvänds för att validera data.
Detta alternativ kan endast användas med `sync`.
VARNING! Detta alternativ är endast för experter, och det rekommenderas
starkt att inte använda det.
Du HAR INGET dataskydd under `sync`-operationen.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-l, --log FILE
</div><div class="manual-option-description">
Skriver en detaljerad logg till den specificerade filen.
Om detta alternativ inte specificeras, skrivs oväntade fel ut
på skärmen, vilket potentiellt kan leda till överdriven utdata i händelse av
många fel. När -l, --log specificeras, skrivs endast
fatala fel som får SnapRAID att stoppa ut
på skärmen.
Om sökvägen börjar med '&gt;&gt;', öppnas filen
i tilläggsläge. Förekomster av '%D' och '%T' i namnet ersätts
med datum och tid i formatet YYYYMMDD respektive
HHMMSS. I Windows batch-filer måste du dubblera
'%'-tecknet, t.ex. result-%%D.log. För att använda '&gt;&gt;' måste du
omsluta namnet i citattecken, t.ex. `"&gt;&gt;result.log"`.
För att skicka ut loggen till standardutdata eller standardfel,
kan du använda `"&gt;&amp;1"` respektive `"&gt;&amp;2"`.
Se filen snapraid_log.txt eller man-sidan för beskrivningar av logg-taggar.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-L, --error-limit NUMBER
</div><div class="manual-option-description">
Anger en ny felgräns innan körningen stoppas.
Som standard stoppar SnapRAID om det stöter på mer än 100
input/output-fel, vilket indikerar att en disk troligen håller på att misslyckas.
Detta alternativ påverkar `sync` och `scrub`, som tillåts
att fortsätta efter den första uppsättningen diskfel för att försöka
slutföra sina operationer.
Däremot stoppar `check` och `fix` alltid vid det första felet.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-S, --start BLKSTART
</div><div class="manual-option-description">
Börjar behandlingen från det specificerade
blocknumret. Detta kan vara användbart för att försöka igen att kontrollera
eller fixa specifika block i händelse av en skadad disk.
Detta alternativ är främst för avancerad manuell återställning.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-B, --count BLKCOUNT
</div><div class="manual-option-description">
Behandlar endast det specificerade antalet block.
Detta alternativ är främst för avancerad manuell återställning.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-C, --gen-conf CONTENT
</div><div class="manual-option-description">
Genererar en dummy-konfigurationsfil från en befintlig
content-fil.
Konfigurationsfilen skrivs till standardutdata
och skriver inte över en befintlig fil.
Denna konfigurationsfil innehåller också den information
som behövs för att rekonstruera diskmonteringspunkterna om du
förlorar hela systemet.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-v, --verbose
</div><div class="manual-option-description">
Skriver ut mer information på skärmen.
Om det specificeras en gång, skrivs exkluderade filer
och ytterligare statistik ut.
Detta alternativ har ingen effekt på loggfilerna.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-q, --quiet
</div><div class="manual-option-description">
Skriver ut mindre information på skärmen.
Om det specificeras en gång, tas förloppsindikatorn bort; två gånger,
de pågående operationerna; tre gånger, informations-
meddelandena; fyra gånger, statusmeddelandena.
Fatala fel skrivs alltid ut på skärmen.
Detta alternativ har ingen effekt på loggfilerna.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-H, --help
</div><div class="manual-option-description">
Skriver ut en kort hjälpskärm.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-V, --version
</div><div class="manual-option-description">
Skriver ut programversionen.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
</div>
<div class="manual-section-level-1">
<h1 id="sec7" class="manual-title-level-1">
Konfiguration
</h1>
<p>SnapRAID kräver en konfigurationsfil för att veta var din disk-array
finns och var paritetsinformationen ska lagras.
</p><p>I Unix används filen `/usr/local/etc/snapraid.conf` om den finns,
annars `/etc/snapraid.conf`.
I Windows används filen `snapraid.conf` i samma
katalog som `snapraid.exe`.
</p><p>Den måste innehålla följande alternativ (skiftlägeskänsligt):
</p><div class="manual-section-level-2">
<h2 id="sec7-1" class="manual-title-level-2">
parity FIL [,FIL] ...
</h2>
<p>Definierar de filer som ska användas för att lagra paritetsinformationen.
Pariteten möjliggör skydd från ett enda disk-
fel, liknande RAID5.
</p><p>Du kan specificera flera filer, som måste finnas på olika diskar.
När en fil inte kan växa mer, används nästa fil.
Det totala tillgängliga utrymmet måste vara minst lika stort som den största datadisken i
arrayen.
</p><p>Du kan lägga till ytterligare paritetsfiler senare, men du
kan inte ändra ordning på eller ta bort dem.
</p><p>Att hålla paritetsdiskarna reserverade för paritet säkerställer att
de inte blir fragmenterade, vilket förbättrar prestandan.
</p><p>I Windows lämnas 256 MB oanvänt på varje disk för att undvika
varningen om fulla diskar.
</p><p>Detta alternativ är obligatoriskt och kan endast användas en gång.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-2" class="manual-title-level-2">
(2,3,4,5,6)-parity FIL [,FIL] ...
</h2>
<p>Definierar de filer som ska användas för att lagra extra paritetsinformation.
</p><p>För varje paritetsnivå som specificeras aktiveras en ytterligare skyddsnivå:
</p><ul>
<li>
2-parity möjliggör RAID6 dubbel paritet.
</li>
<li>
3-parity möjliggör trippel paritet.
</li>
<li>
4-parity möjliggör fyrdubbel (fyra) paritet.
</li>
<li>
5-parity möjliggör penta (fem) paritet.
</li>
<li>
6-parity möjliggör hexa (sex) paritet.
</li>
</ul>
<p>Varje paritetsnivå kräver närvaro av alla föregående paritets-
nivåer.
</p><p>Samma överväganden som för alternativet 'parity' gäller.
</p><p>Dessa alternativ är valfria och kan endast användas en gång.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-3" class="manual-title-level-2">
z-parity FIL [,FIL] ...
</h2>
<p>Definierar en alternativ fil och ett format för att lagra trippel paritet.
</p><p>Detta alternativ är ett alternativ till '3-parity', främst avsett för
lågpresterande processorer som ARM eller AMD Phenom, Athlon och Opteron som inte
stöder SSSE3-instruktionsuppsättningen. I sådana fall ger det
bättre prestanda.
</p><p>Detta format liknar, men är snabbare än, det som används av ZFS RAIDZ3.
Liksom ZFS fungerar det inte utöver trippel paritet.
</p><p>När du använder '3-parity' kommer du att varnas om det rekommenderas att använda
formatet 'z-parity' för prestandaförbättring.
</p><p>Det är möjligt att konvertera från ett format till ett annat genom att justera
konfigurationsfilen med önskad z-parity eller 3-parity fil
och använda 'fix' för att återskapa den.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-4" class="manual-title-level-2">
content FIL
</h2>
<p>Definierar den fil som ska användas för att lagra listan och checksummorna för alla
filer som finns i din disk-array.
</p><p>Den kan placeras på en disk som används för data, paritet eller
någon annan tillgänglig disk.
Om du använder en datadisk exkluderas denna fil automatiskt
från `sync`-processen.
</p><p>Detta alternativ är obligatoriskt och kan användas flera gånger för att spara
flera kopior av samma fil.
</p><p>Du måste lagra minst en kopia för varje paritetsdisk som används
plus en. Att använda ytterligare kopior skadar inte.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-5" class="manual-title-level-2">
data NAMN KATALOG
</h2>
<p>Definierar namnet och monteringspunkten för datadiskarna i
arrayen. NAMN används för att identifiera disken och måste
vara unikt. KATALOG är monteringspunkten för disken i
filsystemet.
</p><p>Du kan ändra monteringspunkten vid behov, så länge
du behåller NAMN fixerat.
</p><p>Du bör använda ett alternativ för varje datadisk i arrayen.
</p><p>Du kan byta namn på en disk senare genom att ändra NAMN direkt
i konfigurationsfilen och sedan köra ett 'sync'-kommando.
I händelse av namnbyte görs associationen med hjälp av den lagrade
UUID:n för diskarna.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-6" class="manual-title-level-2">
nohidden
</h2>
<p>Exkluderar alla dolda filer och kataloger.
I Unix är dolda filer de som börjar med `.`.
I Windows är de de med det dolda attributet.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-7" class="manual-title-level-2">
exclude/include MÖNSTER
</h2>
<p>Definierar fil- eller katalogmönstren att exkludera eller inkludera
i sync-processen.
Alla mönster behandlas i den specificerade ordningen.
</p><p>Om det första mönstret som matchar är ett `exclude`-mönster,
exkluderas filen. Om det är ett `include`-mönster, inkluderas filen.
Om inget mönster matchar, exkluderas filen om det sista mönstret
som specificerats är ett `include`-mönster, eller inkluderas om det sista mönstret
som specificerats är ett `exclude`-mönster.
</p><p>Se avsnittet MÖNSTER för mer information om mönster-
specifikationer.
</p><p>Detta alternativ kan användas flera gånger.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-8" class="manual-title-level-2">
blocksize STORLEK_I_KIBIBYTES
</h2>
<p>Definierar den grundläggande blockstorleken i kibibytes för pariteten.
En kibibyte är 1024 byte.
</p><p>Standard blockstorlek är 256, vilket bör fungera för de flesta fall.
</p><p>VARNING! Detta alternativ är endast för experter, och det rekommenderas
starkt att inte ändra detta värde. För att ändra detta värde i framtiden,
kommer du att behöva återskapa hela pariteten!
</p><p>En anledning att använda en annan blockstorlek är om du har många små
filer, i storleksordningen miljoner.
</p><p>För varje fil, även om den bara är några byte, allokeras ett helt block paritet,
och med många filer kan detta leda till betydande oanvänt paritetsutrymme.
När du helt fyller paritetsdisken, är du inte
tillåten att lägga till fler filer på datadiskarna.
Det bortkastade paritetsutrymmet ackumuleras dock inte över datadiskar.
Bortkastat utrymme som härrör från ett högt antal filer på en datadisk begränsar endast
mängden data på den datadisken, inte andra.
</p><p>Som en approximation kan du anta att hälften av blockstorleken är
bortkastad för varje fil. Till exempel, med 100 000 filer och en 256 KiB
blockstorlek, kommer du att slösa 12,8 GB paritet, vilket kan resultera
i 12,8 GB mindre utrymme tillgängligt på datadisken.
</p><p>Du kan kontrollera mängden bortkastat utrymme på varje disk med hjälp av `status`.
Detta är mängden utrymme du måste lämna ledigt på data-
diskarna eller använda för filer som inte ingår i arrayen.
Om detta värde är negativt betyder det att du är nära att fylla
pariteten, och det representerar det utrymme du fortfarande kan slösa.
</p><p>För att undvika detta problem kan du använda en större partition för paritet.
Om till exempel paritetspartitionen är 12,8 GB större än datadiskarna,
har du tillräckligt med extra utrymme för att hantera upp till 100 000
filer på varje datadisk utan något bortkastat utrymme.
</p><p>Ett trick för att få en större paritetspartition i Linux är att formatera den
med kommandot:
</p><pre>
mkfs.ext4 -m 0 -T largefile4 DEVICE
</pre>
<p>Detta resulterar i cirka 1,5% extra utrymme, ungefär 60 GB för
en 4 TB-disk, vilket möjliggör cirka 460 000 filer på varje datadisk utan
något bortkastat utrymme.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-9" class="manual-title-level-2">
hashsize STORLEK_I_BYTE
</h2>
<p>Definierar hash-storleken i byte för de sparade blocken.
</p><p>Standard hash-storlek är 16 byte (128 bitar), vilket bör fungera
för de flesta fall.
</p><p>VARNING! Detta alternativ är endast för experter, och det rekommenderas
starkt att inte ändra detta värde. För att ändra detta värde i framtiden,
kommer du att behöva återskapa hela pariteten!
</p><p>En anledning att använda en annan hash-storlek är om ditt system har
begränsat minne. Som en tumregel kräver SnapRAID vanligtvis
1 GiB RAM för varje 16 TB data i arrayen.
</p><p>Specifikt, för att lagra hasharna av datan, kräver SnapRAID
ungefär TS*(1+HS)/BS byte RAM,
där TS är den totala storleken i byte av din disk-array, BS är
blockstorleken i byte och HS är hash-storleken i byte.
</p><p>Till exempel, med 8 diskar på 4 TB, en blockstorlek på 256 KiB
(1 KiB = 1024 byte) och en hash-storlek på 16, får du:
</p><pre>
RAM = (8 * 4 * 10^12) * (1+16) / (256 * 2^10) = 1,93 GiB
</pre>
<p>Om du byter till en hash-storlek på 8 får du:
</p><pre>
RAM = (8 * 4 * 10^12) * (1+8) / (256 * 2^10) = 1,02 GiB
</pre>
<p>Om du byter till en blockstorlek på 512 får du:
</p><pre>
RAM = (8 * 4 * 10^12) * (1+16) / (512 * 2^10) = 0,96 GiB
</pre>
<p>Om du byter till både en hash-storlek på 8 och en blockstorlek på 512 får du:
</p><pre>
RAM = (8 * 4 * 10^12) * (1+8) / (512 * 2^10) = 0,51 GiB
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-10" class="manual-title-level-2">
autosave STORLEK_I_GIGABYTES
</h2>
<p>Sparar automatiskt tillståndet vid synkronisering eller skrubbning efter att den
specificerade mängden GB har behandlats.
Detta alternativ är användbart för att undvika att starta om långa `sync`-
kommandon från början om de avbryts av en maskinkrasch eller någon annan händelse.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-11" class="manual-title-level-2">
temp_limit TEMPERATUR_CELSIUS
</h2>
<p>Anger den maximalt tillåtna disk-temperaturen i Celsius. När den specificeras,
kontrollerar SnapRAID periodiskt temperaturen på alla diskar med hjälp av
verktyget smartctl. De aktuella disk-temperaturerna visas medan
SnapRAID är igång. Om någon disk överskrider denna gräns, stoppas alla operationer
och diskarna snurras ner (sätts i standby) under den tid
som definieras av alternativet `temp_sleep`. Efter viloperioden återupptas operationerna,
och kan potentiellt pausas igen om temperaturgränsen nås
ännu en gång.
</p><p>Under drift analyserar SnapRAID också värmekurvan för varje
disk och uppskattar den långsiktiga stabila temperaturen de förväntas
nå om aktiviteten fortsätter. Uppskattningen utförs först efter att
disk-temperaturen har ökat fyra gånger, vilket säkerställer att tillräckligt med
datapoäng finns tillgängliga för att fastställa en pålitlig trend.
Denna förutsagda stabila temperatur visas inom parentes bredvid den
aktuella värdet och hjälper till att bedöma om systemets kylning är
tillräcklig. Denna uppskattade temperatur är endast för informationssyfte
och har ingen effekt på SnapRAIDs beteende. Programmens
åtgärder baseras enbart på de faktiska uppmätta disk-temperaturerna.
</p><p>För att utföra denna analys behöver SnapRAID en referens för system-
temperaturen. Det försöker först läsa den från tillgängliga hårdvaru-
sensorer. Om ingen system-sensor kan nås, används den lägsta disk-
temperaturen som mättes vid start av körningen som en reservreferens.
</p><p>Normalt visar SnapRAID endast temperaturen på den hetaste disken.
För att visa temperaturen på alla diskar, använd alternativet -A eller --stats.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-12" class="manual-title-level-2">
temp_sleep TID_I_MINUTER
</h2>
<p>Anger standby-tiden, i minuter, när temperaturgränsen har
nåtts. Under denna period förblir diskarna nedsnurrade. Standard
är 5 minuter.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-13" class="manual-title-level-2">
pool KATALOG
</h2>
<p>Definierar poolningskatalogen där den virtuella vyn av disk-
arrayen skapas med hjälp av kommandot `pool`.
</p><p>Katalogen måste redan existera.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-14" class="manual-title-level-2">
share UNC_KATALOG
</h2>
<p>Definierar Windows UNC-sökvägen som krävs för att få åtkomst till diskarna på distans.
</p><p>Om detta alternativ specificeras, använder de symboliska länkarna som skapats i pool-
katalogen denna UNC-sökväg för att få åtkomst till diskarna.
Utan detta alternativ använder de genererade symboliska länkarna endast lokala sökvägar,
vilket inte tillåter delning av pool-katalogen över nätverket.
</p><p>De symboliska länkarna bildas med hjälp av den specificerade UNC-sökvägen, lägger till
disk-namnet som specificeras i `data`-alternativet, och lägger slutligen till filens
katalog och namn.
</p><p>Detta alternativ krävs endast för Windows.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-15" class="manual-title-level-2">
smartctl DISK/PARITY ALTERNATIV...
</h2>
<p>Definierar anpassade smartctl-alternativ för att få SMART-attributen för
varje disk. Detta kan krävas för RAID-kontroller och vissa USB-
diskar som inte kan upptäckas automatiskt. Platsinnehavaren %s ersätts av
enhetens namn, men är valfri för fixerade enheter som RAID-kontroller.
</p><p>DISK är samma disk-namn som specificeras i `data`-alternativet.
PARITY är ett av paritetsnamnen: `parity`, `2-parity`, `3-parity`,
`4-parity`, `5-parity`, `6-parity` eller `z-parity`.
</p><p>I de specificerade ALTERNATIVEN ersätts strängen `%s` med
enhetens namn. För RAID-kontroller är enheten
sannolikt fixerad, och du kanske inte behöver använda `%s`.
</p><p>Se smartmontools dokumentation för möjliga alternativ:
</p><pre>
https://www.smartmontools.org/wiki/Supported_RAID-Controllers
https://www.smartmontools.org/wiki/Supported_USB-Devices
</pre>
<p>Till exempel:
</p><pre>
smartctl parity -d sat %s
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-16" class="manual-title-level-2">
smartignore DISK/PARITY ATTR [ATTR...]
</h2>
<p>Ignorerar det specificerade SMART-attributet vid beräkning av sannolikheten
för diskfel. Detta alternativ är användbart om en disk rapporterar ovanliga eller
vilseledande värden för ett visst attribut.
</p><p>DISK är samma disk-namn som specificeras i `data`-alternativet.
PARITY är ett av paritetsnamnen: `parity`, `2-parity`, `3-parity`,
`4-parity`, `5-parity`, `6-parity` eller `z-parity`.
Det speciella värdet * kan användas för att ignorera attributet på alla diskar.
</p><p>Till exempel, för att ignorera attributet `Current Pending Sector Count` på
alla diskar:
</p><pre>
smartignore * 197
</pre>
<p>För att ignorera det endast på den första paritetsdisken:
</p><pre>
smartignore parity 197
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-17" class="manual-title-level-2">
Exempel
</h2>
<p>Ett exempel på en typisk konfiguration för Unix är:
</p><pre>
parity /mnt/diskp/snapraid.parity
content /mnt/diskp/snapraid.content
content /var/snapraid/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
exclude /lost+found/
exclude /tmp/
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/sg0
smartctl 2-parity -d areca,2/1 /dev/sg0
</pre>
<p>Ett exempel på en typisk konfiguration för Windows är:
</p><pre>
parity E:\snapraid.parity
content E:\snapraid.content
content C:\snapraid\snapraid.content
data d1 G:\array\
data d2 H:\array\
data d3 I:\array\
exclude Thumbs.db
exclude \$RECYCLE.BIN
exclude \System Volume Information
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/arcmsr0
smartctl 2-parity -d areca,2/1 /dev/arcmsr0
</pre>
</div>
</div>
<div class="manual-section-level-1">
<h1 id="sec8" class="manual-title-level-1">
Mönster (Pattern)
</h1>
<p>Mönster ger ett flexibelt sätt att filtrera filer för inkludering eller
exkludering. Genom att använda jokertecken kan du definiera regler som
matchar specifika filnamn eller hela katalogstrukturer utan att
lista varje sökväg manuellt.
</p><p>Frågetecknet `?` matchar valfritt enskilt tecken utom katalogavgränsaren.
Detta gör det användbart för att matcha filnamn med variabla tecken
samtidigt som mönstret hålls begränsat till en enda katalognivå.
</p><p>Den enkla stjärnan `*` matchar valfri teckensekvens, men precis som
frågetecknet korsar den aldrig kataloggränser. Den stannar vid
snedstrecket, vilket gör den lämplig för matchning inom en enskild
sökvägskomponent. Detta är det standardbeteende för jokertecken som är
bekant från skal-globbing.
</p><p>Den dubbla stjärnan `**` är mer kraftfull; den matchar valfri teckensekvens
inklusive katalogavgränsare. Detta gör att mönster kan matcha över
flera katalognivåer. När `**` förekommer direkt i ett mönster kan det
matcha noll eller fler tecken inklusive snedstreck mellan den
omkringliggande bokstavliga texten.
</p><p>Den viktigaste användningen av `**` är i den speciella formen `/**/`. Detta matchar
noll eller flera kompletta katalognivåer, vilket gör det möjligt att matcha filer
på valfritt djup i ett katalogträd utan att känna till den exakta sökvägsstrukturen.
Till exempel matchar mönstret `src/**/main.js` filerna `src/main.js` (hoppar över
noll kataloger), `src/ui/main.js` (hoppar över en katalog) och
`src/ui/components/main.js` (hoppar över två kataloger).
</p><p>Teckenklasser som använder hakparenteser `[]` matchar ett enskilt tecken från en
angiven uppsättning eller ett intervall. Precis som de andra mönstren för enskilda
tecken matchar de inte katalogavgränsare. Klasser stöder intervall och
negering med ett utropstecken.
</p><p>Den grundläggande skillnaden att komma ihåg är att `*`, `?` och teckenklasser
alla respekterar kataloggränser och endast matchar inom en enskild
sökvägskomponent, medan `**` är det enda mönstret som kan matcha över
katalogavgränsare.
</p><p>Det finns fyra olika typer av mönster:
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
FILE
</div><div class="manual-option-description">
Väljer valfri fil med namnet FILE.
Detta mönster gäller endast filer, inte kataloger.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
DIR/
</div><div class="manual-option-description">
Väljer valfri katalog med namnet DIR och allt innehåll.
Detta mönster gäller endast kataloger, inte filer.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/FILE
</div><div class="manual-option-description">
Väljer den exakt angivna filsökvägen. Detta mönster gäller
endast filer, inte kataloger.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/DIR/
</div><div class="manual-option-description">
Väljer den exakt angivna katalogsökvägen och allt innehåll.
Detta mönster gäller endast kataloger, inte filer.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>När du specificerar en absolut sökväg som börjar med /, tillämpas den vid
array-rotkatalogen, inte den lokala filsystemets rotkatalog.
</p><p>I Windows kan du använda bakåtsnedstrecket \ istället för framåtsnedstrecket /.
Windows systemkataloger, junction points, monteringspunkter och andra Windows
speciella kataloger behandlas som filer, vilket innebär att för att exkludera
dem måste du använda en fil-regel, inte en katalog-regel.
</p><p>Om filnamnet innehåller tecknet '*', '?', '[',
eller ']', måste du undvika det för att förhindra att det tolkas som ett
globbing-tecken. I Unix är undvikande-tecknet '\'; i Windows är det '^'.
När mönstret är på kommandoraden måste du dubbla undvikande-
tecknet för att förhindra att det tolkas av kommandoskalet.
</p><p>I konfigurationsfilen kan du använda olika strategier för att filtrera
filerna som ska behandlas.
Det enklaste tillvägagångssättet är att endast använda `exclude`-regler för att ta bort alla
filer och kataloger du inte vill behandla. Till exempel:
</p><pre>
# Exkluderar alla filer som heter `*.unrecoverable`
exclude *.unrecoverable
# Exkluderar rotkatalogen `/lost+found`
exclude /lost+found/
# Exkluderar alla underkataloger som heter `tmp`
exclude tmp/
</pre>
<p>Det motsatta tillvägagångssättet är att definiera endast de filer du vill behandla, med
endast `include`-regler. Till exempel:
</p><pre>
# Inkluderar endast vissa kataloger
include /movies/
include /musics/
include /pictures/
</pre>
<p>Det sista tillvägagångssättet är att blanda `exclude`- och `include`-regler. I detta fall
är ordningen på reglerna viktig. Tidigare regler har
företräde framför senare.
För att förenkla kan du lista alla `exclude`-regler först och sedan
alla `include`-regler. Till exempel:
</p><pre>
# Exkluderar alla filer som heter `*.unrecoverable`
exclude *.unrecoverable
# Exkluderar alla underkataloger som heter `tmp`
exclude tmp/
# Inkluderar endast vissa kataloger
include /movies/
include /musics/
include /pictures/
</pre>
<p>På kommandoraden, med hjälp av alternativet -f, kan du bara använda `include`-
mönster. Till exempel:
</p><pre>
# Kontrollerar endast .mp3-filerna.
# I Unix, använd citattecken för att undvika globbing-expansion av skalet.
snapraid -f "*.mp3" check
</pre>
<p>I Unix, när du använder globbing-tecken på kommandoraden, måste du
citattecken dem för att förhindra att skalet expanderar dem.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec9" class="manual-title-level-1">
Ignorera filer (Ignore File)
</h1>
<p>Utöver de globala reglerna i konfigurationsfilen kan du placera
`.snapraidignore`-filer i vilken katalog som helst i arrayen för att definiera
decentraliserade exkluderingsregler.
</p><p>Regler som definieras i `.snapraidignore` tillämpas efter reglerna i
konfigurationsfilen. Detta innebär att de har högre prioritet och kan
användas för att exkludera filer som tidigare inkluderats av den globala
konfigurationen. I praktiken innebär det att om en lokal regel matchar, så
exkluderas filen oavsett de globala inkluderingsinställningarna.
</p><p>Mönsterlogiken i `.snapraidignore` speglar den globala konfigurationen men
förankrar mönstren till den katalog där filen finns:
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
FILE
</div><div class="manual-option-description">
Väljer alla filer med namnet FILE i denna katalog eller under.
Detta följer samma globbing-regler som det globala mönstret.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
DIR/
</div><div class="manual-option-description">
Väljer alla kataloger med namnet DIR och allt innehåll, som finns
i denna katalog eller under.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/FILE
</div><div class="manual-option-description">
Väljer den exakt angivna filen relativt platsen för
`.snapraidignore`-filen.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/DIR/
</div><div class="manual-option-description">
Väljer den exakt angivna katalogen och allt innehåll, relativt
platsen för `.snapraidignore`-filen.
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>Till skillnad från den globala konfigurationen stöder `.snapraidignore`-filer
endast exkluderingsregler; du kan inte använda `include`-mönster eller negation (!).
</p><p>Till exempel, om du har en `.snapraidignore` i `/mnt/disk1/projects/`:
</p><pre>
# Exkluderar ENDAST /mnt/disk1/projects/output.bin
/output.bin
# Exkluderar alla kataloger med namnet 'build' inuti projects/
build/
# Exkluderar alla .tmp-filer inuti projects/ eller dess undermappar
*.tmp
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec10" class="manual-title-level-1">
Innehåll (Content)
</h1>
<p>SnapRAID lagrar listan och checksummorna för dina filer i content-filen.
</p><p>Det är en binär fil som listar alla filer som finns i din disk-array,
tillsammans med alla checksummor för att verifiera deras integritet.
</p><p>Denna fil läses och skrivs av kommandona `sync` och `scrub` och
läses av kommandona `fix`, `check` och `status`.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec11" class="manual-title-level-1">
Paritet (Parity)
</h1>
<p>SnapRAID lagrar paritetsinformationen för din array i parity-
filerna.
</p><p>Dessa är binära filer som innehåller den beräknade pariteten för alla
block definierade i `content`-filen.
</p><p>Dessa filer läses och skrivs av kommandona `sync` och `fix` och
läses endast av kommandona `scrub` och `check`.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec12" class="manual-title-level-1">
Kodning
</h1>
<p>SnapRAID i Unix ignorerar all kodning. Det läser och lagrar
filnamnen med samma kodning som används av filsystemet.
</p><p>I Windows konverteras alla namn som läses från filsystemet och
behandlas i UTF-8-format.
</p><p>För att få filnamn utskrivna korrekt måste du ställa in Windows-
konsolen till UTF-8-läge med kommandot `chcp 65001` och använda
ett TrueType-typsnitt som `Lucida Console` som konsoltypsnitt.
Detta påverkar endast de utskrivna filnamnen; om du
omdirigerar konsolutdata till en fil, är den resulterande filen alltid
i UTF-8-format.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec13" class="manual-title-level-1">
Upphovsrätt (Copyright)
</h1>
<p>Denna fil är Copyright (C) 2025 Andrea Mazzoleni
</p></div>
<div class="manual-section-level-1">
<h1 id="sec14" class="manual-title-level-1">
Se Även (See Also)
</h1>
<p>snapraid_log(1), snapraidd(1)
</p></div>


            </div>
        </main>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container footer-content">
            <div class="footer-col">
                <h3>SnapRAID</h3>
                <p>Copyright &copy; 2026 Andrea Mazzoleni</p>
                <p class="license">Distributed under GPL v3 License</p>
            </div>
            <div class="footer-col">
                <h4>Community</h4>
                <ul>
                    <li><a href="https://www.reddit.com/r/Snapraid/">Reddit r/snapraid</a></li>
                    <li><a href="https://sourceforge.net/p/snapraid/discussion/1677233/">SourceForge Forum</a></li>
                    <li><a href="https://github.com/amadvance/snapraid/">GitHub</a></li>
                </ul>
            </div>
        </div>
    </footer>
</body>
</html>


