<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A backup program for disk arrays. It stores parity information of your data and it recovers from up to six disk failures">
    <meta name="keywords" content="snapraid snapshot raid backup disk array redundancy parity">    
    <title>SnapRAID CLI Manual</title>
    <style>html,body{background-color:#020617;color:#f8fafc;}</style>
    <link rel="stylesheet" href="style.css">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">    
    <script src="script.js"></script>

<!-- Google Analytics 4 -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W1Z5FKHYQ4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-W1Z5FKHYQ4');
</script>

<!-- Google Universal Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body>
    <header>
        <div class="container nav-container">
            <a href="index" class="logo">
                <img src="favicon-32x32.png"/>
                SnapRAID
            </a>
            <nav>
                <input type="checkbox" id="menu-toggle">
                <label for="menu-toggle" class="menu-icon"><svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></label>
                <ul>
                    <li><a href="index" >Home</a></li>
                    <li><a href="ui" >UI & Daemon</a></li>
                    <li><a href="howitworks" >How it Works</a></li>
                    <li><a href="design" >Design</a></li>
                    <li><a href="compare" >Compare</a></li>
                    <li><a href="manual" class="active">Manual</a></li>
                    <li><a href="faq" >FAQ</a></li>
                    <li><a href="support" >Support</a></li>
                    <li><a href="download" class="nav-cta">Download</a></li>
                </ul>
            </nav>
        </div>
    </header>


    <div class="container manual-layout">

        <aside class="manual-sidebar">

            <h4>Components</h4>
            <select id="manual-selector" style="width: 100%; padding: 5px; background: var(--bg-surface); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; margin-bottom: 2rem;">
                <option value="manual.html">Command Line</option>
                <option value="manual-daemon.html">Daemon</option>
                <option value="manual-log.html">Log</option>
            </select>

            <h4>Languages</h4>
            <select id="language-selector" style="width: 100%; padding: 5px; background: var(--bg-surface); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; margin-bottom: 2rem;">
                <option value="manual">English</option>
                <option value="manual-de">German</option>
                <option value="manual-es">Spanish</option>
                <option value="manual-fr">French</option>
                <option value="manual-it">Italian</option>
                <option value="manual-ja">Japanse</option>
                <option value="manual-ko">Korean</option>
                <option value="manual-pl">Polish</option>
                <option value="manual-pt">Portuguese</option>
                <option value="manual-ro">Romanian</option>
                <option value="manual-ru">Russian</option>
                <option value="manual-sv">Swedish</option>
                <option value="manual-uk">Ukranian</option>
                <option value="manual-zh">Simplified Chinese</option>.

            </select>

            <h4>Contents</h4>
            <ul id="manual-toc-list">
                <!-- Populated by JavaScript -->
            </ul>
        </aside>


        <main id="manual-container">
            
            <div class="manual-doc">

<div class="manual-section-level-1">
<h1 id="sec1" class="manual-title-level-1">
Synopsis
</h1>
<pre>
snapraid [-c, --conf CONFIG]
&nbsp;&nbsp;&nbsp;&nbsp;[-f, --filter PATTERN] [-d, --filter-disk NAME]
&nbsp;&nbsp;&nbsp;&nbsp;[-m, --filter-missing] [-e, --filter-error]
&nbsp;&nbsp;&nbsp;&nbsp;[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR]
&nbsp;&nbsp;&nbsp;&nbsp;[-p, --plan PERC|bad|new|full]
&nbsp;&nbsp;&nbsp;&nbsp;[-o, --older-than DAYS] [-l, --log FILE]
&nbsp;&nbsp;&nbsp;&nbsp;[-s, --spin-down-on-error] [-w, --bw-limit RATE]
&nbsp;&nbsp;&nbsp;&nbsp;[-Z, --force-zero] [-E, --force-empty]
&nbsp;&nbsp;&nbsp;&nbsp;[-U, --force-uuid] [-D, --force-device]
&nbsp;&nbsp;&nbsp;&nbsp;[-N, --force-nocopy] [-F, --force-full]
&nbsp;&nbsp;&nbsp;&nbsp;[-R, --force-realloc]
&nbsp;&nbsp;&nbsp;&nbsp;[-S, --start BLKSTART] [-B, --count BLKCOUNT]
&nbsp;&nbsp;&nbsp;&nbsp;[-L, --error-limit NUMBER]
&nbsp;&nbsp;&nbsp;&nbsp;[-A, --stats]
&nbsp;&nbsp;&nbsp;&nbsp;[-v, --verbose] [-q, --quiet]
&nbsp;&nbsp;&nbsp;&nbsp;status|smart|probe|up|down|diff|sync|scrub|fix|check
&nbsp;&nbsp;&nbsp;&nbsp;|list|dup|pool|devices|touch|rehash
</pre>
<pre>
snapraid [-V, --version] [-H, --help] [-C, --gen-conf CONTENT]
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec2" class="manual-title-level-1">
Description
</h1>
<p>SnapRAID ist ein Sicherungsprogramm, das für Festplatten-Arrays
entwickelt wurde und Paritätsinformationen zur Datenwiederherstellung
bei Ausfall von bis zu sechs Festplatten speichert.
</p><p>SnapRAID ist hauptsächlich für Home-Media-Center mit großen,
selten geänderten Dateien konzipiert und bietet folgende Funktionen:
</p><ul>
<li>
Sie können bereits mit Dateien gefüllte Festplatten verwenden,
ohne sie neu formatieren zu müssen, und wie gewohnt darauf zugreifen.
</li>
<li>
Alle Ihre Daten werden gehasht, um die Datenintegrität zu
gewährleisten und stille Beschädigung (silent corruption) zu verhindern.
</li>
<li>
Wenn die Anzahl der ausgefallenen Festplatten die Paritätsanzahl
überschreitet, beschränkt sich der Datenverlust auf die betroffenen
Festplatten; Daten auf anderen Festplatten bleiben zugänglich.
</li>
<li>
Wenn Sie versehentlich Dateien auf einer Festplatte löschen,
ist eine Wiederherstellung möglich.
</li>
<li>
Festplatten können unterschiedliche Größen haben.
</li>
<li>
Sie können jederzeit Festplatten hinzufügen.
</li>
<li>
SnapRAID sperrt Ihre Daten nicht ein; Sie können die Verwendung
jederzeit beenden, ohne neu formatieren oder Daten verschieben zu müssen.
</li>
<li>
Um auf eine Datei zuzugreifen, muss nur eine einzige Festplatte
drehen (spinnen), was Strom spart und Geräusche reduziert.
</li>
</ul>
<p>Für weitere Informationen besuchen Sie bitte die offizielle SnapRAID-Website:
</p><pre>
<a href="https://www.snapraid.it/">https://www.snapraid.it/</a>
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec3" class="manual-title-level-1">
Limitations
</h1>
<p>SnapRAID ist ein Hybrid aus einem RAID- und einem Sicherungsprogramm,
das darauf abzielt, die besten Vorteile beider zu kombinieren.
Es hat jedoch einige Einschränkungen, die Sie vor der Verwendung
berücksichtigen sollten.
</p><p>Die Haupteinschränkung besteht darin, dass wenn eine Festplatte
ausfällt und Sie in letzter Zeit keine Synchronisierung durchgeführt haben,
Sie möglicherweise nicht vollständig wiederherstellen können.
Genauer gesagt können Sie möglicherweise nicht bis zur Größe der
geänderten oder gelöschten Dateien seit der letzten <b>sync</b>-Operation
wiederherstellen. Dies tritt auch dann auf, wenn die geänderten oder
gelöschten Dateien sich nicht auf der ausgefallenen Festplatte befinden.
Aus diesem Grund ist SnapRAID besser für Daten geeignet, die sich
selten ändern.
</p><p>Andererseits verhindern neu hinzugefügte Dateien die Wiederherstellung
von bereits vorhandenen Dateien nicht. Sie verlieren nur die
kürzlich hinzugefügten Dateien, wenn diese sich auf der ausgefallenen
Festplatte befinden.
</p><p>Weitere Einschränkungen von SnapRAID sind:
</p><ul>
<li>
Mit SnapRAID haben Sie immer noch separate Dateisysteme für jede
Festplatte. Mit RAID erhalten Sie ein einziges großes Dateisystem.
</li>
<li>
SnapRAID streift (stripes) keine Daten.
Mit RAID erhalten Sie einen Geschwindigkeitsvorteil durch Striping.
</li>
<li>
SnapRAID unterstützt keine Echtzeit-Wiederherstellung.
Mit RAID müssen Sie die Arbeit nicht unterbrechen, wenn eine
Festplatte ausfällt.
</li>
<li>
SnapRAID kann Daten nur von einer begrenzten Anzahl von Festplattenausfällen
wiederherstellen. Mit einer Sicherung können Sie von einem
vollständigen Ausfall des gesamten Festplatten-Arrays wiederherstellen.
</li>
<li>
Nur Dateinamen, Zeitstempel, symbolische Links (symlinks) und
Hardlinks werden gespeichert. Berechtigungen, Eigentümerschaft
und erweiterte Attribute werden nicht gespeichert.
</li>
</ul>
</div>
<div class="manual-section-level-1">
<h1 id="sec4" class="manual-title-level-1">
Getting Started
</h1>
<p>Um SnapRAID zu verwenden, müssen Sie zuerst eine Festplatte in Ihrem
Festplatten-Array auswählen, die für <b>parity</b>-Informationen
reserviert wird. Mit einer Festplatte für Parität können Sie von
einem einzelnen Festplattenausfall wiederherstellen, ähnlich wie bei RAID5.
</p><p>Wenn Sie von mehr Festplattenausfällen wiederherstellen möchten,
ähnlich wie bei RAID6, müssen Sie zusätzliche Festplatten für Parität
reservieren. Jede zusätzliche Paritätsfestplatte ermöglicht die
Wiederherstellung von einem weiteren Festplattenausfall.
</p><p>Als Paritätsfestplatten müssen Sie die größten Festplatten im Array
auswählen, da die Paritätsinformationen auf die Größe der größten
Datenfestplatte im Array anwachsen können.
</p><p>Diese Festplatten werden zum Speichern der <b>parity</b>-Dateien
reserviert. Sie sollten Ihre Daten nicht darauf speichern.
</p><p>Anschließend müssen Sie die <b>data</b>-Festplatten definieren, die Sie
mit SnapRAID schützen möchten. Der Schutz ist effektiver, wenn diese
Festplatten Daten enthalten, die sich selten ändern. Aus diesem Grund
ist es besser, die Windows C:\-Festplatte oder die Unix-Verzeichnisse
/home, /var und /tmp NICHT einzuschließen.
</p><p>Die Liste der Dateien wird in den <b>content</b>-Dateien gespeichert,
die normalerweise auf den Daten-, Paritäts- oder Boot-Festplatten
gespeichert werden. Diese Datei enthält die Details Ihrer Sicherung,
einschließlich aller Prüfsummen zur Überprüfung ihrer Integrität.
Die <b>content</b>-Datei wird in mehreren Kopien gespeichert, und jede Kopie
muss sich auf einer anderen Festplatte befinden, um sicherzustellen,
dass selbst bei mehreren Festplattenausfällen mindestens eine Kopie
verfügbar ist.
</p><p>Angenommen, Sie sind nur an einer Paritätsstufe des Schutzes interessiert
und Ihre Festplatten befinden sich unter:
</p><pre>
/mnt/diskp &lt;- ausgewählte Festplatte für Parität
/mnt/disk1 &lt;- erste zu schützende Festplatte
/mnt/disk2 &lt;- zweite zu schützende Festplatte
/mnt/disk3 &lt;- dritte zu schützende Festplatte
</pre>
<p>Sie müssen die Konfigurationsdatei /etc/snapraid.conf mit den
folgenden Optionen erstellen:
</p><pre>
parity /mnt/diskp/snapraid.parity
content /var/snapraid/snapraid.content
content /mnt/disk1/snapraid.content
content /mnt/disk2/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
</pre>
<p>Wenn Sie Windows verwenden, sollten Sie das Windows-Pfadformat mit
Laufwerksbuchstaben und Backslashes anstelle von Slashes verwenden.
</p><pre>
parity E:\snapraid.parity
content C:\snapraid\snapraid.content
content F:\array\snapraid.content
content G:\array\snapraid.content
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
</pre>
<p>Wenn Sie viele Festplatten haben und keine Laufwerksbuchstaben mehr
verfügbar sind, können Sie Festplatten direkt in Unterordnern
einhängen (mounten). Siehe:
</p><pre>
<a href="https://www.google.com/search?q=Windows+mount+point">https://www.google.com/search?q=Windows+mount+point</a>
</pre>
<p>Zu diesem Zeitpunkt sind Sie bereit, den Befehl <b>sync</b> auszuführen,
um die Paritätsinformationen zu erstellen.
</p><pre>
snapraid sync
</pre>
<p>Dieser Vorgang kann beim ersten Mal mehrere Stunden dauern, abhängig
von der Größe der bereits auf den Festplatten vorhandenen Daten.
Wenn die Festplatten leer sind, ist der Vorgang sofort abgeschlossen.
</p><p>Sie können ihn jederzeit durch Drücken von Strg+C anhalten, und beim
nächsten Lauf wird er dort fortgesetzt, wo er unterbrochen wurde.
</p><p>Wenn dieser Befehl abgeschlossen ist, sind Ihre Daten SICHER.
</p><p>Jetzt können Sie Ihr Array nach Belieben verwenden und die Paritätsinformationen
regelmäßig durch Ausführen des <b>sync</b>-Befehls aktualisieren.
</p><div class="manual-section-level-2">
<h2 id="sec4-1" class="manual-title-level-2">
Scrubbing
</h2>
<p>Um die Daten und die Parität regelmäßig auf Fehler zu überprüfen,
können Sie den Befehl <b>scrub</b> ausführen.
</p><pre>
snapraid scrub
</pre>
<p>Dieser Befehl vergleicht die Daten in Ihrem Array mit dem Hash,
der während des <b>sync</b>-Befehls berechnet wurde, um die Integrität
zu überprüfen.
</p><p>Jeder Lauf des Befehls überprüft ungefähr 8% des Arrays,
ausgenommen Daten, die bereits in den letzten 10 Tagen gescrubbed wurden.
Sie können die Option -p, --plan verwenden, um eine andere Menge
anzugeben, und die Option -o, --older-than, um ein anderes Alter
in Tagen anzugeben. Zum Beispiel, um 5% des Arrays auf Blöcke zu
überprüfen, die älter als 20 Tage sind, verwenden Sie:
</p><pre>
snapraid -p 5 -o 20 scrub
</pre>
<p>Wenn während des Vorgangs stille oder Eingabe-/Ausgabefehler
gefunden werden, werden die entsprechenden Blöcke in der
<b>content</b>-Datei als fehlerhaft (bad) markiert und im Befehl
<b>status</b> aufgelistet.
</p><pre>
snapraid status
</pre>
<p>Um sie zu beheben, können Sie den Befehl <b>fix</b> verwenden und dabei
nach fehlerhaften Blöcken mit der Option -e, --filter-error
filtern:
</p><pre>
snapraid -e fix
</pre>
<p>Beim nächsten <b>scrub</b> verschwinden die Fehler aus dem <b>status</b>-Bericht,
wenn sie tatsächlich behoben sind. Um es schneller zu machen,
können Sie -p bad verwenden, um nur als fehlerhaft markierte Blöcke
zu scrubben.
</p><pre>
snapraid -p bad scrub
</pre>
<p>Das Ausführen von <b>scrub</b> auf einem nicht synchronisierten Array
kann Fehler melden, die durch entfernte oder geänderte Dateien
verursacht wurden. Diese Fehler werden in der <b>scrub</b>-Ausgabe
gemeldet, aber die zugehörigen Blöcke werden nicht als fehlerhaft
markiert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec4-2" class="manual-title-level-2">
Pooling
</h2>
<p>Hinweis: Die unten beschriebene Pooling-Funktion wurde durch das
Tool mergefs ersetzt, das jetzt die empfohlene Option für Linux-Benutzer
in der SnapRAID-Community ist. Mergefs bietet eine flexiblere
und effizientere Möglichkeit, mehrere Laufwerke zu einem einzigen,
vereinheitlichten Einhängepunkt (Mount Point) zusammenzufassen,
was einen nahtlosen Zugriff auf Dateien über Ihr gesamtes Array
hinweg ermöglicht, ohne auf symbolische Links angewiesen zu sein.
Es lässt sich gut mit SnapRAID zum Paritätsschutz integrieren und
wird häufig in Setups wie OpenMediaVault (OMV) oder benutzerdefinierten
NAS-Konfigurationen verwendet.
</p><p>Um alle Dateien in Ihrem Array im selben Verzeichnisbaum anzuzeigen,
können Sie die <b>pooling</b>-Funktion aktivieren. Sie erstellt eine
schreibgeschützte virtuelle Ansicht aller Dateien in Ihrem Array
mithilfe symbolischer Links.
</p><p>Sie können das <b>pooling</b>-Verzeichnis in der Konfigurationsdatei
mit folgender Option konfigurieren:
</p><pre>
pool /pool
</pre>
<p>oder, wenn Sie Windows verwenden, mit:
</p><pre>
pool C:\pool
</pre>
<p>und anschließend den Befehl <b>pool</b> ausführen, um die virtuelle
Ansicht zu erstellen oder zu aktualisieren.
</p><pre>
snapraid pool
</pre>
<p>Wenn Sie eine Unix-Plattform verwenden und dieses Verzeichnis über
das Netzwerk für Windows- oder Unix-Maschinen freigeben möchten,
sollten Sie die folgenden Optionen zu Ihrer /etc/samba/smb.conf
hinzufügen:
</p><pre>
# Im globalen Abschnitt von smb.conf
unix extensions = no
</pre>
<pre>
# Im Freigabe-Abschnitt von smb.conf
[pool]
comment = Pool
path = /pool
read only = yes
guest ok = yes
wide links = yes
follow symlinks = yes
</pre>
<p>In Windows erfordert die Freigabe symbolischer Links über ein Netzwerk,
dass Clients diese remote auflösen. Um dies zu ermöglichen,
müssen Sie neben der Freigabe des Pool-Verzeichnisses auch alle
Festplatten unabhängig freigeben, indem Sie die in der Konfigurationsdatei
definierten Festplattennamen als Freigabepunkte verwenden.
Sie müssen auch in der Option <b>share</b> der Konfigurationsdatei
den Windows UNC-Pfad angeben, den Remote-Clients benötigen, um
auf diese freigegebenen Festplatten zuzugreifen.
</p><p>Zum Beispiel, wenn Sie von einem Server namens <b>darkstar</b> aus
arbeiten, können Sie die Optionen verwenden:
</p><pre>
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
pool C:\pool
share \\darkstar
</pre>
<p>und die folgenden Verzeichnisse über das Netzwerk freigeben:
</p><pre>
\\darkstar\pool -&gt; C:\pool
\\darkstar\d1 -&gt; F:\array
\\darkstar\d2 -&gt; G:\array
\\darkstar\d3 -&gt; H:\array
</pre>
<p>um Remote-Clients den Zugriff auf alle Dateien unter \\darkstar\pool
zu ermöglichen.
</p><p>Möglicherweise müssen Sie auch Remote-Clients konfigurieren, um
den Zugriff auf Remote-Symlinks mit dem Befehl zu aktivieren:
</p><pre>
fsutil behavior set SymlinkEvaluation L2L:1 R2R:1 L2R:1 R2L:1
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec4-3" class="manual-title-level-2">
Undeleting
</h2>
<p>SnapRAID funktioniert eher wie ein Sicherungsprogramm als ein RAID-System
und kann verwendet werden, um Dateien in ihren vorherigen Zustand
wiederherzustellen oder das Löschen rückgängig zu machen, indem die
Option -f, --filter verwendet wird:
</p><pre>
snapraid fix -f DATEI
</pre>
<p>oder für ein Verzeichnis:
</p><pre>
snapraid fix -f VERZEICHNIS/
</pre>
<p>Sie können es auch verwenden, um nur versehentlich gelöschte Dateien
innerhalb eines Verzeichnisses wiederherzustellen, indem Sie die
Option -m, --filter-missing verwenden, die nur fehlende Dateien
wiederherstellt und alle anderen unberührt lässt.
</p><pre>
snapraid fix -m -f VERZEICHNIS/
</pre>
<p>Oder um alle gelöschten Dateien auf allen Laufwerken wiederherzustellen mit:
</p><pre>
snapraid fix -m
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec4-4" class="manual-title-level-2">
Recovering
</h2>
<p>Das Schlimmste ist passiert, und Sie haben eine oder mehrere Festplatten
verloren!
</p><p>KEINE PANIK! Sie werden in der Lage sein, sie wiederherzustellen!
</p><p>Das erste, was Sie tun müssen, ist, weitere Änderungen an Ihrem
Festplatten-Array zu vermeiden. Deaktivieren Sie alle Remote-Verbindungen
dazu und alle geplanten Prozesse, einschließlich geplanter SnapRAID-nächtlicher
<b>sync</b>- oder <b>scrub</b>-Läufe.
</p><p>Fahren Sie dann mit den folgenden Schritten fort.
</p><div class="manual-section-level-3">
<h3 id="sec4-4-1" class="manual-title-level-3">
STEP 1 -&gt; Reconfigure
</h3>
<p>Sie benötigen etwas Platz zur Wiederherstellung, idealerweise auf
zusätzlichen Ersatzfestplatten, aber eine externe USB-Festplatte oder
eine Remote-Festplatte ist ausreichend.
</p><p>Ändern Sie die SnapRAID-Konfigurationsdatei so, dass die <b>data</b>-
oder <b>parity</b>-Option der ausgefallenen Festplatte auf einen Ort mit
genügend leerem Speicherplatz zur Wiederherstellung der Dateien zeigt.
</p><p>Wenn zum Beispiel die Festplatte <b>d1</b> ausgefallen ist, ändern Sie von:
</p><pre>
data d1 /mnt/disk1/
</pre>
<p>zu:
</p><pre>
data d1 /mnt/new_spare_disk/
</pre>
<p>Wenn die wiederherzustellende Festplatte eine Paritätsfestplatte ist,
aktualisieren Sie die entsprechende <b>parity</b>-Option.
Wenn Sie mehrere ausgefallene Festplatten haben, aktualisieren Sie
alle ihre Konfigurationsoptionen.
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-2" class="manual-title-level-3">
STEP 2 -&gt; Fix
</h3>
<p>Führen Sie den <b>fix</b>-Befehl aus und speichern Sie das Protokoll
in einer externen Datei mit:
</p><pre>
snapraid -d NAME -l fix.log fix
</pre>
<p>Wobei NAME der Name der Festplatte ist, wie z.B. <b>d1</b> in unserem
vorherigen Beispiel. Wenn die wiederherzustellende Festplatte eine
Paritätsfestplatte ist, verwenden Sie die Namen <b>parity</b>, <b>2-parity</b>,
usw. Wenn Sie mehrere ausgefallene Festplatten haben, verwenden Sie
mehrere -d-Optionen, um alle anzugeben.
</p><p>Dieser Befehl wird lange dauern.
</p><p>Stellen Sie sicher, dass Sie einige Gigabyte frei haben, um die
Datei fix.log zu speichern. Führen Sie ihn von einer Festplatte
mit ausreichend freiem Speicherplatz aus.
</p><p>Jetzt haben Sie alles wiederhergestellt, was wiederherstellbar ist.
Wenn einige Dateien teilweise oder vollständig nicht wiederherstellbar
sind, werden sie umbenannt, indem die Erweiterung <b>.unrecoverable</b>
hinzugefügt wird.
</p><p>Sie finden eine detaillierte Liste aller nicht wiederherstellbaren
Blöcke in der Datei fix.log, indem Sie alle Zeilen überprüfen,
die mit <b>unrecoverable:</b> beginnen.
</p><p>Wenn Sie mit der Wiederherstellung nicht zufrieden sind, können Sie
sie so oft wie gewünscht wiederholen.
</p><p>Wenn Sie zum Beispiel Dateien nach dem letzten <b>sync</b> aus dem Array
entfernt haben, kann dies dazu führen, dass einige Dateien nicht
wiederhergestellt werden. In diesem Fall können Sie den <b>fix</b>
mithilfe der Option -i, --import wiederholen, wobei Sie angeben,
wo sich diese Dateien jetzt befinden, um sie erneut in den
Wiederherstellungsprozess einzubeziehen.
</p><p>Wenn Sie mit der Wiederherstellung zufrieden sind, können Sie
fortfahren, aber beachten Sie, dass Sie nach der Synchronisierung
den <b>fix</b>-Befehl nicht mehr wiederholen können!
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-3" class="manual-title-level-3">
STEP 3 -&gt; Check
</h3>
<p>Als vorsichtige Überprüfung können Sie jetzt einen <b>check</b>-Befehl
ausführen, um sicherzustellen, dass auf der wiederhergestellten
Festplatte alles korrekt ist.
</p><pre>
snapraid -d NAME -a check
</pre>
<p>Wobei NAME der Name der Festplatte ist, wie z.B. <b>d1</b> in unserem
vorherigen Beispiel.
</p><p>Die Optionen -d und -a weisen SnapRAID an, nur die angegebene
Festplatte zu überprüfen und alle Paritätsdaten zu ignorieren.
</p><p>Dieser Befehl wird lange dauern, aber wenn Sie nicht übermäßig
vorsichtig sind, können Sie ihn überspringen.
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-4" class="manual-title-level-3">
STEP 4 -&gt; Sync
</h3>
<p>Führen Sie den <b>sync</b>-Befehl aus, um das Array mit der neuen
Festplatte zu resynchronisieren.
</p><pre>
snapraid sync
</pre>
<p>Wenn alles wiederhergestellt ist, ist dieser Befehl sofort.
</p></div>
</div>
</div>
<div class="manual-section-level-1">
<h1 id="sec5" class="manual-title-level-1">
Commands
</h1>
<p>SnapRAID bietet einige einfache Befehle, mit denen Sie:
</p><ul>
<li>
Den Status des Arrays ausgeben -&gt; <b>status</b>
</li>
<li>
Die Festplatten steuern -&gt; <b>smart</b>, <b>probe</b>, <b>up</b>, <b>down</b>
</li>
<li>
Eine Sicherung/einen Snapshot erstellen -&gt; <b>sync</b>
</li>
<li>
Daten regelmäßig überprüfen -&gt; <b>scrub</b>
</li>
<li>
Die letzte Sicherung/den letzten Snapshot wiederherstellen -&gt; <b>fix</b>.
</li>
</ul>
<p>Befehle müssen in Kleinbuchstaben geschrieben werden.
</p><div class="manual-section-level-2">
<h2 id="sec5-1" class="manual-title-level-2">
status
</h2>
<p>Gibt eine Zusammenfassung des Zustands des Festplatten-Arrays aus.
</p><p>Es enthält Informationen zur Paritätsfragmentierung, wie alt
die Blöcke sind, ohne Überprüfung, und alle aufgezeichneten
stillen Fehler, die beim Scrubbing aufgetreten sind.
</p><p>Die präsentierten Informationen beziehen sich auf den letzten Zeitpunkt,
zu dem Sie <b>sync</b> ausgeführt haben. Spätere Änderungen werden
nicht berücksichtigt.
</p><p>Wenn fehlerhafte Blöcke erkannt wurden, werden deren Blocknummern
aufgelistet. Um sie zu beheben, können Sie den Befehl <b>fix -e</b>
verwenden.
</p><p>Es zeigt auch ein Diagramm an, das den letzten Zeitpunkt darstellt,
zu dem jeder Block gescrubbed oder synchronisiert wurde. Gescrubbed
Blöcke werden mit <b>*</b>, Blöcke, die synchronisiert, aber noch nicht
gescrubbed wurden, mit <b>o</b> angezeigt.
</p><p>Es wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-2" class="manual-title-level-2">
smart
</h2>
<p>Gibt einen SMART-Bericht aller Festplatten im System aus.
</p><p>Es enthält eine Schätzung der Ausfallwahrscheinlichkeit im nächsten
Jahr, sodass Sie die Wartungsersetzung von Festplatten planen können,
die verdächtige Attribute aufweisen.
</p><p>Diese Wahrscheinlichkeitsschätzung wird durch Korrelation der SMART-Attribute
der Festplatten mit den Backblaze-Daten erhalten, die unter
folgender Adresse verfügbar sind:
</p><pre>
<a href="https://www.backblaze.com/hard-drive-test-data.html">https://www.backblaze.com/hard-drive-test-data.html</a>
</pre>
<p>Wenn SMART meldet, dass eine Festplatte ausfällt, wird <b>FAIL</b>
oder <b>PREFAIL</b> für diese Festplatte gedruckt, und SnapRAID
endet mit einem Fehler. In diesem Fall wird ein sofortiger
Austausch der Festplatte dringend empfohlen.
</p><p>Weitere mögliche Statuszeichenfolgen sind:
</p><div class="manual-tag-list">
<div class="manual-tag-entry">
<div class="manual-tag-name">
logfail
</div><div class="manual-tag-description">
In der Vergangenheit lagen einige Attribute unter
dem Schwellenwert.
</div>
</div>
<div class="manual-tag-entry">
<div class="manual-tag-name">
logerr
</div><div class="manual-tag-description">
Das Gerätefehlerprotokoll enthält Fehler.
</div>
</div>
<div class="manual-tag-entry">
<div class="manual-tag-name">
selferr
</div><div class="manual-tag-description">
Das Geräte-Selbsttestprotokoll enthält Fehler.
</div>
</div>
</div>
<p>Wenn die Option -v, --verbose angegeben ist, wird eine tiefere
statistische Analyse bereitgestellt. Diese Analyse kann Ihnen bei
der Entscheidung helfen, ob Sie mehr oder weniger Parität benötigen.
</p><p>Dieser Befehl verwendet das <b>smartctl</b>-Tool und entspricht dem
Ausführen von <b>smartctl -a</b> auf allen Geräten.
</p><p>Wenn Ihre Geräte nicht korrekt automatisch erkannt werden, können Sie
einen benutzerdefinierten Befehl mithilfe der <b>smartctl</b>-Option
in der Konfigurationsdatei angeben.
</p><p>Es wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-3" class="manual-title-level-2">
probe
</h2>
<p>Gibt den POWER-Zustand aller Festplatten im System aus.
</p><p><b>Standby</b> bedeutet, dass die Festplatte nicht dreht. <b>Active</b>
bedeutet, dass die Festplatte dreht.
</p><p>Dieser Befehl verwendet das <b>smartctl</b>-Tool und entspricht dem
Ausführen von <b>smartctl -n standby -i</b> auf allen Geräten.
</p><p>Wenn Ihre Geräte nicht korrekt automatisch erkannt werden, können Sie
einen benutzerdefinierten Befehl mithilfe der <b>smartctl</b>-Option
in der Konfigurationsdatei angeben.
</p><p>Es wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-4" class="manual-title-level-2">
up
</h2>
<p>Dreht alle Festplatten des Arrays hoch (spins up).
</p><p>Sie können nur bestimmte Festplatten mithilfe der Option -d, --filter-disk
hochdrehen.
</p><p>Das gleichzeitige Hochdrehen aller Festplatten erfordert viel Strom.
Stellen Sie sicher, dass Ihr Netzteil dies aushalten kann.
</p><p>Es wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-5" class="manual-title-level-2">
down
</h2>
<p>Dreht alle Festplatten des Arrays herunter (spins down).
</p><p>Dieser Befehl verwendet das <b>smartctl</b>-Tool und entspricht dem
Ausführen von <b>smartctl -s standby,now</b> auf allen Geräten.
</p><p>Sie können nur bestimmte Festplatten mithilfe der Option -d, --filter-disk
herunterdrehen.
</p><p>Um automatisch bei einem Fehler herunterzufahren, können Sie die Option
-s, --spin-down-on-error mit jedem anderen Befehl verwenden, was dem
manuellen Ausführen von <b>down</b> bei Auftreten eines Fehlers
entspricht.
</p><p>Es wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-6" class="manual-title-level-2">
diff
</h2>
<p>Listet alle Dateien auf, die seit dem letzten <b>sync</b> geändert wurden
und deren Paritätsdaten neu berechnet werden müssen.
</p><p>Dieser Befehl überprüft nicht die Dateidaten, sondern nur den
Dateizeitstempel, die Größe und die Inode.
</p><p>Nach dem Auflisten aller geänderten Dateien wird eine Zusammenfassung
der Änderungen präsentiert, gruppiert nach:
</p><div class="manual-tag-list">
<div class="manual-tag-entry">
<div class="manual-tag-name">
equal
</div><div class="manual-tag-description">
Dateien, die sich seitdem nicht geändert haben.
</div>
</div>
<div class="manual-tag-entry">
<div class="manual-tag-name">
added
</div><div class="manual-tag-description">
Neu hinzugefügte Dateien, die vorher nicht vorhanden waren.
</div>
</div>
<div class="manual-tag-entry">
<div class="manual-tag-name">
removed
</div><div class="manual-tag-description">
Entfernte Dateien.
</div>
</div>
<div class="manual-tag-entry">
<div class="manual-tag-name">
updated
</div><div class="manual-tag-description">
Dateien mit einer anderen Größe oder einem anderen
Zeitstempel, was bedeutet, dass sie geändert wurden.
</div>
</div>
<div class="manual-tag-entry">
<div class="manual-tag-name">
moved
</div><div class="manual-tag-description">
Auf derselben Festplatte in ein anderes Verzeichnis
verschobene Dateien. Sie werden durch denselben Namen,
dieselbe Größe, denselben Zeitstempel und dieselbe Inode,
aber ein anderes Verzeichnis identifiziert.
</div>
</div>
<div class="manual-tag-entry">
<div class="manual-tag-name">
copied
</div><div class="manual-tag-description">
Auf dieselbe oder eine andere Festplatte kopierte
Dateien. Beachten Sie, dass wenn sie tatsächlich auf eine
andere Festplatte verschoben werden, sie auch unter <b>removed</b>
gezählt werden. Sie werden durch denselben Namen, dieselbe
Größe und denselben Zeitstempel identifiziert. Wenn der
Untersekunden-Zeitstempel Null ist, muss der vollständige
Pfad übereinstimmen, nicht nur der Name.
</div>
</div>
<div class="manual-tag-entry">
<div class="manual-tag-name">
restored
</div><div class="manual-tag-description">
Dateien mit einer anderen Inode, aber übereinstimmendem
Namen, Größe und Zeitstempel. Dies sind normalerweise
Dateien, die nach dem Löschen wiederhergestellt wurden.
</div>
</div>
</div>
<p>Wenn ein <b>sync</b> erforderlich ist, ist der Rückgabecode des Prozesses 2
anstelle des Standardwerts 0. Der Rückgabecode 1 wird für eine
allgemeine Fehlerbedingung verwendet.
</p><p>Es wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-7" class="manual-title-level-2">
sync
</h2>
<p>Aktualisiert die Paritätsinformationen. Alle geänderten Dateien
im Festplatten-Array werden gelesen, und die entsprechenden
Paritätsdaten werden aktualisiert.
</p><p>Sie können diesen Vorgang jederzeit durch Drücken von Strg+C
anhalten, ohne die bereits geleistete Arbeit zu verlieren.
Beim nächsten Lauf wird der <b>sync</b>-Vorgang dort fortgesetzt,
wo er unterbrochen wurde.
</p><p>Wenn während des Vorgangs stille oder Eingabe-/Ausgabefehler
gefunden werden, werden die entsprechenden Blöcke als fehlerhaft
markiert.
</p><p>Dateien werden durch Pfad und/oder Inode identifiziert und anhand
von Größe und Zeitstempel überprüft.
Wenn die Dateigröße oder der Zeitstempel abweicht, werden die Paritätsdaten
für die gesamte Datei neu berechnet.
Wenn die Datei auf derselben Festplatte verschoben oder umbenannt
wird und dieselbe Inode beibehält, wird die Parität nicht neu
berechnet.
Wenn die Datei auf eine andere Festplatte verschoben wird, wird die
Parität neu berechnet, aber die zuvor berechneten Hash-Informationen
werden beibehalten.
</p><p>Die <b>content</b>- und <b>parity</b>-Dateien werden bei Bedarf geändert.
Die Dateien im Array werden NICHT geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-8" class="manual-title-level-2">
scrub
</h2>
<p>Scrubbt das Array und überprüft auf stille oder Eingabe-/Ausgabefehler
auf Daten- und Paritätsfestplatten.
</p><p>Jede Ausführung überprüft ungefähr 8% des Arrays, ausgenommen Daten,
die bereits in den letzten 10 Tagen gescrubbed wurden.
Dies bedeutet, dass Scrubbing einmal pro Woche sicherstellt, dass
jedes Bit an Daten mindestens einmal alle drei Monate überprüft wird.
</p><p>Sie können einen anderen Scrub-Plan oder eine andere Menge mithilfe
der Option -p, --plan definieren, die Folgendes akzeptiert:
bad - Scrubbt als fehlerhaft markierte Blöcke.
new - Scrubbt gerade synchronisierte Blöcke, die noch nicht gescrubbed
</p><p>wurden.
</p><div class="manual-tag-list">
<div class="manual-tag-entry">
<div class="manual-tag-name">
full
</div><div class="manual-tag-description">
Scrubbt alles.
</div>
</div>
<div class="manual-tag-entry">
<div class="manual-tag-name">
0-100
</div><div class="manual-tag-description">
Scrubbt den angegebenen Prozentsatz der Blöcke.
</div>
</div>
</div>
<p>Wenn Sie einen Prozentsatz angeben, können Sie auch die Option
-o, --older-than verwenden, um festzulegen, wie alt der Block sein
soll. Die ältesten Blöcke werden zuerst gescrubbed, um eine optimale
Überprüfung zu gewährleisten. Wenn Sie nur die gerade synchronisierten
Blöcke scrubben möchten, die noch nicht gescrubbed wurden,
verwenden Sie die Option <b>-p new</b>.
</p><p>Um Details zum Scrub-Status zu erhalten, verwenden Sie den Befehl
<b>status</b>.
</p><p>Für jeden gefundenen stillen oder Eingabe-/Ausgabefehler werden die
entsprechenden Blöcke in der <b>content</b>-Datei als fehlerhaft (bad)
markiert. Diese fehlerhaften Blöcke werden in <b>status</b> aufgelistet
und können mit <b>fix -e</b> behoben werden. Nach der Behebung werden
sie beim nächsten Scrub erneut überprüft, und wenn sie als korrigiert
befunden werden, wird die fehlerhafte Markierung entfernt.
Um nur die fehlerhaften Blöcke zu scrubben, können Sie den Befehl
<b>scrub -p bad</b> verwenden.
</p><p>Es wird empfohlen, <b>scrub</b> nur auf einem synchronisierten Array
auszuführen, um gemeldete Fehler zu vermeiden, die durch nicht
synchronisierte Daten verursacht werden. Diese Fehler werden als
keine stillen Fehler erkannt, und die Blöcke werden nicht als fehlerhaft
markiert, aber solche Fehler werden in der Ausgabe des Befehls
gemeldet.
</p><p>Die <b>content</b>-Datei wird geändert, um die Zeit der letzten
Überprüfung für jeden Block zu aktualisieren und fehlerhafte
Blöcke zu markieren.
Die <b>parity</b>-Dateien werden NICHT geändert.
Die Dateien im Array werden NICHT geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-9" class="manual-title-level-2">
fix
</h2>
<p>Behebt alle Dateien und die Paritätsdaten.
</p><p>Alle Dateien und Paritätsdaten werden mit dem Snapshot-Zustand
verglichen, der beim letzten <b>sync</b> gespeichert wurde.
Wenn eine Abweichung gefunden wird, wird sie auf den gespeicherten
Snapshot zurückgesetzt.
</p><p>WARNUNG! Der Befehl <b>fix</b> unterscheidet nicht zwischen Fehlern und
beabsichtigten Änderungen. Er setzt den Dateizustand bedingungslos
auf den letzten <b>sync</b> zurück.
</p><p>Wenn keine andere Option angegeben ist, wird das gesamte Array verarbeitet.
Verwenden Sie die Filteroptionen, um eine Teilmenge von Dateien
oder Festplatten für die Operation auszuwählen.
</p><p>Um nur die Blöcke zu beheben, die während <b>sync</b> und <b>scrub</b> als
fehlerhaft markiert wurden, verwenden Sie die Option -e, --filter-error.
Im Gegensatz zu anderen Filteroptionen wendet diese Behebungen nur
auf Dateien an, die seit dem letzten <b>sync</b> unverändert sind.
</p><p>SnapRAID benennt alle Dateien, die nicht behoben werden können,
durch Hinzufügen der Erweiterung <b>.unrecoverable</b> um.
</p><p>Vor dem Beheben wird das gesamte Array gescannt, um alle Dateien
zu finden, die seit der letzten <b>sync</b>-Operation verschoben wurden.
Diese Dateien werden anhand ihres Zeitstempels identifiziert, wobei
Name und Verzeichnis ignoriert werden, und werden bei Bedarf im
Wiederherstellungsprozess verwendet. Wenn Sie einige davon außerhalb
des Arrays verschoben haben, können Sie die Option -i, --import
verwenden, um zusätzliche Verzeichnisse zum Scannen anzugeben.
</p><p>Dateien werden nur anhand des Pfads identifiziert, nicht anhand
der Inode.
</p><p>Die <b>content</b>-Datei wird NICHT geändert.
Die <b>parity</b>-Dateien werden bei Bedarf geändert.
Die Dateien im Array werden bei Bedarf geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-10" class="manual-title-level-2">
check
</h2>
<p>Überprüft alle Dateien und die Paritätsdaten.
</p><p>Es funktioniert wie <b>fix</b>, simuliert jedoch nur eine Wiederherstellung,
und es werden keine Änderungen in das Array geschrieben.
</p><p>Dieser Befehl ist primär für manuelle Überprüfung gedacht, wie z.B.
nach einem Wiederherstellungsprozess oder unter anderen speziellen
Bedingungen. Für regelmäßige und geplante Überprüfungen verwenden
Sie <b>scrub</b>.
</p><p>Wenn Sie die Option -a, --audit-only verwenden, wird nur der Hash
der Dateien überprüft, und die Paritätsdaten werden für einen
schnelleren Lauf ignoriert.
</p><p>Dateien werden nur anhand des Pfads identifiziert, nicht anhand
der Inode.
</p><p>Es wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-11" class="manual-title-level-2">
list
</h2>
<p>Listet alle Dateien auf, die sich zum Zeitpunkt des letzten <b>sync</b>
im Array befanden.
</p><p>Mit -v oder --verbose wird auch die Untersekundenzeit angezeigt.
</p><p>Es wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-12" class="manual-title-level-2">
dup
</h2>
<p>Listet alle doppelten Dateien auf. Zwei Dateien gelten als gleich,
wenn ihre Hashes übereinstimmen. Die Dateidaten werden nicht gelesen;
es werden nur die vorab berechneten Hashes verwendet.
</p><p>Es wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-13" class="manual-title-level-2">
pool
</h2>
<p>Erstellt oder aktualisiert eine virtuelle Ansicht aller
Dateien in Ihrem Festplatten-Array im <b>pooling</b>-Verzeichnis.
</p><p>Die Dateien werden nicht kopiert, sondern mithilfe symbolischer
Links verknüpft.
</p><p>Beim Aktualisieren werden alle vorhandenen symbolischen Links und
leeren Unterverzeichnisse gelöscht und durch die neue Ansicht des
Arrays ersetzt. Alle anderen regulären Dateien bleiben erhalten.
</p><p>Außerhalb des Pool-Verzeichnisses wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-14" class="manual-title-level-2">
devices
</h2>
<p>Gibt die Low-Level-Geräte aus, die vom Array verwendet werden.
</p><p>Dieser Befehl zeigt die Gerätezuordnungen im Array an und ist
hauptsächlich als Skriptschnittstelle gedacht.
</p><p>Die ersten beiden Spalten sind die Low-Level-Geräte-ID und der Pfad.
Die nächsten beiden Spalten sind die High-Level-Geräte-ID und der Pfad.
Die letzte Spalte ist der Festplattenname im Array.
</p><p>In den meisten Fällen haben Sie ein Low-Level-Gerät für jede
Festplatte im Array, aber in einigen komplexeren Konfigurationen
können mehrere Low-Level-Geräte von einer einzigen Festplatte
im Array verwendet werden.
</p><p>Es wird nichts geändert.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-15" class="manual-title-level-2">
touch
</h2>
<p>Setzt einen beliebigen Untersekunden-Zeitstempel für alle Dateien,
deren Untersekunden-Zeitstempel auf Null gesetzt ist.
</p><p>Dies verbessert die Fähigkeit von SnapRAID, verschobene und
kopierte Dateien zu erkennen, da es den Zeitstempel fast
eindeutig macht und mögliche Duplikate reduziert.
</p><p>Genauer gesagt, wenn der Untersekunden-Zeitstempel nicht Null ist,
wird eine verschobene oder kopierte Datei als solche identifiziert,
wenn sie mit Name, Größe und Zeitstempel übereinstimmt. Wenn der
Untersekunden-Zeitstempel Null ist, wird sie nur als Kopie betrachtet,
wenn der vollständige Pfad, die Größe und der Zeitstempel alle
übereinstimmen.
</p><p>Der Zeitstempel mit Sekundenpräzision wird nicht geändert,
sodass alle Daten und Zeiten Ihrer Dateien erhalten bleiben.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-16" class="manual-title-level-2">
rehash
</h2>
<p>Plant eine Neu-Hash-Berechnung (rehash) des gesamten Arrays.
</p><p>Dieser Befehl ändert die verwendete Hash-Art, typischerweise beim
Upgrade von einem 32-Bit-System auf ein 64-Bit-System, um von
MurmurHash3 auf den schnelleren SpookyHash umzuschalten.
</p><p>Wenn Sie bereits den optimalen Hash verwenden, tut dieser Befehl
nichts und informiert Sie darüber, dass keine Aktion erforderlich ist.
</p><p>Die Neu-Hash-Berechnung wird nicht sofort durchgeführt, sondern
findet schrittweise während <b>sync</b> und <b>scrub</b> statt.
</p><p>Sie können den Neu-Hash-Zustand mithilfe von <b>status</b> überprüfen.
</p><p>Während der Neu-Hash-Berechnung behält SnapRAID die volle
Funktionalität bei, mit der einzigen Ausnahme, dass <b>dup</b> keine
doppelten Dateien mit einem anderen Hash erkennen kann.
</p></div>
</div>
<div class="manual-section-level-1">
<h1 id="sec6" class="manual-title-level-1">
Options
</h1>
<p>SnapRAID bietet die folgenden Optionen:
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-c, --conf CONFIG
</div><div class="manual-option-description">
Wählt die zu verwendende Konfigurationsdatei aus. Wenn nicht
angegeben, wird unter Unix die Datei <b>/usr/local/etc/snapraid.conf</b>
verwendet, falls sie existiert, andernfalls <b>/etc/snapraid.conf</b>.
Unter Windows wird die Datei <b>snapraid.conf</b> im selben
Verzeichnis wie <b>snapraid.exe</b> verwendet.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-f, --filter PATTERN
</div><div class="manual-option-description">
Filtert die zu verarbeitenden Dateien in <b>check</b> und <b>fix</b>.
Nur die Dateien, die dem angegebenen Muster entsprechen, werden
verarbeitet. Diese Option kann mehrmals verwendet werden.
Weitere Details zu Musterspezifikationen finden Sie im
Abschnitt PATTERN. Unter Unix stellen Sie sicher, dass Globbing-Zeichen
in Anführungszeichen gesetzt werden, wenn sie verwendet werden.
Diese Option kann nur mit <b>check</b> und <b>fix</b> verwendet werden.
Sie kann nicht mit <b>sync</b> und <b>scrub</b> verwendet werden, da
diese immer das gesamte Array verarbeiten.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-d, --filter-disk NAME
</div><div class="manual-option-description">
Filtert die zu verarbeitenden Festplatten in <b>check</b>, <b>fix</b>, <b>up</b>
und <b>down</b>. Sie müssen einen Festplattennamen angeben, wie
in der Konfigurationsdatei definiert. Sie können auch Paritätsfestplatten
mit den Namen <b>parity</b>, <b>2-parity</b>, <b>3-parity</b>, usw. angeben,
um Vorgänge auf eine bestimmte Paritätsfestplatte zu beschränken.
Wenn Sie mehrere --filter, --filter-disk und --filter-missing
Optionen kombinieren, werden nur Dateien ausgewählt, die allen
Filtern entsprechen. Diese Option kann mehrmals verwendet werden.
Diese Option kann nur mit <b>check</b>, <b>fix</b>, <b>up</b> und <b>down</b> verwendet
werden. Sie kann nicht mit <b>sync</b> und <b>scrub</b> verwendet werden,
da diese immer das gesamte Array verarbeiten.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-m, --filter-missing
</div><div class="manual-option-description">
Filtert die zu verarbeitenden Dateien in <b>check</b> und <b>fix</b>.
Nur die Dateien, die im Array fehlen oder gelöscht wurden, werden
verarbeitet. Bei Verwendung mit <b>fix</b> fungiert dies als
<b>undelete</b>-Befehl (Wiederherstellung von Gelöschtem).
Wenn Sie mehrere --filter, --filter-disk und --filter-missing
Optionen kombinieren, werden nur Dateien ausgewählt, die allen
Filtern entsprechen. Diese Option kann nur mit <b>check</b> und <b>fix</b>
verwendet werden. Sie kann nicht mit <b>sync</b> und <b>scrub</b>
verwendet werden, da diese immer das gesamte Array verarbeiten.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-e, --filter-error
</div><div class="manual-option-description">
Verarbeitet die Dateien mit Fehlern in <b>check</b> und <b>fix</b>.
Es verarbeitet nur Dateien, deren Blöcke während <b>sync</b>
und <b>scrub</b> als mit stillen oder Eingabe-/Ausgabefehlern
markiert wurden, wie in <b>status</b> aufgelistet.
Diese Option kann nur mit <b>check</b> und <b>fix</b> verwendet werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-p, --plan PERC|bad|new|full
</div><div class="manual-option-description">
Wählt den Scrub-Plan aus. Wenn PERC ein numerischer Wert
von 0 bis 100 ist, wird er als Prozentsatz der zu scrubbenden
Blöcke interpretiert. Anstelle eines Prozentsatzes können Sie
einen Plan angeben: <b>bad</b> scrubbt fehlerhafte Blöcke,
<b>new</b> scrubbt Blöcke, die noch nicht gescrubbed wurden,
und <b>full</b> scrubbt alles.
Diese Option kann nur mit <b>scrub</b> verwendet werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-o, --older-than DAYS
</div><div class="manual-option-description">
Wählt den ältesten Teil des Arrays aus, der in <b>scrub</b>
verarbeitet werden soll. DAYS ist das Mindestalter in Tagen,
damit ein Block gescrubbed werden kann; der Standardwert
ist 10. Blöcke, die als fehlerhaft markiert sind, werden
immer gescrubbed, unabhängig von dieser Option.
Diese Option kann nur mit <b>scrub</b> verwendet werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-a, --audit-only
</div><div class="manual-option-description">
Überprüft in <b>check</b> den Hash der Dateien, ohne die Paritätsdaten
zu überprüfen. Wenn Sie nur an der Überprüfung der Dateidaten
interessiert sind, kann diese Option den Überprüfungsprozess
erheblich beschleunigen.
Diese Option kann nur mit <b>check</b> verwendet werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-h, --pre-hash
</div><div class="manual-option-description">
Führt in <b>sync</b> eine vorläufige Hash-Phase aller neuen Daten
zur zusätzlichen Überprüfung vor der Paritätsberechnung durch.
Normalerweise wird in <b>sync</b> keine vorläufige Hash-Berechnung
durchgeführt, und die neuen Daten werden unmittelbar vor der
Paritätsberechnung gehasht, wenn sie zum ersten Mal gelesen werden.
Dieser Vorgang tritt auf, wenn das System unter starker Last
steht, wobei alle Festplatten drehen und eine ausgelastete CPU
vorliegt. Dies ist ein Extremzustand für die Maschine, und wenn
sie ein latentes Hardwareproblem hat, können stille Fehler
unentdeckt bleiben, da die Daten noch nicht gehasht sind.
Um dieses Risiko zu vermeiden, können Sie den <b>pre-hash</b>-Modus
aktivieren, um alle Daten zweimal lesen zu lassen und so ihre
Integrität sicherzustellen. Diese Option überprüft auch im Array
verschobene Dateien, um sicherzustellen, dass die Verschiebeoperation
erfolgreich war, und ermöglicht es Ihnen, bei Bedarf eine
<b>fix</b>-Operation durchzuführen, bevor Sie fortfahren.
Diese Option kann nur mit <b>sync</b> verwendet werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-i, --import DIR
</div><div class="manual-option-description">
Importiert aus dem angegebenen Verzeichnis alle Dateien, die
nach dem letzten <b>sync</b> aus dem Array gelöscht wurden.
Wenn Sie solche Dateien noch haben, können sie von <b>check</b> und
<b>fix</b> verwendet werden, um den Wiederherstellungsprozess zu
verbessern. Die Dateien werden gelesen, auch in Unterverzeichnissen,
und unabhängig von ihrem Namen identifiziert.
Diese Option kann nur mit <b>check</b> und <b>fix</b> verwendet werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-s, --spin-down-on-error
</div><div class="manual-option-description">
Dreht bei jedem Fehler alle verwalteten Festplatten herunter,
bevor mit einem von Null verschiedenen Statuscode beendet wird.
Dies verhindert, dass die Laufwerke nach einem abgebrochenen
Vorgang aktiv bleiben und drehen, was unnötige Hitzeentwicklung
und Stromverbrauch vermeiden hilft. Verwenden Sie diese Option,
um sicherzustellen, dass die Festplatten auch bei einem
Befehlsfehler sicher gestoppt werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-w, --bw-limit RATE
</div><div class="manual-option-description">
Wendet eine globale Bandbreitenbegrenzung für alle Festplatten
an. RATE ist die Anzahl der Bytes pro Sekunde. Sie können
einen Multiplikator wie K, M oder G angeben (z.B. --bw-limit 1G).
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-A, --stats
</div><div class="manual-option-description">
Aktiviert eine erweiterte Statusansicht, die zusätzliche
Informationen anzeigt. Der Bildschirm zeigt zwei Diagramme an:
Das erste Diagramm zeigt die Anzahl der gepufferten Stripes für jede
Festplatte sowie den Dateipfad der Datei, auf die derzeit auf dieser
Festplatte zugegriffen wird. Typischerweise hat die langsamste Festplatte
keinen verfügbaren Puffer, was die maximal erreichbare Bandbreite bestimmt.
Das zweite Diagramm zeigt den Prozentsatz der Wartezeit über die
letzten 100 Sekunden. Es wird erwartet, dass die langsamste Festplatte
die meiste Wartezeit verursacht, während andere Festplatten wenig
oder keine Wartezeit haben sollten, da sie ihre gepufferten Stripes
verwenden können. Dieses Diagramm zeigt auch die Zeit an, die
mit Warten auf Hash-Berechnungen und RAID-Berechnungen verbracht
wurde. Alle Berechnungen laufen parallel zu den Festplattenoperationen.
Solange für mindestens eine Festplatte eine messbare Wartezeit
vorhanden ist, deutet dies daher darauf hin, dass die CPU schnell
genug ist, um mit der Arbeitslast Schritt zu halten.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-Z, --force-zero
</div><div class="manual-option-description">
Erzwingt den unsicheren Vorgang der Synchronisierung einer Datei
mit Nullgröße, die zuvor nicht Null war. Wenn SnapRAID eine
solche Bedingung erkennt, stoppt es den Vorgang, es sei denn,
Sie geben diese Option an. Dies ermöglicht es Ihnen, leicht zu
erkennen, wann nach einem Systemabsturz einige zugegriffene Dateien
abgeschnitten (truncated) wurden. Dies ist eine mögliche Bedingung
unter Linux mit den ext3/ext4-Dateisystemen.
Diese Option kann nur mit <b>sync</b> verwendet werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-E, --force-empty
</div><div class="manual-option-description">
Erzwingt den unsicheren Vorgang der Synchronisierung einer
Festplatte, bei der alle ursprünglichen Dateien fehlen.
Wenn SnapRAID erkennt, dass alle ursprünglich auf der Festplatte
vorhandenen Dateien fehlen oder überschrieben wurden, stoppt es
den Vorgang, es sei denn, Sie geben diese Option an.
Dies ermöglicht es Ihnen, leicht zu erkennen, wann ein Daten-Dateisystem
nicht gemountet (eingehängt) ist.
Diese Option kann nur mit <b>sync</b> verwendet werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-U, --force-uuid
</div><div class="manual-option-description">
Erzwingt den unsicheren Vorgang der Synchronisierung, Überprüfung
und Behebung mit Festplatten, deren UUID geändert wurde.
Wenn SnapRAID erkennt, dass einige Festplatten ihre UUID
geändert haben, stoppt es den Vorgang, es sei denn, Sie geben
diese Option an. Dies ermöglicht es Ihnen, zu erkennen, wann
Ihre Festplatten an den falschen Einhängepunkten gemountet sind.
Es ist jedoch erlaubt, eine einzelne UUID-Änderung mit einfacher
Parität zu haben und mehr mit mehrfacher Parität, da dies
der normale Fall beim Austausch von Festplatten nach einer
Wiederherstellung ist.
Diese Option kann nur mit <b>sync</b>, <b>check</b> oder <b>fix</b> verwendet
werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-D, --force-device
</div><div class="manual-option-description">
Erzwingt den unsicheren Vorgang der Behebung mit unzugänglichen
Festplatten oder mit Festplatten auf demselben physischen Gerät.
Wenn Sie beispielsweise zwei Datenfestplatten verloren haben und
eine Ersatzfestplatte haben, um nur die erste wiederherzustellen,
können Sie die zweite unzugängliche Festplatte ignorieren.
Oder wenn Sie eine Festplatte in dem auf einer bereits
verwendeten Festplatte verbleibenden freien Speicherplatz
wiederherstellen möchten, wobei sie dasselbe physische Gerät
gemeinsam nutzen.
Diese Option kann nur mit <b>fix</b> verwendet werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-N, --force-nocopy
</div><div class="manual-option-description">
Deaktiviert in <b>sync</b>, <b>check</b> und <b>fix</b> die Kopiererkennungsheuristik.
Ohne diese Option geht SnapRAID davon aus, dass Dateien mit den
gleichen Attributen, wie Name, Größe und Zeitstempel, Kopien mit
denselben Daten sind. Dies ermöglicht die Identifizierung von
kopierten oder von einer Festplatte auf eine andere verschobenen
Dateien und die Wiederverwendung der bereits berechneten Hash-Informationen,
um stille Fehler zu erkennen oder fehlende Dateien wiederherzustellen.
In einigen seltenen Fällen kann dieses Verhalten zu falsch positiven
Ergebnissen oder einem langsamen Vorgang aufgrund vieler Hash-Überprüfungen
führen, und diese Option ermöglicht es Ihnen, solche Probleme
zu beheben.
Diese Option kann nur mit <b>sync</b>, <b>check</b> und <b>fix</b> verwendet
werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-F, --force-full
</div><div class="manual-option-description">
Erzwingt in <b>sync</b> eine vollständige Neuberechnung der Parität.
Diese Option kann verwendet werden, wenn Sie eine neue Paritätsstufe
hinzufügen oder wenn Sie zu einer alten Content-Datei mit
neueren Paritätsdaten zurückgekehrt sind. Anstatt die Parität
von Grund auf neu zu erstellen, ermöglicht dies die Wiederverwendung
der in der Content-Datei vorhandenen Hashes zur Validierung
von Daten und zur Aufrechterhaltung des Datenschutzes während
des <b>sync</b>-Vorgangs unter Verwendung der vorhandenen Paritätsdaten.
Diese Option kann nur mit <b>sync</b> verwendet werden.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-R, --force-realloc
</div><div class="manual-option-description">
Erzwingt in <b>sync</b> eine vollständige Neuallokation von Dateien
und eine Wiederherstellung der Parität.
Diese Option kann verwendet werden, um alle Dateien vollständig
neu zuzuweisen und die Fragmentierung zu entfernen, während
die in der Content-Datei vorhandenen Hashes zur Validierung
von Daten wiederverwendet werden.
Diese Option kann nur mit <b>sync</b> verwendet werden.
WARNUNG! Diese Option ist nur für Experten gedacht, und es wird
dringend empfohlen, sie nicht zu verwenden.
Sie haben während der <b>sync</b>-Operation KEINEN Datenschutz.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-l, --log FILE
</div><div class="manual-option-description">
Schreibt ein detailliertes Protokoll in die angegebene Datei.
Wenn diese Option nicht angegeben ist, werden unerwartete Fehler
auf dem Bildschirm ausgegeben, was bei vielen Fehlern möglicherweise
zu einer übermäßigen Ausgabe führt. Wenn -l, --log angegeben
ist, werden nur schwerwiegende Fehler, die SnapRAID zum Stoppen
bringen, auf dem Bildschirm ausgegeben.
Wenn der Pfad mit <b>&gt;&gt;</b> beginnt, wird die Datei im Anhängemodus
(append mode) geöffnet. Vorkommen von <b>%D</b> und <b>%T</b> im Namen
werden durch Datum und Uhrzeit im Format YYYYMMDD bzw. HHMMSS
ersetzt. In Windows-Batch-Dateien müssen Sie das <b>%</b>-Zeichen
verdoppeln, z.B. result-%%D.log. Um <b>&gt;&gt;</b> zu verwenden, müssen
Sie den Namen in Anführungszeichen setzen, z.B. <b>"&gt;&gt;result.log"</b>.
Um das Protokoll an die Standardausgabe oder den Standardfehler
auszugeben, können Sie <b>"&gt;&amp;1"</b> bzw. <b>"&gt;&amp;2"</b> verwenden.
Beschreibungen der Protokoll-Tags finden Sie in der Datei
snapraid_log.txt oder in der Manpage.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-L, --error-limit NUMBER
</div><div class="manual-option-description">
Legt ein neues Fehlerlimit fest, bevor die Ausführung gestoppt
wird. Standardmäßig stoppt SnapRAID, wenn es mehr als 100
Eingabe-/Ausgabefehler feststellt, was darauf hindeutet, dass
eine Festplatte wahrscheinlich ausfällt. Diese Option wirkt sich
auf <b>sync</b> und <b>scrub</b> aus, denen es gestattet ist, nach dem
ersten Satz von Festplattenfehlern fortzufahren, um ihre Vorgänge
abzuschließen. <b>check</b> und <b>fix</b> stoppen jedoch immer beim
ersten Fehler.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-S, --start BLKSTART
</div><div class="manual-option-description">
Startet die Verarbeitung ab der angegebenen Blocknummer.
Dies kann nützlich sein, um die Überprüfung oder Behebung
spezifischer Blöcke im Falle einer beschädigten Festplatte
zu wiederholen. Diese Option ist hauptsächlich für die erweiterte
manuelle Wiederherstellung gedacht.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-B, --count BLKCOUNT
</div><div class="manual-option-description">
Verarbeitet nur die angegebene Anzahl von Blöcken.
Diese Option ist hauptsächlich für die erweiterte manuelle
Wiederherstellung gedacht.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-C, --gen-conf CONTENT
</div><div class="manual-option-description">
Generiert eine Dummy-Konfigurationsdatei aus einer vorhandenen
Content-Datei. Die Konfigurationsdatei wird in die Standardausgabe
geschrieben und überschreibt keine vorhandene.
Diese Konfigurationsdatei enthält auch die Informationen,
die zur Rekonstruktion der Festplatten-Einhängepunkte erforderlich
sind, falls Sie das gesamte System verlieren.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-v, --verbose
</div><div class="manual-option-description">
Gibt mehr Informationen auf dem Bildschirm aus.
Wenn einmal angegeben, werden ausgeschlossene Dateien
und zusätzliche Statistiken gedruckt.
Diese Option hat keine Auswirkung auf die Protokolldateien.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-q, --quiet
</div><div class="manual-option-description">
Gibt weniger Informationen auf dem Bildschirm aus.
Wenn einmal angegeben, wird die Fortschrittsleiste entfernt;
zweimal, die laufenden Operationen; dreimal, die Info-Meldungen;
viermal, die Statusmeldungen.
Schwerwiegende Fehler werden immer auf dem Bildschirm ausgegeben.
Diese Option hat keine Auswirkung auf die Protokolldateien.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-H, --help
</div><div class="manual-option-description">
Gibt eine kurze Hilfeanzeige aus.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-V, --version
</div><div class="manual-option-description">
Gibt die Programmversion aus.
</div>
</div>
</div>
</div>
<div class="manual-section-level-1">
<h1 id="sec7" class="manual-title-level-1">
Configuration
</h1>
<p>SnapRAID benötigt eine Konfigurationsdatei, um zu wissen, wo sich
Ihr Festplatten-Array befindet und wo die Paritätsinformationen
gespeichert werden sollen.
</p><p>Unter Unix wird die Datei <b>/usr/local/etc/snapraid.conf</b> verwendet,
falls sie existiert, andernfalls <b>/etc/snapraid.conf</b>.
Unter Windows wird die Datei <b>snapraid.conf</b> im selben
Verzeichnis wie <b>snapraid.exe</b> verwendet.
</p><p>Sie muss die folgenden Optionen (Groß- und Kleinschreibung beachten)
enthalten:
</p><div class="manual-section-level-2">
<h2 id="sec7-1" class="manual-title-level-2">
parity FILE [,FILE] ...
</h2>
<p>Definiert die Dateien, die zum Speichern der Paritätsinformationen
verwendet werden sollen. Die Parität ermöglicht den Schutz
vor einem einzelnen Festplattenausfall, ähnlich wie bei RAID5.
</p><p>Sie können mehrere Dateien angeben, die sich auf unterschiedlichen
Festplatten befinden müssen. Wenn eine Datei nicht mehr wachsen
kann, wird die nächste verwendet. Der gesamte verfügbare Platz
muss mindestens so groß sein wie die größte Datenfestplatte im
Array.
</p><p>Sie können später zusätzliche Paritätsdateien hinzufügen, aber Sie
können sie nicht neu anordnen oder entfernen.
</p><p>Das Reservieren der Paritätsfestplatten für Parität stellt sicher,
dass sie nicht fragmentiert werden, was die Leistung verbessert.
</p><p>Unter Windows werden 256 MB auf jeder Festplatte ungenutzt gelassen,
um die Warnung vor vollen Festplatten zu vermeiden.
</p><p>Diese Option ist obligatorisch und kann nur einmal verwendet werden.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-2" class="manual-title-level-2">
(2,3,4,5,6)-parity FILE [,FILE] ...
</h2>
<p>Definiert die Dateien, die zum Speichern zusätzlicher Paritätsinformationen
verwendet werden sollen.
</p><p>Für jede angegebene Paritätsstufe wird eine zusätzliche Schutzstufe
aktiviert:
</p><ul>
<li>
2-parity aktiviert RAID6 Dual-Parität.
</li>
<li>
3-parity aktiviert Triple-Parität.
</li>
<li>
4-parity aktiviert Quad- (vierfache) Parität.
</li>
<li>
5-parity aktiviert Penta- (fünffache) Parität.
</li>
<li>
6-parity aktiviert Hexa- (sechsfache) Parität.
</li>
</ul>
<p>Jede Paritätsstufe erfordert die Anwesenheit aller vorherigen
Paritätsstufen.
</p><p>Die gleichen Überlegungen wie bei der Option <b>parity</b> gelten.
</p><p>Diese Optionen sind optional und können nur einmal verwendet werden.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-3" class="manual-title-level-2">
z-parity FILE [,FILE] ...
</h2>
<p>Definiert eine alternative Datei und ein alternatives Format zum
Speichern von Triple-Parität.
</p><p>Diese Option ist eine Alternative zu <b>3-parity</b>, die primär für
Low-End-CPUs wie ARM oder AMD Phenom, Athlon und Opteron gedacht
ist, die den SSSE3-Befehlssatz nicht unterstützen. In solchen Fällen
bietet sie eine bessere Leistung.
</p><p>Dieses Format ähnelt dem von ZFS RAIDZ3, ist aber schneller.
Wie ZFS funktioniert es nicht jenseits der Triple-Parität.
</p><p>Bei Verwendung von <b>3-parity</b> werden Sie gewarnt, wenn das
<b>z-parity</b>-Format zur Leistungsverbesserung empfohlen wird.
</p><p>Es ist möglich, von einem Format in ein anderes zu konvertieren,
indem die Konfigurationsdatei mit der gewünschten z-parity- oder
3-parity-Datei angepasst und <b>fix</b> zur Neuerstellung verwendet wird.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-4" class="manual-title-level-2">
content FILE
</h2>
<p>Definiert die Datei, die zum Speichern der Liste und Prüfsummen
aller im Festplatten-Array vorhandenen Dateien verwendet werden soll.
</p><p>Sie kann auf einer für Daten, Parität oder einer anderen
verfügbaren Festplatte platziert werden.
Wenn Sie eine Datenfestplatte verwenden, wird diese Datei automatisch
vom <b>sync</b>-Vorgang ausgeschlossen.
</p><p>Diese Option ist obligatorisch und kann mehrmals verwendet werden,
um mehrere Kopien derselben Datei zu speichern.
</p><p>Sie müssen mindestens eine Kopie für jede verwendete Paritätsfestplatte
plus eine speichern. Die Verwendung zusätzlicher Kopien schadet nicht.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-5" class="manual-title-level-2">
data NAME DIR
</h2>
<p>Definiert den Namen und den Einhängepunkt (Mount Point) der
Datenfestplatten im Array. NAME wird zur Identifizierung der
Festplatte verwendet und muss eindeutig sein. DIR ist der
Einhängepunkt der Festplatte im Dateisystem.
</p><p>Sie können den Einhängepunkt nach Bedarf ändern, solange Sie
den NAME unverändert lassen.
</p><p>Sie sollten eine Option für jede Datenfestplatte im Array verwenden.
</p><p>Sie können eine Festplatte später umbenennen, indem Sie den NAME
direkt in der Konfigurationsdatei ändern und dann einen <b>sync</b>-Befehl
ausführen. Im Falle einer Umbenennung erfolgt die Zuordnung
mithilfe der gespeicherten UUID der Festplatten.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-6" class="manual-title-level-2">
nohidden
</h2>
<p>Schließt alle versteckten Dateien und Verzeichnisse aus.
Unter Unix sind versteckte Dateien solche, die mit <b>.</b> beginnen.
Unter Windows sind es solche mit dem versteckten Attribut.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-7" class="manual-title-level-2">
exclude/include PATTERN
</h2>
<p>Definiert die Datei- oder Verzeichnismuster, die im <b>sync</b>-Vorgang
ausgeschlossen oder eingeschlossen werden sollen.
Alle Muster werden in der angegebenen Reihenfolge verarbeitet.
</p><p>Wenn das erste übereinstimmende Muster ein <b>exclude</b>-Muster ist,
wird die Datei ausgeschlossen. Wenn es ein <b>include</b>-Muster ist,
wird die Datei eingeschlossen. Wenn kein Muster übereinstimmt,
wird die Datei ausgeschlossen, wenn das zuletzt angegebene Muster
ein <b>include</b> ist, oder eingeschlossen, wenn das zuletzt angegebene
Muster ein <b>exclude</b> ist.
</p><p>Weitere Details zu Musterspezifikationen finden Sie im Abschnitt
PATTERN.
</p><p>Diese Option kann mehrmals verwendet werden.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-8" class="manual-title-level-2">
blocksize SIZE_IN_KIBIBYTES
</h2>
<p>Definiert die grundlegende Blockgröße in Kibibytes für die Parität.
Ein Kibibyte entspricht 1024 Bytes.
</p><p>Die Standard-Blockgröße ist 256, was für die meisten Fälle
ausreichen sollte.
</p><p>WARNUNG! Diese Option ist nur für Experten gedacht, und es wird
dringend empfohlen, diesen Wert nicht zu ändern. Um diesen Wert
zukünftig zu ändern, müssen Sie die gesamte Parität neu erstellen!
</p><p>Ein Grund für die Verwendung einer anderen Blockgröße ist, wenn Sie
viele kleine Dateien in der Größenordnung von Millionen haben.
</p><p>Für jede Datei, auch wenn sie nur wenige Bytes groß ist, wird ein
ganzer Block Parität zugewiesen, und bei vielen Dateien kann dies
zu erheblichem ungenutztem Paritätsplatz führen. Wenn Sie die
Paritätsfestplatte vollständig füllen, dürfen Sie keine weiteren
Dateien zu den Datenfestplatten hinzufügen.
Der verschwendete Paritätsplatz akkumuliert sich jedoch nicht über
die Datenfestplatten hinweg. Verschwendeter Platz, der durch eine
hohe Anzahl von Dateien auf einer Datenfestplatte entsteht, begrenzt
nur die Datenmenge auf dieser Datenfestplatte, nicht auf anderen.
</p><p>Als Annäherung können Sie davon ausgehen, dass die Hälfte der
Blockgröße für jede Datei verschwendet wird. Mit beispielsweise
100.000 Dateien und einer Blockgröße von 256 KiB verschwenden
Sie 12,8 GB Parität, was zu 12,8 GB weniger verfügbarem Speicherplatz
auf der Datenfestplatte führen kann.
</p><p>Sie können die Menge des verschwendeten Platzes auf jeder Festplatte
mithilfe von <b>status</b> überprüfen. Dies ist die Menge an Platz, die Sie
auf den Datenfestplatten freilassen oder für Dateien verwenden müssen,
die nicht im Array enthalten sind. Wenn dieser Wert negativ ist,
bedeutet dies, dass Sie kurz davor sind, die Parität zu füllen,
und er stellt den Platz dar, den Sie noch verschwenden können.
</p><p>Um dieses Problem zu vermeiden, können Sie eine größere Partition
für die Parität verwenden. Wenn die Paritätspartition beispielsweise
12,8 GB größer ist als die Datenfestplatten, haben Sie genügend
zusätzlichen Platz, um bis zu 100.000 Dateien auf jeder Datenfestplatte
ohne verschwendeten Platz zu verarbeiten.
</p><p>Ein Trick, um eine größere Paritätspartition unter Linux zu erhalten,
ist die Formatierung mit dem Befehl:
</p><pre>
mkfs.ext4 -m 0 -T largefile4 DEVICE
</pre>
<p>Dies führt zu etwa 1,5% zusätzlichem Speicherplatz, ungefähr 60 GB
für eine 4 TB Festplatte, was etwa 460.000 Dateien auf jeder
Datenfestplatte ohne verschwendeten Platz ermöglicht.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-9" class="manual-title-level-2">
hashsize SIZE_IN_BYTES
</h2>
<p>Definiert die Hash-Größe in Bytes für die gespeicherten Blöcke.
</p><p>Die Standard-Hash-Größe beträgt 16 Bytes (128 Bit), was für die
meisten Fälle ausreichen sollte.
</p><p>WARNUNG! Diese Option ist nur für Experten gedacht, und es wird
dringend empfohlen, diesen Wert nicht zu ändern. Um diesen Wert
zukünftig zu ändern, müssen Sie die gesamte Parität neu erstellen!
</p><p>Ein Grund für die Verwendung einer anderen Hash-Größe ist, wenn Ihr
System über begrenzten Speicher verfügt. Als Faustregel benötigt
SnapRAID typischerweise 1 GiB RAM für jede 16 TB Daten im Array.
</p><p>Genauer gesagt benötigt SnapRAID zum Speichern der Hashes der Daten
ungefähr TS*(1+HS)/BS Bytes RAM,
wobei TS die Gesamtgröße in Bytes Ihres Festplatten-Arrays ist,
BS die Blockgröße in Bytes und HS die Hash-Größe in Bytes.
</p><p>Mit beispielsweise 8 Festplatten à 4 TB, einer Blockgröße von 256 KiB
(1 KiB = 1024 Bytes) und einer Hash-Größe von 16 erhalten Sie:
</p><pre>
RAM = (8 * 4 * 10^12) * (1+16) / (256 * 2^10) = 1.93 GiB
</pre>
<p>Bei einem Wechsel zu einer Hash-Größe von 8 erhalten Sie:
</p><pre>
RAM = (8 * 4 * 10^12) * (1+8) / (256 * 2^10) = 1.02 GiB
</pre>
<p>Bei einem Wechsel zu einer Blockgröße von 512 erhalten Sie:
</p><pre>
RAM = (8 * 4 * 10^12) * (1+16) / (512 * 2^10) = 0.96 GiB
</pre>
<p>Bei einem Wechsel zu einer Hash-Größe von 8 und einer Blockgröße
von 512 erhalten Sie:
</p><pre>
RAM = (8 * 4 * 10^12) * (1+8) / (512 * 2^10) = 0.51 GiB
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-10" class="manual-title-level-2">
autosave SIZE_IN_GIGABYTES
</h2>
<p>Speichert den Zustand beim Synchronisieren oder Scrubben automatisch
nach der angegebenen Menge an verarbeiteten GB.
Diese Option ist nützlich, um zu vermeiden, dass lange <b>sync</b>-Befehle
von vorne gestartet werden müssen, wenn sie durch einen Maschinenabsturz
oder ein anderes Ereignis unterbrochen werden.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-11" class="manual-title-level-2">
temp_limit TEMPERATURE_CELSIUS
</h2>
<p>Legt die maximal zulässige Festplattentemperatur in Celsius fest.
Wenn angegeben, überprüft SnapRAID regelmäßig die Temperatur aller
Festplatten mithilfe des smartctl-Tools. Die aktuellen Festplattentemperaturen
werden während des Betriebs von SnapRAID angezeigt. Wenn eine Festplatte
diesen Grenzwert überschreitet, werden alle Vorgänge gestoppt, und
die Festplatten werden für die durch die Option <b>temp_sleep</b> definierte
Dauer heruntergefahren (in den Standby-Modus versetzt). Nach der
Schlafperiode werden die Vorgänge fortgesetzt und möglicherweise
erneut pausiert, wenn der Temperaturgrenzwert erneut erreicht wird.
</p><p>Während des Betriebs analysiert SnapRAID auch die Heizkurve jeder
Festplatte und schätzt die langfristige stationäre Temperatur, die
erwartet wird, wenn die Aktivität fortgesetzt wird. Die Schätzung
wird nur durchgeführt, nachdem die Festplattentemperatur viermal
angestiegen ist, um sicherzustellen, dass genügend Datenpunkte
zur Verfügung stehen, um einen zuverlässigen Trend festzustellen.
Diese vorhergesagte stationäre Temperatur wird in Klammern neben
dem aktuellen Wert angezeigt und hilft bei der Beurteilung, ob die
Kühlung des Systems ausreichend ist. Diese geschätzte Temperatur
dient nur zu Informationszwecken und hat keine Auswirkung auf das
Verhalten von SnapRAID. Die Aktionen des Programms basieren
ausschließlich auf den tatsächlich gemessenen Festplattentemperaturen.
</p><p>Um diese Analyse durchzuführen, benötigt SnapRAID eine Referenz für
die Systemtemperatur. Es versucht zunächst, diese von verfügbaren
Hardwaresensoren zu lesen. Wenn kein Systemsensor zugänglich ist,
wird die niedrigste zu Beginn des Laufs gemessene Festplattentemperatur
als Fallback-Referenz verwendet.
</p><p>Normalerweise zeigt SnapRAID nur die Temperatur der heißesten
Festplatte an. Um die Temperatur aller Festplatten anzuzeigen,
verwenden Sie die Option -A oder --stats.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-12" class="manual-title-level-2">
temp_sleep TIME_IN_MINUTES
</h2>
<p>Legt die Standby-Zeit in Minuten fest, wenn der Temperaturgrenzwert
erreicht wird. Während dieser Zeit bleiben die Festplatten heruntergefahren.
Der Standardwert ist 5 Minuten.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-13" class="manual-title-level-2">
pool DIR
</h2>
<p>Definiert das Pooling-Verzeichnis, in dem die virtuelle Ansicht des
Festplatten-Arrays mithilfe des Befehls <b>pool</b> erstellt wird.
</p><p>Das Verzeichnis muss bereits existieren.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-14" class="manual-title-level-2">
share UNC_DIR
</h2>
<p>Definiert den Windows UNC-Pfad, der für den Remote-Zugriff auf die
Festplatten erforderlich ist.
</p><p>Wenn diese Option angegeben ist, verwenden die im Pool-Verzeichnis
erstellten symbolischen Links diesen UNC-Pfad, um auf die Festplatten
zuzugreifen. Ohne diese Option verwenden die generierten symbolischen
Links nur lokale Pfade, was die Freigabe des Pool-Verzeichnisses
über das Netzwerk nicht ermöglicht.
</p><p>Die symbolischen Links werden unter Verwendung des angegebenen UNC-Pfads
gebildet, wobei der in der <b>data</b>-Option angegebene Festplattenname
und schließlich das Dateiverzeichnis und der Name hinzugefügt werden.
</p><p>Diese Option ist nur für Windows erforderlich.
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-15" class="manual-title-level-2">
smartctl DISK/PARITY OPTIONS...
</h2>
<p>Definiert benutzerdefinierte smartctl-Optionen, um die SMART-Attribute
für jede Festplatte abzurufen. Dies kann für RAID-Controller und einige
USB-Festplatten erforderlich sein, die nicht automatisch erkannt
werden können. Der Platzhalter %s wird durch den Gerätenamen ersetzt,
ist aber für feste Geräte wie RAID-Controller optional.
</p><p>DISK ist derselbe Festplattenname, der in der <b>data</b>-Option angegeben
ist. PARITY ist einer der Paritätsnamen: <b>parity</b>, <b>2-parity</b>,
<b>3-parity</b>, <b>4-parity</b>, <b>5-parity</b>, <b>6-parity</b> oder <b>z-parity</b>.
</p><p>In den angegebenen OPTIONS wird die Zeichenfolge <b>%s</b> durch den
Gerätenamen ersetzt. Bei RAID-Controllern ist das Gerät
wahrscheinlich fest, und Sie müssen <b>%s</b> möglicherweise nicht verwenden.
</p><p>Weitere mögliche Optionen finden Sie in der smartmontools-Dokumentation:
</p><pre>
<a href="https://www.smartmontools.org/wiki/Supported_RAID-Controllers">https://www.smartmontools.org/wiki/Supported_RAID-Controllers</a>
<a href="https://www.smartmontools.org/wiki/Supported_USB-Devices">https://www.smartmontools.org/wiki/Supported_USB-Devices</a>
</pre>
<p>Zum Beispiel:
</p><pre>
smartctl parity -d sat %s
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-16" class="manual-title-level-2">
smartignore DISK/PARITY ATTR [ATTR...]
</h2>
<p>Ignoriert das angegebene SMART-Attribut bei der Berechnung der
Wahrscheinlichkeit eines Festplattenausfalls. Diese Option ist
nützlich, wenn eine Festplatte ungewöhnliche oder irreführende
Werte für ein bestimmtes Attribut meldet.
</p><p>DISK ist derselbe Festplattenname, der in der <b>data</b>-Option angegeben
ist. PARITY ist einer der Paritätsnamen: <b>parity</b>, <b>2-parity</b>,
<b>3-parity</b>, <b>4-parity</b>, <b>5-parity</b>, <b>6-parity</b> oder <b>z-parity</b>.
Der Sonderwert * kann verwendet werden, um das Attribut auf allen
Festplatten zu ignorieren.
</p><p>Um beispielsweise das Attribut <b>Current Pending Sector Count</b> auf allen
Festplatten zu ignorieren:
</p><pre>
smartignore * 197
</pre>
<p>Um es nur auf der ersten Paritätsfestplatte zu ignorieren:
</p><pre>
smartignore parity 197
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-17" class="manual-title-level-2">
Examples
</h2>
<p>Ein Beispiel für eine typische Konfiguration für Unix ist:
</p><pre>
parity /mnt/diskp/snapraid.parity
content /mnt/diskp/snapraid.content
content /var/snapraid/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
exclude /lost+found/
exclude /tmp/
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/sg0
smartctl 2-parity -d areca,2/1 /dev/sg0
</pre>
<p>Ein Beispiel für eine typische Konfiguration für Windows ist:
</p><pre>
parity E:\snapraid.parity
content E:\snapraid.content
content C:\snapraid\snapraid.content
data d1 G:\array\
data d2 H:\array\
data d3 I:\array\
exclude Thumbs.db
exclude \$RECYCLE.BIN
exclude \System Volume Information
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/arcmsr0
smartctl 2-parity -d areca,2/1 /dev/arcmsr0
</pre>
</div>
</div>
<div class="manual-section-level-1">
<h1 id="sec8" class="manual-title-level-1">
Pattern
</h1>
<p>Muster bieten eine flexible Möglichkeit, Dateien für die Einbeziehung oder
den Ausschluss zu filtern. Durch die Verwendung von Globbing-Zeichen können Sie Regeln definieren,
die mit bestimmten Dateinamen oder ganzen Verzeichnisstrukturen übereinstimmen, ohne
jeden Pfad manuell auflisten zu müssen.
</p><p>Das Fragezeichen <b>?</b> entspricht einem beliebigen einzelnen Zeichen außer dem
Verzeichnistrennzeichen. Dies macht es nützlich für den Abgleich von Dateinamen mit variablen
Zeichen, während das Muster auf eine einzelne Verzeichnisebene beschränkt bleibt.
</p><p>Der einfache Stern <b>*</b> entspricht einer beliebigen Folge von Zeichen, aber wie das
Fragezeichen überschreitet er niemals Verzeichnisgrenzen. Er stoppt beim
Schrägstrich, was ihn für den Abgleich innerhalb einer einzelnen Pfadkomponente
geeignet macht. Dies ist das Standardverhalten von Wildcards, das vom Shell-
Globbing bekannt ist.
</p><p>Der Doppelstern <b>**</b> ist mächtiger; er entspricht jeder Folge von
Zeichen einschließlich Verzeichnistrennzeichen. Dies ermöglicht es Mustern, über
mehrere Verzeichnisebenen hinweg übereinzustimmen. Wenn <b>**</b> direkt in
ein Muster eingebettet ist, kann es null oder mehr Zeichen einschließlich Schrägstrichen zwischen
dem umgebenden wörtlichen Text entsprechen.
</p><p>Die wichtigste Verwendung von <b>**</b> ist in der speziellen Form <b>/**/</b>. Dies entspricht
null oder mehr vollständigen Verzeichnisebenen, was es möglich macht, Dateien
in jeder Tiefe eines Verzeichnisbaums abzugleichen, ohne die genaue Pfadstruktur zu kennen.
Zum Beispiel entspricht das Muster <b>src/**/main.js</b> dem Pfad <b>src/main.js</b> (Überspringen
von null Verzeichnissen), <b>src/ui/main.js</b> (Überspringen eines Verzeichnisses) und
<b>src/ui/components/main.js</b> (Überspringen von zwei Verzeichnissen).
</p><p>Zeichenklassen mit eckigen Klammern <b>[]</b> entsprechen einem einzelnen Zeichen aus einer
bestimmten Menge oder einem Bereich. Wie die anderen Einzelzeichenmuster
entsprechen sie nicht den Verzeichnistrennzeichen. Klassen unterstützen Bereiche und Negierung durch
ein Ausrufezeichen.
</p><p>Der grundlegende Unterschied, den man sich merken sollte, ist, dass <b>*</b>, <b>?</b> und Zeichenklassen
alle Verzeichnisgrenzen respektieren und nur innerhalb einer einzelnen Pfadkomponente
übereinstimmen, während <b>**</b> das einzige Muster ist, das über Verzeichnistrennzeichen
hinweg übereinstimmen kann.
</p><p>Es gibt vier verschiedene Arten von Mustern:
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
FILE
</div><div class="manual-option-description">
Wählt jede Datei mit dem Namen FILE aus.
Dieses Muster gilt nur für Dateien, nicht für Verzeichnisse.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
DIR/
</div><div class="manual-option-description">
Wählt jedes Verzeichnis mit dem Namen DIR und alles darin aus.
Dieses Muster gilt nur für Verzeichnisse, nicht für Dateien.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/FILE
</div><div class="manual-option-description">
Wählt den exakt angegebenen Dateipfad aus. Dieses Muster gilt
nur für Dateien, nicht für Verzeichnisse.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/DIR/
</div><div class="manual-option-description">
Wählt den exakt angegebenen Verzeichnispfad und alles darin aus.
Dieses Muster gilt nur für Verzeichnisse, nicht für Dateien.
</div>
</div>
</div>
<p>Wenn Sie einen absoluten Pfad angeben, der mit / beginnt, wird er
auf das Array-Stammverzeichnis angewendet, nicht auf das lokale
Dateisystem-Stammverzeichnis.
</p><p>Unter Windows können Sie den Backslash \ anstelle des Forward-Slash /
verwenden. Windows-Systemverzeichnisse, Junctions, Einhängepunkte
(Mount Points) und andere spezielle Windows-Verzeichnisse werden
als Dateien behandelt, was bedeutet, dass Sie zum Ausschließen
eine Dateiregel verwenden müssen, nicht eine Verzeichnisregel.
</p><p>Wenn der Dateiname ein Zeichen <b>*</b>, <b>?</b>, <b>[</b>, oder <b>]</b> enthält,
müssen Sie es escapen, um zu vermeiden, dass es als Globbing-Zeichen
interpretiert wird. Unter Unix ist das Escape-Zeichen <b>\</b>; unter
Windows ist es <b>^</b>. Wenn sich das Muster in der Befehlszeile befindet,
müssen Sie das Escape-Zeichen verdoppeln, um zu vermeiden, dass es
von der Befehlsshell interpretiert wird.
</p><p>In der Konfigurationsdatei können Sie verschiedene Strategien zum
Filtern der zu verarbeitenden Dateien verwenden.
Der einfachste Ansatz besteht darin, nur <b>exclude</b>-Regeln zu verwenden,
um alle Dateien und Verzeichnisse zu entfernen, die Sie nicht
verarbeiten möchten. Zum Beispiel:
</p><pre>
# Schließt jede Datei namens <b>*.unrecoverable</b> aus
exclude *.unrecoverable
# Schließt das Stammverzeichnis <b>/lost+found</b> aus
exclude /lost+found/
# Schließt jedes Unterverzeichnis namens <b>tmp</b> aus
exclude tmp/
</pre>
<p>Der gegenteilige Ansatz besteht darin, nur die Dateien zu definieren,
die Sie verarbeiten möchten, indem Sie nur <b>include</b>-Regeln verwenden.
Zum Beispiel:
</p><pre>
# Schließt nur einige Verzeichnisse ein
include /movies/
include /musics/
include /pictures/
</pre>
<p>Der letzte Ansatz besteht darin, <b>exclude</b>- und <b>include</b>-Regeln
zu mischen. In diesem Fall ist die Reihenfolge der Regeln wichtig.
Frühere Regeln haben Vorrang vor späteren.
Zur Vereinfachung können Sie zuerst alle <b>exclude</b>-Regeln und
dann alle <b>include</b>-Regeln auflisten. Zum Beispiel:
</p><pre>
# Schließt jede Datei namens <b>*.unrecoverable</b> aus
exclude *.unrecoverable
# Schließt jedes Unterverzeichnis namens <b>tmp</b> aus
exclude tmp/
# Schließt nur einige Verzeichnisse ein
include /movies/
include /musics/
include /pictures/
</pre>
<p>In der Befehlszeile können Sie mit der Option -f nur <b>include</b>-Muster
verwenden. Zum Beispiel:
</p><pre>
# Überprüft nur die .mp3-Dateien.
# Unter Unix Anführungszeichen verwenden, um die Globbing-Erweiterung durch die Shell zu vermeiden.
snapraid -f "*.mp3" check
</pre>
<p>Unter Unix müssen Sie Globbing-Zeichen in der Befehlszeile in
Anführungszeichen setzen, um zu verhindern, dass die Shell sie erweitert.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec9" class="manual-title-level-1">
Dateien Ignorieren
</h1>
<p>Zusätzlich zu den globalen Regeln in der Konfigurationsdatei können Sie
<b>.snapraidignore</b>-Dateien in jedem Verzeichnis innerhalb des Arrays platzieren,
um dezentrale Ausschlussregeln zu definieren.
</p><p>Regeln, die in <b>.snapraidignore</b> definiert sind, werden nach den Regeln in der
Konfigurationsdatei angewendet. Dies bedeutet, dass sie eine höhere Priorität haben
und verwendet werden können, um Dateien auszuschließen, die zuvor durch die globale
Konfiguration eingeschlossen wurden. Effektiv wird eine Datei ausgeschlossen, wenn
eine lokale Regel zutrifft, unabhängig von den globalen Include-Einstellungen.
</p><p>Die Musterlogik in <b>.snapraidignore</b> spiegelt die globale Konfiguration wider,
verankert die Muster jedoch an dem Verzeichnis, in dem sich die Datei befindet:
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
FILE
</div><div class="manual-option-description">
Wählt jede Datei namens FILE in diesem Verzeichnis oder darunter aus.
Dies folgt denselben Globbing-Regeln wie das globale Muster.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
DIR/
</div><div class="manual-option-description">
Wählt jedes Verzeichnis namens DIR und alles darin aus, das sich
in diesem Verzeichnis oder darunter befindet.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/FILE
</div><div class="manual-option-description">
Wählt die exakt angegebene Datei relativ zum Speicherort
der <b>.snapraidignore</b>-Datei aus.
</div>
</div>
</div>
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/DIR/
</div><div class="manual-option-description">
Wählt das exakt angegebene Verzeichnis und alles darin aus,
relativ zum Speicherort der <b>.snapraidignore</b>-Datei.
</div>
</div>
</div>
<p>Im Gegensatz zur globalen Konfiguration unterstützen <b>.snapraidignore</b>-Dateien nur
Ausschlussregeln; Sie können keine <b>include</b>-Muster oder Negationen (!) verwenden.
</p><p>Wenn Sie beispielsweise eine <b>.snapraidignore</b> in <b>/mnt/disk1/projects/</b> haben:
</p><pre>
# Schließt NUR /mnt/disk1/projects/output.bin aus
/output.bin
# Schließt jedes Verzeichnis namens <b>build</b> innerhalb von projects/ aus
build/
# Schließt jede .tmp-Datei innerhalb von projects/ oder deren Unterordnern aus
*.tmp
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec10" class="manual-title-level-1">
Content
</h1>
<p>SnapRAID speichert die Liste und Prüfsummen Ihrer Dateien in der
Content-Datei.
</p><p>Es ist eine Binärdatei, die alle im Festplatten-Array vorhandenen
Dateien auflistet, zusammen mit allen Prüfsummen zur Überprüfung
ihrer Integrität.
</p><p>Diese Datei wird von den Befehlen <b>sync</b> und <b>scrub</b> gelesen und
geschrieben und von den Befehlen <b>fix</b>, <b>check</b> und <b>status</b> gelesen.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec11" class="manual-title-level-1">
Parity
</h1>
<p>SnapRAID speichert die Paritätsinformationen Ihres Arrays in den
Paritätsdateien.
</p><p>Dies sind Binärdateien, die die berechnete Parität aller in der
<b>content</b>-Datei definierten Blöcke enthalten.
</p><p>Diese Dateien werden von den Befehlen <b>sync</b> und <b>fix</b> gelesen
und geschrieben und nur von den Befehlen <b>scrub</b> und <b>check</b> gelesen.
</p></div>
<div class="manual-section-level-1">
<h1 id="sec12" class="manual-title-level-1">
Encoding
</h1>
<p>SnapRAID ignoriert unter Unix jede Kodierung. Es liest und speichert
die Dateinamen mit derselben Kodierung, die vom Dateisystem
verwendet wird.
</p><p>Unter Windows werden alle vom Dateisystem gelesenen Namen konvertiert
und im UTF-8-Format verarbeitet.
</p><p>Um Dateinamen korrekt auszugeben, müssen Sie die Windows-Konsole
mit dem Befehl <b>chcp 65001</b> auf den UTF-8-Modus einstellen und
eine TrueType-Schriftart wie <b>Lucida Console</b> als Konsolenschriftart
verwenden. Dies betrifft nur die gedruckten Dateinamen; wenn Sie
die Konsolenausgabe in eine Datei umleiten, ist die resultierende
Datei immer im UTF-8-Format.
</p></div>


            </div>
        </main>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container footer-content">
            <div class="footer-col">
                <h3>SnapRAID</h3>
                <p>Copyright &copy; 2026 Andrea Mazzoleni</p>
                <p class="license">Distributed under GPL v3 License</p>
            </div>
            <div class="footer-col">
                <h4>Community</h4>
                <ul>
                    <li><a href="https://www.reddit.com/r/Snapraid/">Reddit r/snapraid</a></li>
                    <li><a href="https://sourceforge.net/p/snapraid/discussion/1677233/">SourceForge Forum</a></li>
                    <li><a href="https://github.com/amadvance/snapraid/">GitHub</a></li>
                </ul>
            </div>
        </div>
    </footer>
</body>
</html>


