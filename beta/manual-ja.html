<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A backup program for disk arrays. It stores parity information of your data and it recovers from up to six disk failures">
    <meta name="keywords" content="snapraid snapshot raid backup disk array redundancy parity">    
    <title>SnapRAID CLI Manual</title>
    <style>html,body{background-color:#020617;color:#f8fafc;}</style>
    <link rel="stylesheet" href="style.css">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">    
    <script src="script.js"></script>

<!-- Google Analytics 4 -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W1Z5FKHYQ4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-W1Z5FKHYQ4');
</script>

<!-- Google Universal Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body>
    <header>
        <div class="container nav-container">
            <a href="index" class="logo">
                <img src="favicon-32x32.png"/>
                SnapRAID
            </a>
            <nav>
                <input type="checkbox" id="menu-toggle">
                <label for="menu-toggle" class="menu-icon"><svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></label>
                <ul>
                    <li><a href="index" >Home</a></li>
                    <li><a href="ui" >UI & Daemon</a></li>
                    <li><a href="howitworks" >How it Works</a></li>
                    <li><a href="design" >Design</a></li>
                    <li><a href="compare" >Compare</a></li>
                    <li><a href="manual" class="active">Manual</a></li>
                    <li><a href="faq" >FAQ</a></li>
                    <li><a href="support" >Support</a></li>
                    <li><a href="download" class="nav-cta">Download</a></li>
                </ul>
            </nav>
        </div>
    </header>


    <div class="container manual-layout">

        <aside class="manual-sidebar">

            <h4>Component</h4>
            <select id="manual-selector" style="width: 100%; padding: 5px; background: var(--bg-surface); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; margin-bottom: 2rem;">
                <option value="manual.html">Command Line</option>
                <option value="manual-daemon.html">Daemon</option>
                <option value="manual-log.html">Log</option>
            </select>

            <h4>Languages</h4>
            <select id="language-selector" style="width: 100%; padding: 5px; background: var(--bg-surface); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; margin-bottom: 2rem;">
                <option value="manual">English</option>
                <option value="manual-de">German</option>
                <option value="manual-es">Spanish</option>
                <option value="manual-fr">French</option>
                <option value="manual-it">Italian</option>
                <option value="manual-ja">Japanse</option>
                <option value="manual-ko">Korean</option>
                <option value="manual-pl">Polish</option>
                <option value="manual-pt">Portuguese</option>
                <option value="manual-ro">Romanian</option>
                <option value="manual-ru">Russian</option>
                <option value="manual-sv">Swedish</option>
                <option value="manual-uk">Ukranian</option>
                <option value="manual-zh">Simplified Chinese</option>.

            </select>

            <h4>Contents</h4>
            <ul id="manual-toc-list">
                <!-- Populated by JavaScript -->
            </ul>
        </aside>


        <main id="manual-container">
            
            <div class="manual-doc">

<div class="manual-section-level-1">
<h1 id="sec1" class="manual-title-level-1">
Synopsis
</h1>
<pre>
snapraid [-c, --conf CONFIG]
&nbsp;&nbsp;&nbsp;&nbsp;[-f, --filter PATTERN] [-d, --filter-disk NAME]
&nbsp;&nbsp;&nbsp;&nbsp;[-m, --filter-missing] [-e, --filter-error]
&nbsp;&nbsp;&nbsp;&nbsp;[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR]
&nbsp;&nbsp;&nbsp;&nbsp;[-p, --plan PERC|bad|new|full]
&nbsp;&nbsp;&nbsp;&nbsp;[-o, --older-than DAYS] [-l, --log FILE]
&nbsp;&nbsp;&nbsp;&nbsp;[-s, --spin-down-on-error] [-w, --bw-limit RATE]
&nbsp;&nbsp;&nbsp;&nbsp;[-Z, --force-zero] [-E, --force-empty]
&nbsp;&nbsp;&nbsp;&nbsp;[-U, --force-uuid] [-D, --force-device]
&nbsp;&nbsp;&nbsp;&nbsp;[-N, --force-nocopy] [-F, --force-full]
&nbsp;&nbsp;&nbsp;&nbsp;[-R, --force-realloc]
&nbsp;&nbsp;&nbsp;&nbsp;[-S, --start BLKSTART] [-B, --count BLKCOUNT]
&nbsp;&nbsp;&nbsp;&nbsp;[-L, --error-limit NUMBER]
&nbsp;&nbsp;&nbsp;&nbsp;[-A, --stats]
&nbsp;&nbsp;&nbsp;&nbsp;[-v, --verbose] [-q, --quiet]
&nbsp;&nbsp;&nbsp;&nbsp;status|smart|probe|up|down|diff|sync|scrub|fix|check
&nbsp;&nbsp;&nbsp;&nbsp;|list|dup|pool|devices|touch|rehash
</pre>
<pre>
snapraid [-V, --version] [-H, --help] [-C, --gen-conf CONTENT]
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec2" class="manual-title-level-1">
Description
</h1>
<p>SnapRAIDは、ディスクアレイ用のバックアッププログラムで、最大6台のディスク障害が発生した場合の
データ復旧のためにパリティ情報を保存します。
</p><p>主に大容量で、更新頻度の低いファイルを扱うホームメディアセンターを対象としており、
SnapRAIDにはいくつかの機能があります。
</p><ul>
<li>
ファイルが既に入っているディスクを、再フォーマットせずにそのまま利用でき、通常通り
アクセスできます。
</li>
<li>
すべてのデータがハッシュ化され、データの整合性を確保し、サイレントな破損を防ぎます。
</li>
<li>
障害が発生したディスクの数がパリティ数を超えた場合、データの損失は影響を受けたディスクに
限定され、他のディスクのデータは引き続きアクセス可能です。
</li>
<li>
誤ってディスク上のファイルを削除した場合でも、復旧が可能です。
</li>
<li>
ディスクは異なるサイズであっても構いません。
</li>
<li>
いつでもディスクを追加できます。
</li>
<li>
SnapRAIDはデータをロックしません。いつでも再フォーマットやデータ移動なしに利用を
停止できます。
</li>
<li>
ファイルにアクセスするためにスピンさせる必要があるのは1台のディスクだけであり、
省電力と騒音低減に役立ちます。
</li>
</ul>
<p>詳細については、SnapRAIDの公式サイトをご覧ください。
</p><pre>
https://www.snapraid.it/
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec3" class="manual-title-level-1">
Limitations
</h1>
<p>SnapRAIDはRAIDとバックアッププログラムのハイブリッドであり、両方の利点を組み合わせることを
目指しています。ただし、使用する前に考慮すべきいくつかの制限があります。
</p><p>主な制限は、ディスクが故障し、最近 `sync` を実行していない場合、完全に復旧できない
可能性があることです。
より具体的には、最後の `sync` 操作以降に変更または削除されたファイルのサイズまでのデータが
復旧できない可能性があります。
これは、変更または削除されたファイルが故障したディスク上にない場合でも発生します。
このため、SnapRAIDは**めったに変更されない**データに適しています。
</p><p>一方で、新しく追加されたファイルは、既に存在するファイルの復旧を妨げません。
新しく追加されたファイルが故障したディスク上にある場合にのみ、それらのファイルが失われます。
</p><p>その他のSnapRAIDの制限は次のとおりです。
</p><ul>
<li>
SnapRAIDでは、各ディスクに対して**個別のファイルシステム**が保持されます。
RAIDでは、単一の大きなファイルシステムが得られます。
</li>
<li>
SnapRAIDは**データをストライピングしません**。
RAIDでは、ストライピングにより速度が向上します。
</li>
<li>
SnapRAIDは**リアルタイムの復旧をサポートしません**。
RAIDでは、ディスクが故障しても作業を停止する必要はありません。
</li>
<li>
SnapRAIDは**限られた数のディスク障害**からのみデータを復旧できます。
バックアップでは、ディスクアレイ全体の完全な障害から復旧できます。
</li>
<li>
**ファイル名、タイムスタンプ、シンボリックリンク、およびハードリンク**のみが保存されます。
アクセス許可、所有権、および拡張属性は保存されません。
</li>
</ul>
</div>
<div class="manual-section-level-1">
<h1 id="sec4" class="manual-title-level-1">
Getting Started
</h1>
<p>SnapRAIDを使用するには、まずディスクアレイ内の1つのディスクを `parity` 情報専用に
選択する必要があります。パリティ用に1つのディスクを使用すると、RAID5と同様に、単一のディスク障害から
復旧できます。
</p><p>RAID6と同様に、より多くのディスク障害から復旧したい場合は、パリティ用に追加のディスクを
確保する必要があります。パリティディスクを追加するたびに、復旧できるディスク障害が1つ増えます。
</p><p>パリティ情報はアレイ内の**最大のデータディスク**のサイズにまで増える可能性があるため、
パリティディスクとしては、アレイ内の**最大のディスク**を選択する必要があります。
</p><p>これらのディスクは、`parity` ファイルの保存専用になります。
**データを保存しないでください**。
</p><p>次に、SnapRAIDで保護したい `data` ディスクを定義する必要があります。
これらのディスクに含まれるデータがめったに変更されない場合に、保護が最も効果的です。
このため、WindowsのC:\ディスクやUnixの/home、/var、/tmpディレクトリを含めない方が
良いでしょう。
</p><p>ファイルの一覧は `content` ファイルに保存され、通常はデータ、パリティ、または
ブートディスクに保存されます。
このファイルには、バックアップの詳細と、その整合性を検証するためのすべての
チェックサムが含まれています。
`content` ファイルは**複数のコピー**で保存され、複数のディスク障害が発生した場合でも、
少なくとも1つのコピーが利用可能であることを保証するために、**各コピーは異なるディスクに**
配置する必要があります。
</p><p>たとえば、1レベルのパリティ保護のみに関心があり、ディスクが次の場所にあるとします。
</p><pre>
/mnt/diskp &lt;- パリティ用に選択されたディスク
/mnt/disk1 &lt;- 保護する最初のディスク
/mnt/disk2 &lt;- 保護する2番目のディスク
/mnt/disk3 &lt;- 保護する3番目のディスク
</pre>
<p>構成ファイル `/etc/snapraid.conf` を次のオプションで作成する必要があります。
</p><pre>
parity /mnt/diskp/snapraid.parity
content /var/snapraid/snapraid.content
content /mnt/disk1/snapraid.content
content /mnt/disk2/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
</pre>
<p>Windowsを使用している場合は、スラッシュではなくドライブ文字とバックスラッシュを
使用したWindowsのパス形式を使用する必要があります。
</p><pre>
parity E:\snapraid.parity
content C:\snapraid\snapraid.content
content F:\array\snapraid.content
content G:\array\snapraid.content
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
</pre>
<p>ディスクが多くてドライブ文字が不足する場合は、サブフォルダにディスクを
直接マウントできます。参照：
</p><pre>
https://www.google.com/search?q=Windows+mount+point
</pre>
<p>この時点で、パリティ情報を構築するために `sync` コマンドを実行する準備が整いました。
</p><pre>
snapraid sync
</pre>
<p>このプロセスは、既にディスクに存在するデータのサイズに応じて、初回は数時間かかる
場合があります。ディスクが空の場合は、プロセスは即座に完了します。
</p><p>Ctrl+Cを押すことでいつでも停止でき、次回の実行時には中断された場所から再開されます。
</p><p>このコマンドが完了すると、データは**SAFE**になります。
</p><p>これで、アレイを自由に使い始め、定期的に `sync` コマンドを実行してパリティ情報を
更新できます。
</p><div class="manual-section-level-2">
<h2 id="sec4-1" class="manual-title-level-2">
Scrubbing
</h2>
<p>データとパリティのエラーを定期的にチェックするには、`scrub` コマンドを
実行できます。
</p><pre>
snapraid scrub
</pre>
<p>このコマンドは、配列内のデータを `sync` コマンド中に計算されたハッシュと比較して、
整合性を検証します。
</p><p>このコマンドを1回実行すると、前回の10日間で既にスクラブされたデータを除いて、
アレイの約8%がチェックされます。
-p, --plan オプションを使用して異なる量を指定でき、
-o, --older-than オプションを使用して異なる経過日数で
指定できます。
たとえば、20日以上経過したブロックの5%をチェックするには、次のように使用します。
</p><pre>
snapraid -p 5 -o 20 scrub
</pre>
<p>プロセス中にサイレントエラーまたは入出力エラーが見つかった場合、
対応するブロックは `content` ファイル内で不良としてマークされ、
`status` コマンドで一覧表示されます。
</p><pre>
snapraid status
</pre>
<p>それらを修正するには、-e, --filter-error オプションで不良ブロックをフィルタリングして、
`fix` コマンドを使用できます。
</p><pre>
snapraid -e fix
</pre>
<p>次回の `scrub` で、エラーが本当に修正されていれば、`status` レポートから
エラーは消えます。より高速にするために、`-p bad` を使用して不良としてマークされた
ブロックのみをスクラブできます。
</p><pre>
snapraid -p bad scrub
</pre>
<p>未同期のアレイで `scrub` を実行すると、削除または変更されたファイルによって
引き起こされたエラーが報告される場合があります。これらのエラーは `scrub` の
出力で報告されますが、関連するブロックは不良としてマークされません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec4-2" class="manual-title-level-2">
Pooling
</h2>
<p>注: ここで説明するプーリング機能は、**mergefs** ツールに取って代わられました。
mergefs は、SnapRAIDコミュニティのLinuxユーザーに推奨されるオプションです。
Mergefs は、複数のドライブを単一の統合されたマウントポイントにプールするための、
より柔軟で効率的な方法を提供し、シンボリックリンクに頼ることなくアレイ全体の
ファイルにシームレスにアクセスできます。これは、パリティ保護のためにSnapRAIDと
うまく統合されており、OpenMediaVault (OMV) やカスタムNAS構成などのセットアップで
一般的に使用されています。
</p><p>アレイ内のすべてのファイルを同じディレクトリツリーに表示させるには、
`pooling` 機能を有効にできます。これは、シンボリックリンクを使用して、
アレイ内のすべてのファイルの読み取り専用の仮想ビューを作成します。
</p><p>構成ファイルで `pooling` ディレクトリを次のように構成できます。
</p><pre>
pool /pool
</pre>
<p>または、Windowsの場合は、次のようにします。
</p><pre>
pool C:\pool
</pre>
<p>そして、`pool` コマンドを実行して仮想ビューを作成または更新します。
</p><pre>
snapraid pool
</pre>
<p>Unixプラットフォームを使用しており、このディレクトリをWindowsまたはUnixマシンに
ネットワーク経由で共有したい場合は、`/etc/samba/smb.conf` に次のオプションを
追加する必要があります。
</p><pre>
# smb.conf の global セクションで
unix extensions = no
</pre>
<pre>
# smb.conf の share セクションで
[pool]
comment = Pool
path = /pool
read only = yes
guest ok = yes
wide links = yes
follow symlinks = yes
</pre>
<p>Windowsでは、ネットワーク経由でシンボリックリンクを共有するには、クライアントが
それらをリモートで解決する必要があります。これを有効にするには、プールディレクトリを
共有することに加えて、構成ファイルで定義された**ディスク名**を共有ポイントとして
使用して、**すべてのディスクを個別に**共有する必要があります。また、リモートクライアントが
これらの共有ディスクにアクセスするために使用する必要があるWindows UNCパスを、
構成ファイルの `share` オプションで指定する必要があります。
</p><p>たとえば、`darkstar` という名前のサーバーで操作している場合、次のオプションを
使用できます。
</p><pre>
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
pool C:\pool
share \\darkstar
</pre>
<p>そして、次のディレクトリをネットワーク経由で共有します。
</p><pre>
\\darkstar\pool -&gt; C:\pool
\\darkstar\d1 -&gt; F:\array
\\darkstar\d2 -&gt; G:\array
\\darkstar\d3 -&gt; H:\array
</pre>
<p>これにより、リモートクライアントは `\\darkstar\pool` ですべてのファイルに
アクセスできるようになります。
</p><p>また、リモートクライアントがリモートシンボリックリンクへのアクセスを有効にするために、
次のコマンドで構成する必要がある場合もあります。
</p><pre>
fsutil behavior set SymlinkEvaluation L2L:1 R2R:1 L2R:1 R2L:1
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec4-3" class="manual-title-level-2">
Undeleting
</h2>
<p>SnapRAIDはRAIDシステムよりもバックアッププログラムのように機能し、
-f, --filter オプションを使用してファイルを以前の状態に復元または削除解除するために
使用できます。
</p><pre>
snapraid fix -f FILE
</pre>
<p>またはディレクトリの場合は：
</p><pre>
snapraid fix -f DIR/
</pre>
<p>また、-m, --filter-missing オプションを使用して、ディレクトリ内の**誤って削除されたファイルのみ**を
復旧するために使用することもできます。これにより、不足しているファイルのみが復元され、
他のファイルはすべてそのまま残されます。
</p><pre>
snapraid fix -m -f DIR/
</pre>
<p>または、すべてのドライブ上のすべての削除されたファイルを復旧するには：
</p><pre>
snapraid fix -m
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec4-4" class="manual-title-level-2">
Recovering
</h2>
<p>最悪の事態が発生し、1台以上のディスクを失いました！
</p><p>**パニックにならないでください！** 復旧できます！
</p><p>最初に行うべきことは、ディスクアレイへの**さらなる変更を避ける**ことです。
リモート接続、およびスケジュールされたSnapRAIDの夜間 `sync` や `scrub` を含む、
すべてのスケジュールされたプロセスを無効にしてください。
</p><p>次に、次の手順に進みます。
</p><div class="manual-section-level-3">
<h3 id="sec4-4-1" class="manual-title-level-3">
STEP 1 -&gt; Reconfigure
</h3>
<p>復旧のためにいくらかのスペースが必要です。理想的には追加の
予備ディスクですが、外部USBディスクやリモートディスクでも十分です。
</p><p>SnapRAIDの構成ファイルを変更して、故障したディスクの `data` または `parity`
オプションを、ファイルを復旧するための十分な空き容量のある場所に
向けます。
</p><p>たとえば、ディスク `d1` が故障した場合、次のように変更します。
</p><pre>
data d1 /mnt/disk1/
</pre>
<p>から：
</p><pre>
data d1 /mnt/new_spare_disk/
</pre>
<p>復旧するディスクがパリティディスクの場合は、適切な `parity` オプションを
更新します。
複数のディスクが故障している場合は、すべての構成オプションを更新します。
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-2" class="manual-title-level-3">
STEP 2 -&gt; Fix
</h3>
<p>ログを外部ファイルに保存して、`fix` コマンドを実行します。
</p><pre>
snapraid -d NAME -l fix.log fix
</pre>
<p>ここで NAME はディスクの名前であり、前の例では `d1` のようなものです。
復旧するディスクがパリティディスクの場合は、`parity`、`2-parity` などの
名前を使用します。
複数のディスクが故障している場合は、複数の `-d` オプションを使用して
すべてを指定します。
</p><p>このコマンドは時間がかかります。
</p><p>`fix.log` ファイルを保存するために数ギガバイトの空き容量があることを確認してください。
十分な空き容量のあるディスクから実行してください。
</p><p>これで、復旧可能なすべてのものが復旧されました。一部のファイルが部分的または完全に
復旧できない場合、それらは `.unrecoverable` 拡張子を追加して名前が変更されます。
</p><p>`fix.log` ファイルで、`unrecoverable:` で始まるすべての行をチェックすることで、
すべての復旧不能なブロックの詳細なリストを見つけることができます。
</p><p>復旧に満足できない場合は、何度でも再試行できます。
</p><p>たとえば、最後の `sync` の後にアレイからファイルを削除した場合、
これにより一部のファイルが復旧されない可能性があります。
この場合、-i, --import オプションを使用して、これらのファイルが現在どこにあるかを指定することで、
復旧プロセスにそれらを再度含めるように `fix` を再試行できます。
</p><p>復旧に満足している場合は、さらに進むことができますが、**sync** の実行後には
`fix` コマンドを**再試行できない**ことに注意してください！
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-3" class="manual-title-level-3">
STEP 3 -&gt; Check
</h3>
<p>慎重なチェックとして、`check` コマンドを実行して、復旧されたディスク上の
すべてが正しいことを確認できます。
</p><pre>
snapraid -d NAME -a check
</pre>
<p>ここで NAME はディスクの名前であり、前の例では `d1` のようなものです。
</p><p>`-d` および `-a` オプションは、SnapRAIDに**指定されたディスクのみ**をチェックし、
**すべてのパリティデータを無視**するように指示します。
</p><p>このコマンドは時間がかかりますが、過度に慎重でない場合はスキップできます。
</p></div>
<div class="manual-section-level-3">
<h3 id="sec4-4-4" class="manual-title-level-3">
STEP 4 -&gt; Sync
</h3>
<p>`sync` コマンドを実行して、アレイを新しいディスクと再同期します。
</p><pre>
snapraid sync
</pre>
<p>すべてが復旧されていれば、このコマンドは即座に完了します。
</p></div>
</div>
</div>
<div class="manual-section-level-1">
<h1 id="sec5" class="manual-title-level-1">
Commands
</h1>
<p>SnapRAIDは、次のことを可能にするいくつかの簡単なコマンドを提供します。
</p><ul>
<li>
アレイの状態の概要を出力 -&gt; `status`
</li>
<li>
ディスクの制御 -&gt; `smart`、`probe`、`up`、`down`
</li>
<li>
バックアップ/スナップショットの作成 -&gt; `sync`
</li>
<li>
データの定期的なチェック -&gt; `scrub`
</li>
<li>
最後のバックアップ/スナップショットの復元 -&gt; `fix`。
</li>
</ul>
<p>コマンドは**小文字**で記述する必要があります。
</p><div class="manual-section-level-2">
<h2 id="sec5-1" class="manual-title-level-2">
status
</h2>
<p>ディスクアレイの状態の概要を出力します。
</p><p>これには、パリティの断片化、チェックなしでのブロックの古さ、および
スクラビング中に遭遇したすべての記録されたサイレントエラーに関する情報が
含まれます。
</p><p>提示される情報は、最後に `sync` を実行した時点のものです。
それ以降の変更は考慮されません。
</p><p>不良ブロックが検出された場合、それらのブロック番号が一覧表示されます。
それらを修正するには、`fix -e` コマンドを使用できます。
</p><p>また、各ブロックが最後にスクラブまたは同期された時期を示すグラフも表示されます。
スクラブされたブロックは `*` で、同期されたがまだスクラブされていないブロックは `o` で
示されます。
</p><p>何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-2" class="manual-title-level-2">
smart
</h2>
<p>システム内のすべてのディスクのSMARTレポートを出力します。
</p><p>これには、翌年の故障確率の推定値が含まれており、疑わしい属性を示すディスクの
メンテナンス交換を計画できます。
</p><p>この確率推定は、ディスクのSMART属性を次の場所で利用可能なBackblazeのデータと
相関させることで得られます。
</p><pre>
https://www.backblaze.com/hard-drive-test-data.html
</pre>
<p>SMARTがディスクが故障していると報告した場合、そのディスクに対して `FAIL` または `PREFAIL` が
出力され、SnapRAIDはエラーを返します。
この場合、**ディスクの即時交換**が強く推奨されます。
</p><p>その他の可能なステータス文字列は次のとおりです。
</p><div class="manual-tag-list">
<div class="manual-tag-entry">
<div class="manual-tag-name">
logfail
</div><div class="manual-tag-description">
過去に、一部の属性がしきい値よりも低かった。
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
logerr
</div><div class="manual-tag-description">
デバイスのエラーログにエラーが含まれている。
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
selferr
</div><div class="manual-tag-description">
デバイスのセルフテストログにエラーが含まれている。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-v, --verbose オプションが指定されている場合、より詳細な統計分析が提供されます。
</div><div class="manual-option-description">
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>この分析は、より多くまたはより少ないパリティが必要かどうかを決定するのに役立ちます。
</p><p>このコマンドは `smartctl` ツールを使用し、すべてのデバイスで `smartctl -a` を実行するのと
同等です。
</p><p>デバイスが正しく自動検出されない場合は、構成ファイルで `smartctl` オプションを
使用してカスタムコマンドを指定できます。
</p><p>何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-3" class="manual-title-level-2">
probe
</h2>
<p>システム内のすべてのディスクのPOWER状態を出力します。
</p><p>`Standby` はディスクがスピンしていないことを意味します。`Active` は
ディスクがスピンしていることを意味します。
</p><p>このコマンドは `smartctl` ツールを使用し、すべてのデバイスで `smartctl -n standby -i` を実行するのと
同等です。
</p><p>デバイスが正しく自動検出されない場合は、構成ファイルで `smartctl` オプションを
使用してカスタムコマンドを指定できます。
</p><p>何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-4" class="manual-title-level-2">
up
</h2>
<p>アレイのすべてのディスクをスピンアップします。
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-d, --filter-disk オプションを使用して、特定のディスクのみをスピンアップできます。
</div><div class="manual-option-description">
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>すべてのディスクを同時にスピンアップするには、多くの電力が必要です。
電源がそれに耐えられることを確認してください。
</p><p>何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-5" class="manual-title-level-2">
down
</h2>
<p>アレイのすべてのディスクをスピンダウンします。
</p><p>このコマンドは `smartctl` ツールを使用し、すべてのデバイスで `smartctl -s standby,now` を実行するのと
同等です。
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-d, --filter-disk オプションを使用して、特定のディスクのみをスピンダウンできます。
</div><div class="manual-option-description">
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>エラー時に自動的にスピンダウンするには、他の任意のコマンドで -s, --spin-down-on-error
オプションを使用できます。これは、エラーが発生したときに手動で `down` を実行するのと同等です。
</p><p>何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-6" class="manual-title-level-2">
diff
</h2>
<p>最後の `sync` 以降に変更され、パリティデータを再計算する必要があるすべてのファイルを
一覧表示します。
</p><p>このコマンドはファイルデータはチェックせず、ファイルのタイムスタンプ、サイズ、
およびinodeのみをチェックします。
</p><p>変更されたすべてのファイルを一覧表示した後、変更の概要が
次のようにグループ化されて提示されます。
</p><div class="manual-tag-list">
<div class="manual-tag-entry">
<div class="manual-tag-name">
equal
</div><div class="manual-tag-description">
変更されていないファイル。
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
added
</div><div class="manual-tag-description">
以前は存在しなかった追加されたファイル。
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
removed
</div><div class="manual-tag-description">
削除されたファイル。
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
updated
</div><div class="manual-tag-description">
サイズまたはタイムスタンプが異なるファイル。これは、
変更されたことを意味します。
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
moved
</div><div class="manual-tag-description">
同じディスク上の異なるディレクトリに移動されたファイル。
同じ名前、サイズ、タイムスタンプ、およびinodeを持ちますが、ディレクトリが
異なることで識別されます。
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
copied
</div><div class="manual-tag-description">
同じディスクまたは異なるディスクにコピーされたファイル。
異なるディスクに真に移動された場合、`removed` にも
カウントされることに注意してください。
同じ名前、サイズ、およびタイムスタンプを持つことで識別されます。
サブ秒のタイムスタンプがゼロの場合、ファイル名だけでなく、
フルパスが一致する必要があります。
</div> <!-- description -->
</div> <!-- entry -->
<div class="manual-tag-entry">
<div class="manual-tag-name">
restored
</div><div class="manual-tag-description">
inodeは異なるが、名前、サイズ、タイムスタンプが一致するファイル。
これらは通常、削除後に復元されたファイルです。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>`sync` が必要な場合、プロセスはデフォルトの0ではなく、リターンコード2を返します。
リターンコード1は、一般的なエラー状態に使用されます。
</p><p>何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-7" class="manual-title-level-2">
sync
</h2>
<p>パリティ情報を更新します。ディスクアレイ内のすべての変更されたファイルが読み取られ、
対応するパリティデータが更新されます。
</p><p>Ctrl+Cを押すことでいつでもこのプロセスを停止でき、
既に完了した作業を失うことはありません。
次回の実行時には、`sync` プロセスは中断された場所から
再開されます。
</p><p>プロセス中にサイレントエラーまたは入出力エラーが見つかった場合、
対応するブロックは不良としてマークされます。
</p><p>ファイルはパスおよび/またはinodeによって識別され、サイズとタイムスタンプによって
チェックされます。
ファイルサイズまたはタイムスタンプが異なる場合、パリティデータはファイル全体で
再計算されます。
ファイルが同じディスク上で移動または名前が変更され、同じinodeが保持されている場合、
パリティは再計算されません。
ファイルが別のディスクに移動された場合、パリティは再計算されますが、
以前に計算されたハッシュ情報は保持されます。
</p><p>`content` ファイルと `parity` ファイルは必要に応じて変更されます。
アレイ内のファイルは**変更されません**。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-8" class="manual-title-level-2">
scrub
</h2>
<p>アレイをスクラブし、データおよびパリティディスクのサイレントエラーまたは入出力エラーを
チェックします。
</p><p>1回の呼び出しごとに、最後の10日間で既にスクラブされたデータを除いて、
アレイの約8%がチェックされます。
これは、週に1回スクラビングを実行すると、すべてのデータが少なくとも3か月に1回は
チェックされることを意味します。
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-p, --plan オプションを使用して、異なるスクラブプランまたは量を定義できます。
</div><div class="manual-option-description">
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>このオプションは以下を受け入れます。
bad - 不良としてマークされたブロックをスクラブします。
new - まだスクラブされていない、同期されたばかりのブロックをスクラブします。
full - すべてをスクラブします。
0-100 - 指定されたパーセンテージのブロックをスクラブします。
</p><p>パーセンテージの量を指定する場合、-o, --older-than オプションを使用して、
ブロックがどれくらいの古さである必要があるかを定義することもできます。
最も古いブロックが最初にスクラブされ、最適なチェックが保証されます。
まだスクラブされていない、同期されたばかりのブロックのみをスクラブしたい場合は、
`-p new` オプションを使用します。
</p><p>スクラブステータスの詳細を取得するには、`status` コマンドを使用します。
</p><p>見つかったサイレントエラーまたは入出力エラーごとに、対応するブロックは
`content` ファイル内で不良としてマークされます。
これらの不良ブロックは `status` で一覧表示され、`fix -e` で修正できます。
修正後、次回のスクラブで再チェックされ、修正されていると判明した場合、
不良マークは削除されます。
不良ブロックのみをスクラブするには、`scrub -p bad` コマンドを使用できます。
</p><p>未同期のデータによって引き起こされた報告されたエラーを避けるために、
`scrub` は**同期された**アレイでのみ実行することをお勧めします。これらのエラーは
サイレントエラーではないと認識され、ブロックは不良としてマークされませんが、
そのようなエラーはコマンドの出力で報告されます。
</p><p>`content` ファイルは、各ブロックの最後のチェック時刻を更新し、不良ブロックを
マークするために変更されます。
`parity` ファイルは**変更されません**。
アレイ内のファイルは**変更されません**。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-9" class="manual-title-level-2">
fix
</h2>
<p>すべてのファイルとパリティデータを修正します。
</p><p>すべてのファイルとパリティデータは、最後の `sync` で保存されたスナップショット状態と
比較されます。
違いが見つかった場合、保存されたスナップショットに**元に戻されます**。
</p><p>**警告！** `fix` コマンドは、エラーと意図的な変更を区別しません。
ファイルの_状態を_最後の `sync` に**無条件に元に戻します**。
</p><p>他のオプションが指定されていない場合、アレイ全体が処理されます。
フィルタオプションを使用して、操作するファイルまたはディスクのサブセットを
選択します。
</p><p>`sync` および `scrub` 中に不良としてマークされたブロックのみを修正するには、
-e, --filter-error オプションを使用します。
他のフィルタオプションとは異なり、これは最新の `sync` 以降に**変更されていない**
ファイルにのみ修正を適用します。
</p><p>SnapRAIDは、修正できないすべてのファイルの名前を `.unrecoverable` 拡張子を
追加して変更します。
</p><p>修正する前に、アレイ全体がスキャンされ、最後の `sync` 操作以降に移動されたファイルが
見つけられます。
これらのファイルは、名前を無視してタイムスタンプによって識別され、
必要に応じて復旧プロセスで使用されます。
それらのいくつかをアレイ外に移動した場合は、-i, --import オプションを使用して
スキャンする追加のディレクトリを指定できます。
</p><p>ファイルは**パスによってのみ**識別され、inodeによっては識別されません。
</p><p>`content` ファイルは**変更されません**。
`parity` ファイルは必要に応じて変更されます。
アレイ内のファイルは必要に応じて変更されます。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-10" class="manual-title-level-2">
check
</h2>
<p>すべてのファイルとパリティデータを検証します。
</p><p>`fix` のように機能しますが、復旧を**シミュレートするだけ**で、アレイに**変更は書き込まれません**。
</p><p>このコマンドは、主に復旧プロセス後やその他の特殊な条件下での手動検証を
目的としています。
定期的でスケジュールされたチェックには、`scrub` を使用します。
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-a, --audit-only オプションを使用すると、ファイルの**ハッシュのみ**がチェックされ、
</div><div class="manual-option-description">
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>パリティデータは無視されるため、チェックプロセスが大幅に高速化されます。
</p><p>ファイルは**パスによってのみ**識別され、inodeによっては識別されません。
</p><p>何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-11" class="manual-title-level-2">
list
</h2>
<p>最後の `sync` の時点のアレイに含まれるすべてのファイルを
一覧表示します。
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-v または --verbose を使用すると、サブ秒の時間も表示されます。
</div><div class="manual-option-description">
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-12" class="manual-title-level-2">
dup
</h2>
<p>すべての重複ファイルを一覧表示します。ハッシュが一致する場合、2つのファイルは等しいと見なされます。
ファイルデータは読み取られず、事前に計算されたハッシュのみが使用されます。
</p><p>何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-13" class="manual-title-level-2">
pool
</h2>
<p>`pooling` ディレクトリに、ディスクアレイ内のすべてのファイルの仮想ビューを
作成または更新します。
</p><p>ファイルはコピーされず、シンボリックリンクを使用してリンクされます。
</p><p>更新時、既存のすべてのシンボリックリンクと空のサブディレクトリは削除され、
アレイの新しいビューに置き換えられます。その他の通常のファイルはそのまま残されます。
</p><p>プールディレクトリ外は何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-14" class="manual-title-level-2">
devices
</h2>
<p>アレイで使用される低レベルデバイスを出力します。
</p><p>このコマンドは、アレイ内のデバイスの関連付けを表示し、主にスクリプトインターフェイスを
目的としています。
</p><p>最初の2つの列は、低レベルデバイスIDとパスです。
次の2つの列は、高レベルデバイスIDとパスです。
最後の列は、アレイ内のディスク名です。
</p><p>ほとんどの場合、アレイ内のディスクごとに1つの低レベルデバイスがありますが、
より複雑な構成では、単一のアレイ内のディスクで複数の低レベルデバイスが
使用される場合があります。
</p><p>何も変更されません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-15" class="manual-title-level-2">
touch
</h2>
<p>サブ秒のタイムスタンプがゼロに設定されているすべてのファイルに、任意のサブ秒のタイムスタンプを
設定します。
</p><p>これにより、タイムスタンプがほぼ一意になり、重複の可能性が減るため、
SnapRAIDが移動およびコピーされたファイルを認識する能力が向上します。
</p><p>より具体的には、サブ秒のタイムスタンプがゼロでない場合、移動またはコピーされたファイルは、
名前、サイズ、およびタイムスタンプが一致する場合にそうであると識別されます。
サブ秒のタイムスタンプがゼロの場合、フルパス、サイズ、およびタイムスタンプのすべてが
一致する場合にのみコピーと見なされます。
</p><p>秒精度のタイムスタンプは変更されないため、ファイルのすべての日付と時刻は
保持されます。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec5-16" class="manual-title-level-2">
rehash
</h2>
<p>アレイ全体のリハッシュをスケジュールします。
</p><p>このコマンドは、使用されるハッシュの種類を変更します。これは通常、32ビットシステムから
64ビットシステムにアップグレードするときに、MurmurHash3からより高速なSpookyHashに
切り替えるために行われます。
</p><p>既に最適なハッシュを使用している場合、このコマンドは何もせず、アクションが不要であることを
通知します。
</p><p>リハッシュはすぐには実行されず、`sync` および `scrub` の間に徐々に実行されます。
</p><p>`status` を使用してリハッシュの状態を確認できます。
</p><p>リハッシュ中もSnapRAIDは完全な機能を維持しますが、唯一の例外として、
`dup` は異なるハッシュを使用している重複ファイルを検出できません。
</p></div>
</div>
<div class="manual-section-level-1">
<h1 id="sec6" class="manual-title-level-1">
Options
</h1>
<p>SnapRAIDには、次のオプションがあります。
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-c, --conf CONFIG
</div><div class="manual-option-description">
使用する構成ファイルを選択します。指定されていない場合、Unixでは、存在すれば
`/usr/local/etc/snapraid.conf` を使用し、それ以外の場合は `/etc/snapraid.conf` を
使用します。
Windowsでは、`snapraid.exe` と同じディレクトリにある `snapraid.conf` ファイルを
使用します。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-f, --filter PATTERN
</div><div class="manual-option-description">
`check` および `fix` で処理するファイルをフィルタリングします。
指定されたパターンに一致するファイルのみが処理されます。
このオプションは複数回使用できます。
パターン仕様の詳細については、PATTERNセクションを参照してください。
Unixでは、グロブ文字を使用する場合は引用符で囲むようにしてください。
このオプションは、`check` および `fix` のみで使用できます。
これらは常にアレイ全体を処理するため、`sync` および `scrub` では
使用できません。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-d, --filter-disk NAME
</div><div class="manual-option-description">
`check`、`fix`、`up`、および `down` で処理するディスクをフィルタリングします。
構成ファイルで定義されているディスク名を指定する必要があります。
`parity`、`2-parity`、`3-parity` などの名前でパリティディスクも指定して、
特定のパリティディスクに操作を限定できます。
複数の --filter、--filter-disk、および --filter-missing オプションを組み合わせると、
すべてのフィルタに一致するファイルのみが選択されます。
このオプションは複数回使用できます。
このオプションは、`check`、`fix`、`up`、および `down` のみで使用できます。
これらは常にアレイ全体を処理するため、`sync` および `scrub` では
使用できません。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-m, --filter-missing
</div><div class="manual-option-description">
`check` および `fix` で処理するファイルをフィルタリングします。
アレイから不足または削除されたファイルのみが処理されます。
`fix` と一緒に使用すると、これは `undelete` コマンドとして機能します。
複数の --filter、--filter-disk、および --filter-missing オプションを組み合わせると、
すべてのフィルタに一致するファイルのみが選択されます。
このオプションは、`check` および `fix` のみで使用できます。
これらは常にアレイ全体を処理するため、`sync` および `scrub` では
使用できません。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-e, --filter-error
</div><div class="manual-option-description">
`check` および `fix` でエラーのあるファイルを処理します。
`status` で一覧表示されているように、`sync` および `scrub` 中にサイレントエラーまたは
入出力エラーでマークされたブロックを持つファイルのみを処理します。
このオプションは、`check` および `fix` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-p, --plan PERC|bad|new|full
</div><div class="manual-option-description">
スクラブプランを選択します。PERCが0から100までの数値である場合、
スクラブするブロックのパーセンテージとして解釈されます。
パーセンテージの代わりに、プランを指定できます。
`bad` は不良ブロックをスクラブし、`new` はまだスクラブされていないブロックをスクラブし、
`full` はすべてをスクラブします。
このオプションは、`scrub` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-o, --older-than DAYS
</div><div class="manual-option-description">
`scrub` で処理するアレイの最も古い部分を選択します。
DAYS は、ブロックがスクラブされるための最小経過日数であり、デフォルトは10です。
不良としてマークされたブロックは、このオプションに関係なく常にスクラブされます。
このオプションは、`scrub` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-a, --audit-only
</div><div class="manual-option-description">
`check` で、パリティデータをチェックせずにファイルのハッシュを検証します。
ファイルデータのみのチェックに関心がある場合、このオプションはチェックプロセスを
大幅に高速化できます。
このオプションは、`check` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-h, --pre-hash
</div><div class="manual-option-description">
`sync` で、パリティ計算の前の追加検証のために、すべての新しいデータの
予備ハッシュ化フェーズを実行します。
通常、`sync` では、予備ハッシュ化は行われず、新しいデータはパリティ計算の直前に、
最初に読み取られたときにハッシュ化されます。
このプロセスは、システムが重い負荷の下にあり、すべてのディスクがスピンしており、CPUが
ビジーなときに発生します。
これはマシンにとって極端な状態であり、潜在的なハードウェアの問題がある場合、
データがまだハッシュ化されていないため、サイレントエラーが検出されないままになる
可能性があります。
このリスクを回避するために、`pre-hash` モードを有効にして、すべてのデータを2回読み取り、
その整合性を確保できます。
このオプションは、アレイ内で移動されたファイルも検証して、移動操作が成功したことを
確認し、必要に応じて、続行する前に修正操作を実行できるようにします。
このオプションは、`sync` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-i, --import DIR
</div><div class="manual-option-description">
最後の `sync` の後にアレイから削除されたファイルを、指定されたディレクトリから
インポートします。
これらのファイルをまだ持っている場合、それらは復旧プロセスを改善するために
`check` および `fix` で使用できます。
ファイルは、サブディレクトリを含めて読み取られ、名前に関係なく識別されます。
このオプションは、`check` および `fix` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-s, --spin-down-on-error
</div><div class="manual-option-description">
エラーが発生した場合、非ゼロのステータスコードで終了する前に、管理されているすべてのディスクを
スピンダウンします。これにより、中断された操作後にドライブがアクティブなままスピンし続け、
不要な熱の蓄積と電力消費を回避するのに役立ちます。
コマンドが失敗した場合でも、ディスクが安全に停止されるように、このオプションを使用します。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-w, --bw-limit RATE
</div><div class="manual-option-description">
すべてのディスクにグローバルな帯域幅制限を適用します。RATE は
1秒あたりのバイト数です。K、M、Gなどの乗数を指定できます
(例：--bw-limit 1G)。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-A, --stats
</div><div class="manual-option-description">
追加情報を表示する拡張ステータスビューを有効にします。
画面には2つのグラフが表示されます。
最初のグラフは、各ディスクのバッファリングされたストライプの数と、そのディスクで現在
アクセスされているファイルのファイルパスを示します。通常、最も遅いディスクには
バッファが利用できず、これが達成可能な最大帯域幅を決定します。
2番目のグラフは、過去100秒間に待機に費やされた時間のパーセンテージを示します。
最も遅いディスクが待機時間のほとんどを引き起こすと予想され、他のディスクは
バッファリングされたストライプを使用できるため、待機時間がほとんどまたはまったくないはずです。
このグラフは、ハッシュ計算とRAID計算に費やされた待機時間も示します。
すべての計算はディスク操作と並行して実行されます。
したがって、少なくとも1つのディスクで測定可能な待機時間がある限り、
CPUがワークロードに追いつくのに十分速いことを示しています。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-Z, --force-zero
</div><div class="manual-option-description">
以前は非ゼロだったサイズのファイルをゼロで同期するという安全でない操作を強制します。
SnapRAIDがこのような状態を検出した場合、このオプションを指定しない限り、
続行を停止します。
これにより、システムクラッシュ後に一部のアクセスされたファイルが切り捨てられたときに、
それを簡単に検出できます。
これは、ext3/ext4ファイルシステムを使用したLinuxで起こりうる状態です。
このオプションは、`sync` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-E, --force-empty
</div><div class="manual-option-description">
元のファイルがすべて不足しているディスクを同期するという安全でない操作を強制します。
SnapRAIDが、元々ディスクに存在していたすべてのファイルが不足しているか、
書き換えられていることを検出した場合、このオプションを指定しない限り、
続行を停止します。
これにより、データファイルシステムがマウントされていないときに、それを簡単に
検出できます。
このオプションは、`sync` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-U, --force-uuid
</div><div class="manual-option-description">
UUIDが変更されたディスクとの同期、チェック、および修正という安全でない操作を強制します。
SnapRAIDが一部のディスクがUUIDを変更したことを検出した場合、
このオプションを指定しない限り、続行を停止します。
これにより、ディスクが間違ったマウントポイントにマウントされているときに、それを検出できます。
ただし、単一パリティでの単一のUUID変更、および複数のパリティでのより多くのUUID変更は
許可されています。これは、復旧後にディスクを交換するときの通常のケースであるためです。
このオプションは、`sync`、`check`、または `fix` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-D, --force-device
</div><div class="manual-option-description">
アクセスできないディスク、または同じ物理デバイス上のディスクとの修正という安全でない操作を強制します。
たとえば、2台のデータディスクを失い、最初の1台だけを復旧するための予備ディスクがある場合、
2番目のアクセスできないディスクを無視できます。
または、既に**使用されている**ディスクに残された空き容量にディスクを復旧したい場合、
同じ物理デバイスを共有します。
このオプションは、`fix` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-N, --force-nocopy
</div><div class="manual-option-description">
`sync`、`check`、および `fix` で、コピー検出ヒューリスティックを無効にします。
このオプションがない場合、SnapRAIDは、名前、サイズ、タイムスタンプなどの同じ属性を持つファイルが、
同じデータを持つコピーであると見なします。
これにより、あるディスクから別のディスクにコピーまたは移動されたファイルを識別し、
既に計算されたハッシュ情報を再利用して、サイレントエラーを検出したり、不足しているファイルを
復旧したりできます。
まれに、この動作が誤検出や、多くのハッシュ検証によるプロセスの遅延につながる可能性があり、
このオプションを使用すると、そのような問題を解決できます。
このオプションは、`sync`、`check`、および `fix` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-F, --force-full
</div><div class="manual-option-description">
`sync` で、パリティの完全な再計算を強制します。
このオプションは、新しいパリティレベルを追加する場合、またはより新しいパリティデータを使用して
古いコンテンツファイルに戻した場合に使用できます。
パリティを最初から再作成する代わりに、これにより、コンテンツファイルに存在するハッシュを
再利用してデータを検証し、既存のパリティデータを使用して `sync` プロセス中にデータ保護を
維持できます。
このオプションは、`sync` のみで使用できます。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-R, --force-realloc
</div><div class="manual-option-description">
`sync` で、ファイルの完全な再割り当てとパリティの再構築を強制します。
このオプションは、コンテンツファイルに存在するハッシュを再利用してデータを検証しながら、
断片化を削除して、すべてのファイルを完全に再割り当てするために使用できます。
このオプションは、`sync` のみで使用できます。
**警告！** このオプションはエキスパートのみを対象としており、使用しないことを強く
お勧めします。
`sync` 操作中にデータ保護はありません。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-l, --log FILE
</div><div class="manual-option-description">
詳細なログを指定されたファイルに書き込みます。
このオプションが指定されていない場合、予期しないエラーが画面に出力され、
多くのエラーが発生した場合に過剰な出力になる可能性があります。
-l, --log が指定されている場合、SnapRAIDが停止する原因となる致命的なエラーのみが
画面に出力されます。
パスが '&gt;&gt;' で始まる場合、ファイルは追記モードで開かれます。
名前に '%D' と '%T' が出現すると、それぞれYYYYMMDDとHHMMSSの形式で
日付と時刻に置き換えられます。Windowsバッチファイルでは、'%' 文字を
2倍にする必要があります。例：result-%%D.log。'&gt;&gt;' を使用するには、
名前を引用符で囲む必要があります。例：`"&gt;&gt;result.log"`。
ログを標準出力または標準エラーに出力するには、それぞれ `"&gt;&amp;1"` および `"&gt;&amp;2"` を
使用できます。
ログタグの説明については、snapraid_log.txtファイルまたはmanページを参照してください。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-L, --error-limit NUMBER
</div><div class="manual-option-description">
実行を停止する前の新しいエラー制限を設定します。
デフォルトでは、SnapRAIDは100を超える入出力エラーに遭遇した場合に停止します。
これは、ディスクが故障している可能性が高いことを示しています。
このオプションは `sync` と `scrub` に影響し、最初の一連のディスクエラーの後に
続行して操作を完了しようとすることが許可されます。
ただし、`check` と `fix` は常に最初のエラーで停止します。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-S, --start BLKSTART
</div><div class="manual-option-description">
指定されたブロック番号から処理を開始します。
これは、破損したディスクの場合に特定のブロックを再試行してチェックまたは修正するのに
役立ちます。
このオプションは、主に高度な手動復旧を目的としています。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-B, --count BLKCOUNT
</div><div class="manual-option-description">
指定された数のブロックのみを処理します。
このオプションは、主に高度な手動復旧を目的としています。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-C, --gen-conf CONTENT
</div><div class="manual-option-description">
既存のコンテンツファイルからダミーの構成ファイルを生成します。
構成ファイルは標準出力に書き込まれ、既存のファイルを上書きしません。
この構成ファイルには、システム全体を失った場合にディスクのマウントポイントを
再構築するために必要な情報も含まれています。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-v, --verbose
</div><div class="manual-option-description">
画面により多くの情報を出力します。
1回指定すると、除外されたファイルと追加の統計が出力されます。
このオプションはログファイルには影響しません。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-q, --quiet
</div><div class="manual-option-description">
画面に出力される情報を減らします。
1回指定すると、プログレスバーが削除されます。2回指定すると、実行中の操作が削除されます。
3回指定すると、情報メッセージが削除されます。4回指定すると、ステータスメッセージが削除されます。
致命的なエラーは常に画面に出力されます。
このオプションはログファイルには影響しません。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-H, --help
</div><div class="manual-option-description">
短いヘルプ画面を出力します。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
-V, --version
</div><div class="manual-option-description">
プログラムのバージョンを出力します。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
</div>
<div class="manual-section-level-1">
<h1 id="sec7" class="manual-title-level-1">
Configuration
</h1>
<p>SnapRAIDは、ディスクアレイの場所とパリティ情報の保存場所を知るために、構成ファイルを
必要とします。
</p><p>Unixでは、存在すれば `/usr/local/etc/snapraid.conf` を使用し、それ以外の場合は
`/etc/snapraid.conf` を使用します。
Windowsでは、`snapraid.exe` と同じディレクトリにある `snapraid.conf` ファイルを
使用します。
</p><p>次のオプションを含める必要があります（大文字と小文字を区別します）。
</p><div class="manual-section-level-2">
<h2 id="sec7-1" class="manual-title-level-2">
parity FILE [,FILE] ...
</h2>
<p>パリティ情報を保存するために使用するファイルを定義します。
パリティは、RAID5と同様に、単一のディスク障害からの保護を有効にします。
</p><p>複数のファイルを指定でき、それらは異なるディスク上に存在する必要があります。
ファイルがそれ以上成長できなくなると、次のファイルが使用されます。
利用可能な総容量は、アレイ内の**最大のデータディスク**と少なくとも同じ大きさでなければなりません。
</p><p>後で追加のパリティファイルを追加することはできますが、
それらを並べ替えたり削除したりすることはできません。
</p><p>パリティディスクをパリティ用に予約しておくことで、それらが断片化されるのを防ぎ、
パフォーマンスを向上させます。
</p><p>Windowsでは、フルディスクに関する警告を避けるために、各ディスクに256 MBが未使用で
残されます。
</p><p>このオプションは必須であり、1回のみ使用できます。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-2" class="manual-title-level-2">
(2,3,4,5,6)-parity FILE [,FILE] ...
</h2>
<p>追加のパリティ情報を保存するために使用するファイルを定義します。
</p><p>指定されたパリティレベルごとに、1つの追加の保護レベルが有効になります。
</p><ul>
<li>
2-parity は RAID6 デュアルパリティを有効にします。
</li>
<li>
3-parity は トリプルパリティを有効にします。
</li>
<li>
4-parity は クアッド（4つ）パリティを有効にします。
</li>
<li>
5-parity は ペンタ（5つ）パリティを有効にします。
</li>
<li>
6-parity は ヘキサ（6つ）パリティを有効にします。
</li>
</ul>
<p>各パリティレベルには、以前のすべてのパリティレベルが存在する必要があります。
</p><p>`parity` オプションと同じ考慮事項が適用されます。
</p><p>これらのオプションはオプションであり、1回のみ使用できます。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-3" class="manual-title-level-2">
z-parity FILE [,FILE] ...
</h2>
<p>トリプルパリティを保存するための代替ファイルとフォーマットを定義します。
</p><p>このオプションは `3-parity` の代替であり、主にARMやSSSE3命令セットをサポートしていない
AMD Phenom、Athlon、OpteronなどのローエンドCPUを対象としています。
このような場合、より良いパフォーマンスを提供します。
</p><p>このフォーマットは、ZFS RAIDZ3で使用されるものと似ていますが、より高速です。
ZFSと同様に、トリプルパリティを超えては機能しません。
</p><p>`3-parity` を使用している場合、パフォーマンス向上のために `z-parity` フォーマットの
使用が推奨される場合は警告が表示されます。
</p><p>構成ファイルを目的の `z-parity` または `3-parity` ファイルで調整し、
`fix` を使用して再作成することで、あるフォーマットから別のフォーマットに
変換することが可能です。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-4" class="manual-title-level-2">
content FILE
</h2>
<p>ディスクアレイに存在するすべてのファイルの一覧とチェックサムを保存するために使用するファイルを
定義します。
</p><p>データ、パリティ、またはその他の利用可能なディスクに配置できます。
データディスクを使用する場合、このファイルは `sync` プロセスから自動的に
除外されます。
</p><p>このオプションは必須であり、同じファイルを複数コピー保存するために複数回使用できます。
</p><p>使用するパリティディスクごとに**少なくとも1つのコピー**と、さらに**1つのコピー**を
保存する必要があります。追加のコピーを使用しても害はありません。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-5" class="manual-title-level-2">
data NAME DIR
</h2>
<p>アレイ内のデータディスクの名前とマウントポイントを定義します。
NAME はディスクを識別するために使用され、**一意である**必要があります。
DIR はファイルシステム内のディスクの**マウントポイント**です。
</p><p>NAME を固定したままにしておけば、必要に応じてマウントポイントを変更できます。
</p><p>アレイ内のデータディスクごとに1つのオプションを使用する必要があります。
</p><p>構成ファイルで直接 NAME を変更してから `sync` コマンドを実行することで、
後でディスクの名前を変更できます。
名前変更の場合、関連付けはディスクの保存されたUUIDを使用して行われます。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-6" class="manual-title-level-2">
nohidden
</h2>
<p>すべての隠しファイルとディレクトリを除外します。
Unixでは、隠しファイルは `.` で始まるファイルです。
Windowsでは、隠し属性を持つファイルです。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-7" class="manual-title-level-2">
exclude/include PATTERN
</h2>
<p>syncプロセスで除外または含めるファイルまたはディレクトリのパターンを定義します。
すべてのパターンは指定された順序で処理されます。
</p><p>一致する最初のパターンが `exclude` の場合、ファイルは除外されます。
`include` の場合、ファイルは含まれます。
パターンが一致しない場合、最後に指定されたパターンが `include` の場合はファイルは除外され、
`exclude` の場合は含まれます。
</p><p>パターン仕様の詳細については、PATTERNセクションを参照してください。
</p><p>このオプションは複数回使用できます。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-8" class="manual-title-level-2">
blocksize SIZE_IN_KIBIBYTES
</h2>
<p>パリティの基本ブロックサイズをキビバイト単位で定義します。
1キビバイトは1024バイトです。
</p><p>デフォルトのブロックサイズは256であり、ほとんどの場合に機能するはずです。
</p><p>**警告！** このオプションはエキスパートのみを対象としており、この値を変更しないことを強く
お勧めします。今後この値を変更するには、パリティ全体を**再作成**する必要があります！
</p><p>異なるブロックサイズを使用する理由の1つは、数百万のオーダーの**多くの小さなファイル**を
持っている場合です。
</p><p>ファイルごとに、たとえ数バイトであっても、パリティの**ブロック全体**が割り当てられ、
ファイルが多いと、これにより**かなりの未使用パリティスペース**が発生する可能性があります。
パリティディスクを完全に埋めると、データディスクにファイルを追加することは**許可されません**。
ただし、浪費されたパリティはデータディスク間で蓄積されません。データディスク上の多数のファイルから
生じる浪費スペースは、**そのデータディスク上のデータ量**のみを制限し、他のデータディスクには
影響しません。
</p><p>概算として、ファイルごとにブロックサイズの半分が浪費されると仮定できます。
たとえば、100,000ファイルと256 KiBのブロックサイズがある場合、12.8 GBのパリティが浪費され、
これによりデータディスク上で12.8 GB少ないスペースしか利用できなくなる可能性があります。
</p><p>`status` を使用して、各ディスクの浪費スペースの量を確認できます。
これは、データディスク上に**空き**として残す必要がある、またはアレイに含まれないファイルに
使用する必要があるスペースの量です。
この値が負の場合、パリティが満杯に近づいていることを意味し、まだ浪費できるスペースを
表します。
</p><p>この問題を回避するために、パリティにより大きなパーティションを使用できます。
たとえば、パリティパーティションがデータディスクよりも12.8 GB大きい場合、
各データディスクで最大100,000ファイルを処理するのに十分な追加スペースがあり、
浪費スペースはありません。
</p><p>Linuxでより大きなパリティパーティションを取得するトリックは、次のコマンドで
フォーマットすることです。
</p><pre>
mkfs.ext4 -m 0 -T largefile4 DEVICE
</pre>
<p>これにより、約1.5%の追加スペース、4 TBディスクで約60 GBが得られ、
浪費スペースなしで各データディスクで約460,000ファイルが可能になります。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-9" class="manual-title-level-2">
hashsize SIZE_IN_BYTES
</h2>
<p>保存されたブロックのハッシュサイズをバイト単位で定義します。
</p><p>デフォルトのハッシュサイズは16バイト（128ビット）であり、ほとんどの場合に機能するはずです。
</p><p>**警告！** このオプションはエキスパートのみを対象としており、この値を変更しないことを強く
お勧めします。今後この値を変更するには、パリティ全体を**再作成**する必要があります！
</p><p>異なるハッシュサイズを使用する理由の1つは、システムのメモリが制限されている場合です。
経験則として、SnapRAIDは通常、アレイ内のデータ16 TBごとに1 GiBのRAMを必要とします。
</p><p>具体的には、データのハッシュを保存するために、SnapRAIDは
約 $TS \cdot (1 + HS) / BS$ バイトのRAMを必要とします。
ここで、TSはディスクアレイの合計サイズ（バイト）、BSはブロックサイズ（バイト）、HSはハッシュサイズ（バイト）です。
</p><p>たとえば、4 TBのディスク8台、ブロックサイズ256 KiB（1 KiB = 1024バイト）、
ハッシュサイズ16の場合：
</p><pre>
RAM = $(8 \cdot 4 \cdot 10^{12}) \cdot (1 + 16) / (256 \cdot 2^{10}) = 1.93 \text{ GiB}$
</pre>
<p>ハッシュサイズを8に切り替えると：
</p><pre>
RAM = $(8 \cdot 4 \cdot 10^{12}) \cdot (1 + 8) / (256 \cdot 2^{10}) = 1.02 \text{ GiB}$
</pre>
<p>ブロックサイズを512に切り替えると：
</p><pre>
RAM = $(8 \cdot 4 \cdot 10^{12}) \cdot (1 + 16) / (512 \cdot 2^{10}) = 0.96 \text{ GiB}$
</pre>
<p>ハッシュサイズを8、ブロックサイズを512の両方に切り替えると：
</p><pre>
RAM = $(8 \cdot 4 \cdot 10^{12}) \cdot (1 + 8) / (512 \cdot 2^{10}) = 0.51 \text{ GiB}$
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-10" class="manual-title-level-2">
autosave SIZE_IN_GIGABYTES
</h2>
<p>処理された指定されたGB量後に、同期またはスクラビング時に状態を自動的に保存します。
このオプションは、マシンクラッシュやその他のイベントによって中断された場合に、
長い `sync` コマンドを最初から再起動するのを避けるのに役立ちます。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-11" class="manual-title-level-2">
temp_limit TEMPERATURE_CELSIUS
</h2>
<p>許容される最大ディスク温度を摂氏で設定します。指定されている場合、
SnapRAIDは smartctl ツールを使用してすべてのディスクの温度を定期的にチェックします。
SnapRAIDが動作している間、現在のディスク温度が表示されます。
いずれかのディスクがこの制限を超えると、すべての操作が停止し、ディスクは `temp_sleep`
オプションで定義された期間、スピンダウン（スタンバイ状態に移行）されます。
スリープ期間後、操作は再開されますが、温度制限に再度達した場合は再び一時停止する
可能性があります。
</p><p>操作中、SnapRAIDは各ディスクの加熱曲線も分析し、アクティビティが継続した場合に
達すると予想される長期的な安定温度を推定します。推定は、ディスク温度が4回上昇した
後にのみ実行され、信頼できる傾向を確立するのに十分なデータポイントが利用可能であることを
保証します。
この予測される安定温度は、現在の値の横に括弧で表示され、システムの冷却が
適切かどうかを評価するのに役立ちます。この推定温度は情報提供のみを目的としており、
SnapRAIDの動作には影響しません。プログラムの動作は、実際の測定されたディスク温度にのみ
基づいています。
</p><p>この分析を実行するために、SnapRAIDはシステム温度の参照が必要です。
まず、利用可能なハードウェアセンサーから読み取ろうとします。システムセンサーに
アクセスできない場合は、実行開始時に測定された最も低いディスク温度をフォールバック参照として
使用します。
</p><p>通常、SnapRAIDは最も熱いディスクの温度のみを表示します。
すべてのディスクの温度を表示するには、-A または --stats オプションを使用します。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-12" class="manual-title-level-2">
temp_sleep TIME_IN_MINUTES
</h2>
<p>温度制限に達したときのスタンバイ時間（分単位）を設定します。この期間中、ディスクは
スピンダウンしたままです。デフォルトは5分です。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-13" class="manual-title-level-2">
pool DIR
</h2>
<p>`pool` コマンドを使用してディスクアレイの仮想ビューが作成されるプーリングディレクトリを
定義します。
</p><p>ディレクトリは既に存在している必要があります。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-14" class="manual-title-level-2">
share UNC_DIR
</h2>
<p>ディスクにリモートでアクセスするために必要なWindows UNCパスを定義します。
</p><p>このオプションが指定されている場合、プールディレクトリに作成されたシンボリックリンクは、
ディスクにアクセスするためにこのUNCパスを使用します。
このオプションがない場合、生成されたシンボリックリンクはローカルパスのみを使用し、
プールディレクトリをネットワーク経由で共有することはできません。
</p><p>シンボリックリンクは、指定されたUNCパスを使用して形成され、`data` オプションで
指定されたディスク名を追加し、最後にファイルのディレクトリと名前を追加します。
</p><p>このオプションはWindowsでのみ必要です。
</p></div>
<div class="manual-section-level-2">
<h2 id="sec7-15" class="manual-title-level-2">
smartctl DISK/PARITY OPTIONS...
</h2>
<p>各ディスクのSMART属性を取得するためのカスタムsmartctlオプションを定義します。
これは、RAIDコントローラーや一部のUSBディスクが自動検出できない場合に必要になる
ことがあります。`%s` プレースホルダーはデバイス名に置き換えられますが、
RAIDコントローラーなどの固定デバイスではオプションです。
</p><p>DISK は `data` オプションで指定されたのと同じディスク名です。
PARITY はパリティ名のいずれかです：`parity`、`2-parity`、`3-parity`、
`4-parity`、`5-parity`、`6-parity`、または `z-parity`。
</p><p>指定された OPTIONS で、`%s` 文字列はデバイス名に置き換えられます。
RAIDコントローラーの場合、デバイスは固定されている可能性が高いため、
`%s` を使用する必要はないかもしれません。
</p><p>使用可能なオプションについては、smartmontoolsのドキュメントを参照してください。
</p><pre>
https://www.smartmontools.org/wiki/Supported_RAID-Controllers
https://www.smartmontools.org/wiki/Supported_USB-Devices
</pre>
<p>例：
</p><pre>
smartctl parity -d sat %s
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-16" class="manual-title-level-2">
smartignore DISK/PARITY ATTR [ATTR...]
</h2>
<p>ディスク障害の確率を計算するときに、指定されたSMART属性を無視します。
このオプションは、ディスクが特定の属性について異常な値または誤解を招く値を報告する場合に
役立ちます。
</p><p>DISK は `data` オプションで指定されたのと同じディスク名です。
PARITY はパリティ名のいずれかです：`parity`、`2-parity`、`3-parity`、
`4-parity`、`5-parity`、`6-parity`、または `z-parity`。
特殊な値 `*` は、すべてのディスクで属性を無視するために使用できます。
</p><p>例として、すべてのディスクで `Current Pending Sector Count` 属性を無視するには：
</p><pre>
smartignore * 197
</pre>
<p>最初のパリティディスクでのみ無視するには：
</p><pre>
smartignore parity 197
</pre>
</div>
<div class="manual-section-level-2">
<h2 id="sec7-17" class="manual-title-level-2">
Examples
</h2>
<p>Unixの一般的な構成の例は次のとおりです。
</p><pre>
parity /mnt/diskp/snapraid.parity
content /mnt/diskp/snapraid.content
content /var/snapraid/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
exclude /lost+found/
exclude /tmp/
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/sg0
smartctl 2-parity -d areca,2/1 /dev/sg0
</pre>
<p>Windowsの一般的な構成の例は次のとおりです。
</p><pre>
parity E:\snapraid.parity
content E:\snapraid.content
content C:\snapraid\snapraid.content
data d1 G:\array\
data d2 H:\array\
data d3 I:\array\
exclude Thumbs.db
exclude \$RECYCLE.BIN
exclude \System Volume Information
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/arcmsr0
smartctl 2-parity -d areca,2/1 /dev/arcmsr0
</pre>
</div>
</div>
<div class="manual-section-level-1">
<h1 id="sec8" class="manual-title-level-1">
Pattern
</h1>
<p>パターンは、含めるファイルまたは除外するファイルをフィルタリングするための柔軟な方法を
提供します。グロブ文字を使用することで、すべてのパスを手動でリストすることなく、
特定のファイル名やディレクトリ構造全体に一致するルールを定義できます。
</p><p>疑問符 `?` は、ディレクトリ区切り文字を除く任意の1文字に一致します。
これにより、パターンを単一のディレクトリレベルに限定したまま、可変文字を
持つファイル名と一致させるのに役立ちます。
</p><p>単一のアスタリスク `*` は任意の文字列に一致しますが、疑問符と同様に
ディレクトリの境界を越えることはありません。スラッシュで停止するため、
単一のパスコンポーネント内での一致に適しています。これは、シェルの
グロブでおなじみの標準的なワイルドカードの動作です。
</p><p>ダブルアスタリスク `**` はより強力で、ディレクトリ区切り文字を含む
任意の文字列に一致します。これにより、パターンが複数のディレクトリレベルを
またいで一致できるようになります。`**` がパターン内に直接埋め込まれている場合、
周囲のリテラルテキストの間にあるスラッシュを含む0文字以上の文字に一致します。
</p><p>`**` の最も重要な使い方は、特別な形式である `/**/` です。これは
0個以上の完全なディレクトリレベルに一致し、正確なパス構造を知らなくても、
ディレクトリツリー内の任意の深さにあるファイルと一致させることができます。
例えば、パターン `src/**/main.js` は `src/main.js`（ディレクトリを0個スキップ）、
`src/ui/main.js`（1個スキップ）、`src/ui/components/main.js`（2個スキップ）
に一致します。
</p><p>角括弧 `[]` を使用した文字クラスは、指定されたセットまたは範囲の
任意の1文字に一致します。他の単一文字パターンと同様に、
ディレクトリ区切り文字には一致しません。クラスは範囲と、感嘆符を
使用した否定をサポートしています。
</p><p>覚えておくべき根本的な違いは、`*`、`?`、および文字クラスはすべて
ディレクトリの境界を尊重し、単一のパスコンポーネント内でのみ一致するのに対し、
`**` はディレクトリ区切り文字をまたいで一致できる唯一のパターンであるということです。
</p><p>4つの異なる種類のパターンがあります。
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
FILE
</div><div class="manual-option-description">
FILE という名前の任意のファイルを選択します。
このパターンはファイルにのみ適用され、ディレクトリには適用されません。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
DIR/
</div><div class="manual-option-description">
DIR という名前の任意のディレクトリとその中のすべてを選択します。
このパターンはディレクトリにのみ適用され、ファイルには適用されません。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/FILE
</div><div class="manual-option-description">
指定された正確なファイル パスを選択します。このパターンは
ファイルにのみ適用され、ディレクトリには適用されません。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/DIR/
</div><div class="manual-option-description">
指定された正確なディレクトリ パスとその中のすべてを選択します。
このパターンはディレクトリにのみ適用され、ファイルには適用されません。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/ で始まる絶対パスを指定する場合、それはローカルファイルシステムのルートディレクトリではなく、
</div><div class="manual-option-description">
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>**アレイのルートディレクトリ**に適用されます。
</p><p>Windowsでは、フォワードスラッシュ / の代わりにバックスラッシュ \ を使用できます。
Windowsシステムディレクトリ、ジャンクション、マウントポイント、およびその他のWindowsの
特殊ディレクトリはファイルとして扱われます。つまり、それらを除外するには、
ディレクトリルールではなく**ファイルルール**を使用する必要があります。
</p><p>ファイル名に '*'、'?'、'['、または ']' 文字が含まれている場合は、
グロブ文字として解釈されないように**エスケープ**する必要があります。
Unixではエスケープ文字は '\' です。Windowsでは '^' です。
パターンがコマンドラインにある場合は、コマンドシェルによって解釈されるのを防ぐために、
エスケープ文字を**2倍**にする必要があります。
</p><p>構成ファイルでは、処理するファイルをフィルタリングするために異なる戦略を使用できます。
最も簡単なアプローチは、**除外**したいすべてのファイルとディレクトリを削除するために、
`exclude` ルールのみを使用することです。例：
</p><pre>
# `*.unrecoverable` という名前の任意のファイルを除外
exclude *.unrecoverable
# ルートディレクトリ `/lost+found` を除外
exclude /lost+found/
# `tmp` という名前の任意のサブディレクトリを除外
exclude tmp/
</pre>
<p>反対のアプローチは、`include` ルールのみを使用して、**処理したいファイルのみ**を
定義することです。例：
</p><pre>
# 一部のディレクトリのみを含める
include /movies/
include /musics/
include /pictures/
</pre>
<p>最後の方法としては、`exclude` と `include` ルールを混在させます。この場合、
**ルールの順序が重要**です。前のルールは後のルールよりも優先されます。
簡素化するために、すべての `exclude` ルールを最初にリストし、次にすべての `include`
ルールをリストできます。例：
</p><pre>
# `*.unrecoverable` という名前の任意のファイルを除外
exclude *.unrecoverable
# `tmp` という名前の任意のサブディレクトリを除外
exclude tmp/
# 一部のディレクトリのみを含める
include /movies/
include /musics/
include /pictures/
</pre>
<p>コマンドラインで -f オプションを使用する場合、`include` パターンのみを
使用できます。例：
</p><pre>
# .mp3 ファイルのみをチェック。
# Unixでは、シェルによるグロブ展開を防ぐために引用符を使用。
snapraid -f "*.mp3" check
</pre>
<p>Unixでは、コマンドラインでグロブ文字を使用する場合、シェルがそれらを展開するのを
防ぐために引用符で囲む必要があります。
</p></div>
<div class="manual-section-level-1">
<h1 id="sec9" class="manual-title-level-1">
Ignore File
</h1>
<p>設定ファイルのグローバルルールに加えて、アレイ内の任意のディレクトリに
.snapraidignore ファイルを配置して、分散型の除外ルールを定義できます。
</p><p>`.snapraidignore` で定義されたルールは、設定ファイルのルールの後に
適用されます。これは、それらがより高い優先度を持ち、グローバル設定で
以前に含まれていたファイルを除外するために使用できることを意味します。
事実上、ローカルルールが一致する場合、グローバルな包含設定に関係なく、
ファイルは除外されます。
</p><p>`.snapraidignore` のパターンロジックはグローバル設定を反映していますが、
パターンはそのファイルが配置されているディレクトリに固定されます：
</p><div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
FILE
</div><div class="manual-option-description">
このディレクトリまたはその下にある、FILE という名前の任意のファイルを
選択します。これは、グローバルパターンと同じグロッビングルールに従います。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
DIR/
</div><div class="manual-option-description">
このディレクトリまたはその下にある、DIR という名前の任意のディレクトリと
その中のすべてを選択します。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/FILE
</div><div class="manual-option-description">
`.snapraidignore` ファイルの場所を基準にして、指定された正確な
ファイルを選択します。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<div class="manual-option-list">
<div class="manual-option-entry">
<div class="manual-option-name">
/PATH/DIR/
</div><div class="manual-option-description">
`.snapraidignore` ファイルの場所を基準にして、指定された正確な
ディレクトリとその中のすべてを選択します。
</div> <!-- description -->
</div> <!-- entry -->
</div> <!-- list -->
<p>グローバル設定とは異なり、`.snapraidignore` ファイルは除外ルールのみを
サポートします。`include` パターンや否定 (!) は使用できません。
</p><p>たとえば、`/mnt/disk1/projects/` に `.snapraidignore` がある場合：
</p><pre>
# /mnt/disk1/projects/output.bin のみを除外
/output.bin
# projects/ 内の 'build' という名前のディレクトリをすべて除外
build/
# projects/ またはそのサブフォルダ内のすべての .tmp ファイルを除外
*.tmp
</pre>
</div>
<div class="manual-section-level-1">
<h1 id="sec10" class="manual-title-level-1">
Content
</h1>
<p>SnapRAIDは、ファイルの一覧とチェックサムをコンテンツファイルに保存します。
</p><p>これはバイナリファイルであり、ディスクアレイに存在するすべてのファイルと、
それらの整合性を検証するためのすべてのチェックサムを一覧表示します。
</p><p>このファイルは `sync` および `scrub` コマンドによって読み書きされ、
`fix`、`check`、および `status` コマンドによって読み取られます。
</p></div>
<div class="manual-section-level-1">
<h1 id="sec11" class="manual-title-level-1">
Parity
</h1>
<p>SnapRAIDは、アレイのパリティ情報をパリティファイルに保存します。
</p><p>これらはバイナリファイルであり、`content` ファイルで定義されたすべてのブロックの
計算されたパリティが含まれています。
</p><p>これらのファイルは `sync` および `fix` コマンドによって読み書きされ、
`scrub` および `check` コマンドによって**読み取られるだけ**です。
</p></div>
<div class="manual-section-level-1">
<h1 id="sec12" class="manual-title-level-1">
Encoding
</h1>
<p>UnixのSnapRAIDは、エンコーディングを無視します。ファイルシステムで使用されている
のと同じエンコーディングでファイル名を読み取り、保存します。
</p><p>Windowsでは、ファイルシステムから読み取られたすべての名前はUTF-8形式に変換され、
処理されます。
</p><p>ファイル名を正しく出力するには、`chcp 65001` コマンドでWindowsコンソールをUTF-8モードに設定し、
コンソールフォントとして `Lucida Console` などのTrueTypeフォントを**使用する**必要があります。
これは出力されるファイル名にのみ影響します。コンソール出力をファイルにリダイレクトする場合、
結果のファイルは常にUTF-8形式になります。
</p></div>


            </div>
        </main>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container footer-content">
            <div class="footer-col">
                <h3>SnapRAID</h3>
                <p>Copyright &copy; 2026 Andrea Mazzoleni</p>
                <p class="license">Distributed under GPL v3 License</p>
            </div>
            <div class="footer-col">
                <h4>Community</h4>
                <ul>
                    <li><a href="https://www.reddit.com/r/Snapraid/">Reddit r/snapraid</a></li>
                    <li><a href="https://sourceforge.net/p/snapraid/discussion/1677233/">SourceForge Forum</a></li>
                    <li><a href="https://github.com/amadvance/snapraid/">GitHub</a></li>
                </ul>
            </div>
        </div>
    </footer>
</body>
</html>


