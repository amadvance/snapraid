<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="A backup program for disk arrays. It stores parity information of your data and it recovers from up to six disk failures">
<meta name="keywords" content="snapraid snapshot raid backup disk array redundancy parity">
<meta name="author" content="Andrea Mazzoleni">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="stylesheet" type="text/css" href="style.css">
<title>SnapRAID</title>

<!-- Google Analytics 4 -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W1Z5FKHYQ4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-W1Z5FKHYQ4');
</script>

<!-- Google Universal Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<div id="header">
<img src="index.jpg" width="1200" height="150" alt="Title">
</div>
<div id="menu">
<a href="/">About</a>
<a href="download">Download</a>
<a href="design">Design</a>
<a href="compare">Compare</a>
<a href="faq">FAQ</a>
<a href="manual">Manual</a>
<a href="support">Support</a>
<a href="authors">Authors</a>
</div>
<div id="main">



<p>
Manual for <span class="bold">SnapRAID</span>.
</p>

<p>
There are also automatic translation to <a href="manual-de.html">German</a>, <a href="manual-es.html">Spanish</a>, <a href="manual-fr.html">French</a>, <a href="manual-it.html">Italian</a>, <a href="manual-pl.html">Polish</a>, <a href="manual-ro.html">Romanian</a>.
</p>

<h1>Manual</h1>

<h2><a name="1">1</a> 
Synopsis
</h2>
<pre>
snapraid [-c, --conf CONFIG]
&nbsp;&nbsp;&nbsp;&nbsp;[-f, --filter PATTERN] [-d, --filter-disk NAME]
&nbsp;&nbsp;&nbsp;&nbsp;[-m, --filter-missing] [-e, --filter-error]
&nbsp;&nbsp;&nbsp;&nbsp;[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR]
&nbsp;&nbsp;&nbsp;&nbsp;[-p, --plan PERC|bad|new|full]
&nbsp;&nbsp;&nbsp;&nbsp;[-o, --older-than DAYS] [-l, --log FILE]
&nbsp;&nbsp;&nbsp;&nbsp;[-s, --spin-down-on-error] [-w, --bw-limit RATE]
&nbsp;&nbsp;&nbsp;&nbsp;[-Z, --force-zero] [-E, --force-empty]
&nbsp;&nbsp;&nbsp;&nbsp;[-U, --force-uuid] [-D, --force-device]
&nbsp;&nbsp;&nbsp;&nbsp;[-N, --force-nocopy] [-F, --force-full]
&nbsp;&nbsp;&nbsp;&nbsp;[-R, --force-realloc]
&nbsp;&nbsp;&nbsp;&nbsp;[-S, --start BLKSTART] [-B, --count BLKCOUNT]
&nbsp;&nbsp;&nbsp;&nbsp;[-L, --error-limit NUMBER]
&nbsp;&nbsp;&nbsp;&nbsp;[-A, --stats]
&nbsp;&nbsp;&nbsp;&nbsp;[-v, --verbose] [-q, --quiet]
&nbsp;&nbsp;&nbsp;&nbsp;status|smart|probe|up|down|diff|sync|scrub|fix|check
&nbsp;&nbsp;&nbsp;&nbsp;|list|dup|pool|devices|touch|rehash
</pre>
<p>
<pre>
snapraid [-V, --version] [-H, --help] [-C, --gen-conf CONTENT]
</pre>
<h2><a name="2">2</a> 
Description
</h2>
SnapRAID is a backup program designed for disk arrays, storing
parity information for data recovery in the event of up to six
disk failures.
<p>
Primarily intended for home media centers with large,
infrequently changing files, SnapRAID offers several features:
<ul>
<li>
You can utilize disks already filled with files without the
need to reformat them, accessing them as usual.
</li>
<li>
All your data is hashed to ensure data integrity and prevent
silent corruption.
</li>
<li>
When the number of failed disks exceeds the parity count,
data loss is confined to the affected disks; data on
other disks remains accessible.
</li>
<li>
If you accidentally delete files on a disk, recovery is
possible.
</li>
<li>
Disks can have different sizes.
</li>
<li>
You can add disks at any time.
</li>
<li>
SnapRAID doesn't lock in your data; you can stop using it
anytime without reformatting or moving data.
</li>
<li>
To access a file, only a single disk needs to spin, saving
power and reducing noise.
</li>
</ul>
<p>
For more information, please visit the official SnapRAID site:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.snapraid.it/
</pre>
</td></tr></table>
<h2><a name="3">3</a> 
Limitations
</h2>
SnapRAID is a hybrid between a RAID and a backup program, aiming to combine
the best benefits of both. However, it has some limitations that you should
consider before using it.
<p>
The main limitation is that if a disk fails and you haven't recently synced,
you may not be able to fully recover.
More specifically, you may be unable to recover up to the size of
the changed or deleted files since the last sync operation.
This occurs even if the changed or deleted files are not on the
failed disk. This is why SnapRAID is better suited for
data that rarely changes.
<p>
On the other hand, newly added files don't prevent recovery of already
existing files. You will only lose the recently added files if they
are on the failed disk.
<p>
Other SnapRAID limitations are:
<ul>
<li>
With SnapRAID, you still have separate file systems for each disk.
With RAID, you get a single large file system.
</li>
<li>
SnapRAID doesn't stripe data.
With RAID, you get a speed boost with striping.
</li>
<li>
SnapRAID doesn't support real-time recovery.
With RAID, you do not have to stop working when a disk fails.
</li>
<li>
SnapRAID can recover data only from a limited number of disk failures.
With a backup, you can recover from a complete
failure of the entire disk array.
</li>
<li>
Only file names, timestamps, symlinks, and hardlinks are saved.
Permissions, ownership, and extended attributes are not saved.
</li>
</ul>
<h2><a name="4">4</a> 
Getting Started
</h2>
To use SnapRAID, you need to first select one disk in your disk array
to dedicate to `parity` information. With one disk for parity, you
will be able to recover from a single disk failure, similar to RAID5.
<p>
If you want to recover from more disk failures, similar to RAID6,
you must reserve additional disks for parity. Each additional parity
disk allows recovery from one more disk failure.
<p>
As parity disks, you must pick the largest disks in the array,
as the parity information may grow to the size of the largest data
disk in the array.
<p>
These disks will be dedicated to storing the `parity` files.
You should not store your data on them.
<p>
Then, you must define the `data` disks that you want to protect
with SnapRAID. The protection is more effective if these disks
contain data that rarely changes. For this reason, it's better to
NOT include the Windows C:\ disk or the Unix /home, /var, and /tmp
directories.
<p>
The list of files is saved in the `content` files, usually
stored on the data, parity, or boot disks.
This file contains the details of your backup, including all the
checksums to verify its integrity.
The `content` file is stored in multiple copies, and each copy must
be on a different disk to ensure that, even in case of multiple
disk failures, at least one copy is available.
<p>
For example, suppose you are interested in only one parity level
of protection, and your disks are located at:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
/mnt/diskp &lt;- selected disk for parity
/mnt/disk1 &lt;- first disk to protect
/mnt/disk2 &lt;- second disk to protect
/mnt/disk3 &lt;- third disk to protect
</pre>
</td></tr></table>
<p>
You must create the configuration file /etc/snapraid.conf with
the following options:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity /mnt/diskp/snapraid.parity
content /var/snapraid/snapraid.content
content /mnt/disk1/snapraid.content
content /mnt/disk2/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
</pre>
</td></tr></table>
<p>
If you are on Windows, you should use the Windows path format, with drive
letters and backslashes instead of slashes.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity E:\snapraid.parity
content C:\snapraid\snapraid.content
content F:\array\snapraid.content
content G:\array\snapraid.content
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
</pre>
</td></tr></table>
<p>
If you have many disks and run out of drive letters, you can mount
disks directly in subfolders. See:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.google.com/search?q=Windows+mount+point
</pre>
</td></tr></table>
<p>
At this point, you are ready to run the `sync` command to build the
parity information.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid sync
</pre>
</td></tr></table>
<p>
This process may take several hours the first time, depending on the size
of the data already present on the disks. If the disks are empty,
the process is immediate.
<p>
You can stop it at any time by pressing Ctrl+C, and at the next run, it
will resume where it was interrupted.
<p>
When this command completes, your data is SAFE.
<p>
Now you can start using your array as you like and periodically
update the parity information by running the `sync` command.
<h3><a name="4.1">4.1</a> 
Scrubbing
</h3>
To periodically check the data and parity for errors, you can
run the `scrub` command.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid scrub
</pre>
</td></tr></table>
<p>
This command compares the data in your array with the hash computed
during the `sync` command to verify integrity.
<p>
Each run of the command checks approximately 8% of the array, excluding data
already scrubbed in the previous 10 days.
You can use the -p, --plan option to specify a different amount
and the -o, --older-than option to specify a different age in days.
For example, to check 5% of the array for blocks older than 20 days, use:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -p 5 -o 20 scrub
</pre>
</td></tr></table>
<p>
If silent or input/output errors are found during the process,
the corresponding blocks are marked as bad in the `content` file
and listed in the `status` command.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid status
</pre>
</td></tr></table>
<p>
To fix them, you can use the `fix` command, filtering for bad blocks with
the -e, --filter-error option:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -e fix
</pre>
</td></tr></table>
<p>
At the next `scrub`, the errors will disappear from the `status` report
if they are truly fixed. To make it faster, you can use -p bad to scrub
only blocks marked as bad.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -p bad scrub
</pre>
</td></tr></table>
<p>
Running `scrub` on an unsynced array may report errors caused by
removed or modified files. These errors are reported in the `scrub`
output, but the related blocks are not marked as bad.
<h3><a name="4.2">4.2</a> 
Pooling
</h3>
Note: The pooling feature described below has been superseded by the
mergefs tool, which is now the recommended option for Linux users in
the SnapRAID community. Mergefs provides a more flexible and efficient
way to pool multiple drives into a single unified mount point,
allowing seamless access to files across your array without relying
on symbolic links. It integrates well with SnapRAID for parity
protection and is commonly used in setups like OpenMediaVault (OMV)
or custom NAS configurations.
<p>
To have all the files in your array shown in the same directory tree,
you can enable the `pooling` feature. It creates a read-only virtual
view of all the files in your array using symbolic links.
<p>
You can configure the `pooling` directory in the configuration file with:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
pool /pool
</pre>
</td></tr></table>
<p>
or, if you are on Windows, with:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
pool C:\pool
</pre>
</td></tr></table>
<p>
and then run the `pool` command to create or update the virtual view.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid pool
</pre>
</td></tr></table>
<p>
If you are using a Unix platform and want to share this directory
over the network to either Windows or Unix machines, you should add
the following options to your /etc/samba/smb.conf:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# In the global section of smb.conf
unix extensions = no
</pre>
</td></tr></table>
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# In the share section of smb.conf
[pool]
comment = Pool
path = /pool
read only = yes
guest ok = yes
wide links = yes
follow symlinks = yes
</pre>
</td></tr></table>
<p>
In Windows, sharing symbolic links over a network requires clients to
resolve them remotely. To enable this, besides sharing the pool directory,
you must also share all the disks independently, using the disk names
defined in the configuration file as share points. You must also specify
in the `share` option of the configuration file the Windows UNC path that
remote clients need to use to access these shared disks.
<p>
For example, operating from a server named `darkstar`, you can use
the options:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
pool C:\pool
share \\darkstar
</pre>
</td></tr></table>
<p>
and share the following directories over the network:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
\\darkstar\pool -&gt; C:\pool
\\darkstar\d1 -&gt; F:\array
\\darkstar\d2 -&gt; G:\array
\\darkstar\d3 -&gt; H:\array
</pre>
</td></tr></table>
<p>
to allow remote clients to access all the files at \\darkstar\pool.
<p>
You may also need to configure remote clients to enable access to remote
symlinks with the command:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
fsutil behavior set SymlinkEvaluation L2L:1 R2R:1 L2R:1 R2L:1
</pre>
</td></tr></table>
<h3><a name="4.3">4.3</a> 
Undeleting
</h3>
SnapRAID functions more like a backup program than a RAID system, and it
can be used to restore or undelete files to their previous state using
the -f, --filter option:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -f FILE
</pre>
</td></tr></table>
<p>
or for a directory:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -f DIR/
</pre>
</td></tr></table>
<p>
You can also use it to recover only accidentally deleted files inside
a directory using the -m, --filter-missing option, which restores
only missing files, leaving all others untouched.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -m -f DIR/
</pre>
</td></tr></table>
<p>
Or to recover all the deleted files on all drives with:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -m
</pre>
</td></tr></table>
<h3><a name="4.4">4.4</a> 
Recovering
</h3>
The worst has happened, and you have lost one or more disks!
<p>
DO NOT PANIC! You will be able to recover them!
<p>
The first thing you must do is avoid further changes to your disk array.
Disable any remote connections to it and any scheduled processes, including
any scheduled SnapRAID nightly sync or scrub.
<p>
Then proceed with the following steps.
<h4><a name="4.4.1">4.4.1</a> 
STEP 1 -&gt; Reconfigure
</h4>
You need some space to recover, ideally on additional
spare disks, but an external USB disk or remote disk will suffice.
<p>
Modify the SnapRAID configuration file to make the `data` or `parity`
option of the failed disk point to a location with enough empty
space to recover the files.
<p>
For example, if disk `d1` has failed, change from:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 /mnt/disk1/
</pre>
</td></tr></table>
<p>
to:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 /mnt/new_spare_disk/
</pre>
</td></tr></table>
<p>
If the disk to recover is a parity disk, update the appropriate `parity`
option.
If you have multiple failed disks, update all their configuration options.
<h4><a name="4.4.2">4.4.2</a> 
STEP 2 -&gt; Fix
</h4>
Run the fix command, storing the log in an external file with:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -d NAME -l fix.log fix
</pre>
</td></tr></table>
<p>
Where NAME is the name of the disk, such as `d1` in our previous example.
If the disk to recover is a parity disk, use the names `parity`, `2-parity`,
etc.
If you have multiple failed disks, use multiple -d options to specify all
of them.
<p>
This command will take a long time.
<p>
Ensure you have a few gigabytes free to store the fix.log file.
Run it from a disk with sufficient free space.
<p>
Now you have recovered all that is recoverable. If some files are partially
or totally unrecoverable, they will be renamed by adding the `.unrecoverable`
extension.
<p>
You can find a detailed list of all unrecoverable blocks in the fix.log file
by checking all lines starting with `unrecoverable:`.
<p>
If you are not satisfied with the recovery, you can retry it as many
times as you wish.
<p>
For example, if you have removed files from the array after the last
`sync`, this may result in some files not being recovered.
In this case, you can retry the `fix` using the -i, --import option,
specifying where these files are now to include them again in the
recovery process.
<p>
If you are satisfied with the recovery, you can proceed further,
but note that after syncing, you cannot retry the `fix` command
anymore!
<h4><a name="4.4.3">4.4.3</a> 
STEP 3 -&gt; Check
</h4>
As a cautious check, you can now run a `check` command to ensure that
everything is correct on the recovered disk.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -d NAME -a check
</pre>
</td></tr></table>
<p>
Where NAME is the name of the disk, such as `d1` in our previous example.
<p>
The -d and -a options tell SnapRAID to check only the specified disk
and ignore all parity data.
<p>
This command will take a long time, but if you are not overly cautious,
you can skip it.
<h4><a name="4.4.4">4.4.4</a> 
STEP 4 -&gt; Sync
</h4>
Run the `sync` command to resynchronize the array with the new disk.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid sync
</pre>
</td></tr></table>
<p>
If everything is recovered, this command is immediate.
<h2><a name="5">5</a> 
Commands
</h2>
SnapRAID provides a few simple commands that allow you to:
<ul>
<li>
Print the status of the array -&gt; `status`
</li>
<li>
Control the disks -&gt; `smart`, `probe`, `up`, `down`
</li>
<li>
Make a backup/snapshot -&gt; `sync`
</li>
<li>
Periodically check data -&gt; `scrub`
</li>
<li>
Restore the last backup/snapshot -&gt; `fix`.
</li>
</ul>
<p>
Commands must be written in lowercase.
<h3><a name="5.1">5.1</a> 
status
</h3>
Prints a summary of the state of the disk array.
<p>
It includes information about parity fragmentation, how old
the blocks are without checking, and all recorded silent
errors encountered while scrubbing.
<p>
The information presented refers to the latest time you
ran `sync`. Later modifications are not taken into account.
<p>
If bad blocks were detected, their block numbers are listed.
To fix them, you can use the `fix -e` command.
<p>
It also shows a graph representing the last time each block
was scrubbed or synced. Scrubbed blocks are shown with '*',
blocks synced but not yet scrubbed with 'o'.
<p>
Nothing is modified.
<h3><a name="5.2">5.2</a> 
smart
</h3>
Prints a SMART report of all the disks in the system.
<p>
It includes an estimation of the probability of failure in the next
year, allowing you to plan maintenance replacements of disks that show
suspicious attributes.
<p>
This probability estimation is obtained by correlating the SMART attributes
of the disks with the Backblaze data available at:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.backblaze.com/hard-drive-test-data.html
</pre>
</td></tr></table>
<p>
If SMART reports that a disk is failing, `FAIL` or `PREFAIL` is printed
for that disk, and SnapRAID returns with an error.
In this case, immediate replacement of the disk is highly recommended.
<p>
Other possible status strings are:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
logfail
</em></td><td width="90%">
In the past, some attributes were lower than
the threshold.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
logerr
</em></td><td width="90%">
The device error log contains errors.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
selferr
</em></td><td width="90%">
The device self-test log contains errors.
</td></tr>
</table>
<p>
If the -v, --verbose option is specified, a deeper statistical analysis
is provided. This analysis can help you decide if you need more
or less parity.
<p>
This command uses the `smartctl` tool and is equivalent to running
`smartctl -a` on all devices.
<p>
If your devices are not auto-detected correctly, you can specify
a custom command using the `smartctl` option in the configuration
file.
<p>
Nothing is modified.
<h3><a name="5.3">5.3</a> 
probe
</h3>
Prints the POWER state of all disks in the system.
<p>
`Standby` means the disk is not spinning. `Active` means
the disk is spinning.
<p>
This command uses the `smartctl` tool and is equivalent to running
`smartctl -n standby -i` on all devices.
<p>
If your devices are not auto-detected correctly, you can specify
a custom command using the `smartctl` option in the configuration
file.
<p>
Nothing is modified.
<h3><a name="5.4">5.4</a> 
up
</h3>
Spins up all the disks of the array.
<p>
You can spin up only specific disks using the -d, --filter-disk option.
<p>
Spinning up all the disks at the same time requires a lot of power.
Ensure that your power supply can sustain it.
<p>
Nothing is modified.
<h3><a name="5.5">5.5</a> 
down
</h3>
Spins down all the disks of the array.
<p>
This command uses the `smartctl` tool and is equivalent to running
`smartctl -s standby,now` on all devices.
<p>
You can spin down only specific disks using the -d, --filter-disk
option.
<p>
To automatically spin down on error, you can use the -s, --spin-down-on-error
option with any other command, which is equivalent to running `down` manually
when an error occurs.
<p>
Nothing is modified.
<h3><a name="5.6">5.6</a> 
diff
</h3>
Lists all the files modified since the last `sync` that need to have
their parity data recomputed.
<p>
This command doesn't check the file data, but only the file timestamp,
size, and inode.
<p>
After listing all changed files, a summary of the changes is
presented, grouped by:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
equal
</em></td><td width="90%">
Files unchanged from before.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
added
</em></td><td width="90%">
Files added that were not present before.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
removed
</em></td><td width="90%">
Files removed.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
updated
</em></td><td width="90%">
Files with a different size or timestamp, meaning they
were modified.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
moved
</em></td><td width="90%">
Files moved to a different directory on the same disk.
They are identified by having the same name, size, timestamp,
and inode, but a different directory.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
copied
</em></td><td width="90%">
Files copied on the same or a different disk. Note that if
they are truly moved to a different disk, they will also be
counted in `removed`.
They are identified by having the same name, size, and
timestamp. If the sub-second timestamp is zero,
the full path must match, not just the name.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
restored
</em></td><td width="90%">
Files with a different inode but matching name, size, and timestamp.
These are usually files restored after being deleted.
</td></tr>
</table>
<p>
If a `sync` is required, the process return code is 2, instead of the
default 0. The return code 1 is used for a generic error condition.
<p>
Nothing is modified.
<h3><a name="5.7">5.7</a> 
sync
</h3>
Updates the parity information. All modified files
in the disk array are read, and the corresponding parity
data is updated.
<p>
You can stop this process at any time by pressing Ctrl+C,
without losing the work already done.
At the next run, the `sync` process will resume where
it was interrupted.
<p>
If silent or input/output errors are found during the process,
the corresponding blocks are marked as bad.
<p>
Files are identified by path and/or inode and checked by
size and timestamp.
If the file size or timestamp differs, the parity data
is recomputed for the entire file.
If the file is moved or renamed on the same disk, keeping the
same inode, the parity is not recomputed.
If the file is moved to another disk, the parity is recomputed,
but the previously computed hash information is retained.
<p>
The `content` and `parity` files are modified if necessary.
The files in the array are NOT modified.
<h3><a name="5.8">5.8</a> 
scrub
</h3>
Scrubs the array, checking for silent or input/output errors in data
and parity disks.
<p>
Each invocation checks approximately 8% of the array, excluding
data already scrubbed in the last 10 days.
This means that scrubbing once a week ensures every bit of data is checked
at least once every three months.
<p>
You can define a different scrub plan or amount using the -p, --plan
option, which accepts:
bad - Scrub blocks marked bad.
new - Scrub just-synced blocks not yet scrubbed.
full - Scrub everything.
0-100 - Scrub the specified percentage of blocks.
<p>
If you specify a percentage amount, you can also use the -o, --older-than
option to define how old the block should be.
The oldest blocks are scrubbed first, ensuring an optimal check.
If you want to scrub only the just-synced blocks not yet scrubbed,
use the `-p new` option.
<p>
To get details of the scrub status, use the `status` command.
<p>
For any silent or input/output error found, the corresponding blocks
are marked as bad in the `content` file.
These bad blocks are listed in `status` and can be fixed with `fix -e`.
After the fix, at the next scrub, they will be rechecked, and if found
corrected, the bad mark will be removed.
To scrub only the bad blocks, you can use the `scrub -p bad` command.
<p>
It's recommended to run `scrub` only on a synced array to avoid
reported errors caused by unsynced data. These errors are recognized
as not being silent errors, and the blocks are not marked as bad,
but such errors are reported in the output of the command.
<p>
The `content` file is modified to update the time of the last check
for each block and to mark bad blocks.
The `parity` files are NOT modified.
The files in the array are NOT modified.
<h3><a name="5.9">5.9</a> 
fix
</h3>
Fixes all the files and the parity data.
<p>
All files and parity data are compared with the snapshot
state saved in the last `sync`.
If a difference is found, it is reverted to the stored snapshot.
<p>
WARNING! The `fix` command does not differentiate between errors and
intentional modifications. It unconditionally reverts the file state
to the last `sync`.
<p>
If no other option is specified, the entire array is processed.
Use the filter options to select a subset of files or disks to operate on.
<p>
To fix only the blocks marked bad during `sync` and `scrub`,
use the -e, --filter-error option.
Unlike other filter options, this one applies fixes only to files that are
unchanged since the latest `sync`.
<p>
SnapRAID renames all files that cannot be fixed by adding the
`.unrecoverable` extension.
<p>
Before fixing, the entire array is scanned to find any files moved
since the last `sync` operation.
These files are identified by their timestamp, ignoring their name
and directory, and are used in the recovery process if necessary.
If you moved some of them outside the array, you can use the -i, --import
option to specify additional directories to scan.
<p>
Files are identified only by path, not by inode.
<p>
The `content` file is NOT modified.
The `parity` files are modified if necessary.
The files in the array are modified if necessary.
<h3><a name="5.10">5.10</a> 
check
</h3>
Verifies all the files and the parity data.
<p>
It works like `fix`, but it only simulates a recovery and no changes
are written to the array.
<p>
This command is primarily intended for manual verification,
such as after a recovery process or in other special conditions.
For periodic and scheduled checks, use `scrub`.
<p>
If you use the -a, --audit-only option, only the file
data is checked, and the parity data is ignored for a
faster run.
<p>
Files are identified only by path, not by inode.
<p>
Nothing is modified.
<h3><a name="5.11">5.11</a> 
list
</h3>
Lists all the files contained in the array at the time of the
last `sync`.
<p>
With -v or --verbose, the subsecond time is also shown.
<p>
Nothing is modified.
<h3><a name="5.12">5.12</a> 
dup
</h3>
Lists all duplicate files. Two files are assumed equal if their
hashes match. The file data is not read; only the
precomputed hashes are used.
<p>
Nothing is modified.
<h3><a name="5.13">5.13</a> 
pool
</h3>
Creates or updates a virtual view of all
the files in your disk array in the `pooling` directory.
<p>
The files are not copied but linked using
symbolic links.
<p>
When updating, all existing symbolic links and empty
subdirectories are deleted and replaced with the new
view of the array. Any other regular files are left in place.
<p>
Nothing is modified outside the pool directory.
<h3><a name="5.14">5.14</a> 
devices
</h3>
Prints the low-level devices used by the array.
<p>
This command displays the device associations in the array
and is mainly intended as a script interface.
<p>
The first two columns are the low-level device ID and path.
The next two columns are the high-level device ID and path.
The last column is the disk name in the array.
<p>
In most cases, you have one low-level device for each disk in the
array, but in some more complex configurations, you may have multiple
low-level devices used by a single disk in the array.
<p>
Nothing is modified.
<h3><a name="5.15">5.15</a> 
touch
</h3>
Sets an arbitrary sub-second timestamp for all files
that have it set to zero.
<p>
This improves SnapRAID's ability to recognize moved
and copied files, as it makes the timestamp almost unique,
reducing possible duplicates.
<p>
More specifically, if the sub-second timestamp is not zero,
a moved or copied file is identified as such if it matches
the name, size, and timestamp. If the sub-second timestamp
is zero, it is considered a copy only if the full path,
size, and timestamp all match.
<p>
The second-precision timestamp is not modified,
so all the dates and times of your files will be preserved.
<h3><a name="5.16">5.16</a> 
rehash
</h3>
Schedules a rehash of the entire array.
<p>
This command changes the hash kind used, typically when upgrading
from a 32-bit system to a 64-bit one, to switch from
MurmurHash3 to the faster SpookyHash.
<p>
If you are already using the optimal hash, this command
does nothing and informs you that no action is needed.
<p>
The rehash is not performed immediately but takes place
progressively during `sync` and `scrub`.
<p>
You can check the rehash state using `status`.
<p>
During the rehash, SnapRAID maintains full functionality,
with the only exception that `dup` cannot detect duplicated
files using a different hash.
<h2><a name="6">6</a> 
Options
</h2>
SnapRAID provides the following options:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-c, --conf CONFIG
</strong></td></tr><tr><td>
Selects the configuration file to use. If not specified, in Unix
it uses the file `/usr/local/etc/snapraid.conf` if it exists,
otherwise `/etc/snapraid.conf`.
In Windows, it uses the file `snapraid.conf` in the same
directory as `snapraid.exe`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-f, --filter PATTERN
</strong></td></tr><tr><td>
Filters the files to process in `check` and `fix`.
Only the files matching the specified pattern are processed.
This option can be used multiple times.
See the PATTERN section for more details on
pattern specifications.
In Unix, ensure globbing characters are quoted if used.
This option can be used only with `check` and `fix`.
It cannot be used with `sync` and `scrub`, as they always
process the entire array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-d, --filter-disk NAME
</strong></td></tr><tr><td>
Filters the disks to process in `check`, `fix`, `up`, and `down`.
You must specify a disk name as defined in the configuration
file.
You can also specify parity disks with the names: `parity`, `2-parity`,
`3-parity`, etc., to limit operations to a specific parity disk.
If you combine multiple --filter, --filter-disk, and --filter-missing options,
only files matching all the filters are selected.
This option can be used multiple times.
This option can be used only with `check`, `fix`, `up`, and `down`.
It cannot be used with `sync` and `scrub`, as they always
process the entire array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-m, --filter-missing
</strong></td></tr><tr><td>
Filters the files to process in `check` and `fix`.
Only the files missing or deleted from the array are processed.
When used with `fix`, this acts as an `undelete` command.
If you combine multiple --filter, --filter-disk, and --filter-missing options,
only files matching all the filters are selected.
This option can be used only with `check` and `fix`.
It cannot be used with `sync` and `scrub`, as they always
process the entire array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-e, --filter-error
</strong></td></tr><tr><td>
Processes the files with errors in `check` and `fix`.
It processes only files that have blocks marked with silent
or input/output errors during `sync` and `scrub`, as listed in `status`.
This option can be used only with `check` and `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-p, --plan PERC|bad|new|full
</strong></td></tr><tr><td>
Selects the scrub plan. If PERC is a numeric value from 0 to 100,
it is interpreted as the percentage of blocks to scrub.
Instead of a percentage, you can specify a plan:
`bad` scrubs bad blocks, `new` scrubs blocks not yet scrubbed,
and `full` scrubs everything.
This option can be used only with `scrub`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-o, --older-than DAYS
</strong></td></tr><tr><td>
Selects the oldest part of the array to process in `scrub`.
DAYS is the minimum age in days for a block to be scrubbed;
the default is 10.
Blocks marked as bad are always scrubbed regardless of this option.
This option can be used only with `scrub`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-a, --audit-only
</strong></td></tr><tr><td>
In `check`, verifies the hash of the files without
checking the parity data.
If you are interested only in checking the file data, this
option can significantly speed up the checking process.
This option can be used only with `check`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-h, --pre-hash
</strong></td></tr><tr><td>
In `sync`, runs a preliminary hashing phase of all new data
for additional verification before the parity computation.
Usually, in `sync`, no preliminary hashing is done, and the new
data is hashed just before the parity computation when it is read
for the first time.
This process occurs when the system is under
heavy load, with all disks spinning and a busy CPU.
This is an extreme condition for the machine, and if it has a
latent hardware problem, silent errors may go undetected
because the data is not yet hashed.
To avoid this risk, you can enable the `pre-hash` mode to have
all the data read twice to ensure its integrity.
This option also verifies files moved within the array
to ensure the move operation was successful and, if necessary,
allows you to run a fix operation before proceeding.
This option can be used only with `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-i, --import DIR
</strong></td></tr><tr><td>
Imports from the specified directory any files deleted
from the array after the last `sync`.
If you still have such files, they can be used by `check`
and `fix` to improve the recovery process.
The files are read, including in subdirectories, and are
identified regardless of their name.
This option can be used only with `check` and `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-s, --spin-down-on-error
</strong></td></tr><tr><td>
On any error, spins down all managed disks before exiting with
a non-zero status code. This prevents the drives from
remaining active and spinning after an aborted operation,
helping to avoid unnecessary heat buildup and power
consumption. Use this option to ensure disks are safely
stopped even when a command fails.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-w, --bw-limit RATE
</strong></td></tr><tr><td>
Applies a global bandwidth limit for all disks. The RATE is
the number of bytes per second. You can specify a multiplier
such as K, M, or G (e.g., --bw-limit 1G).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-A, --stats
</strong></td></tr><tr><td>
Enables an extended status view that shows additional information.
The screen displays two graphs:
The first graph shows the number of buffered stripes for each
disk, along with the file path of the file currently being
accessed on that disk. Typically, the slowest disk will have
no buffer available, which determines the maximum achievable
bandwidth.
The second graph shows the percentage of time spent waiting
over the past 100 seconds. The slowest disk is expected to
cause most of the wait time, while other disks should have
little or no wait time because they can use their buffered stripes.
This graph also shows the time spent waiting for hash
calculations and RAID computations.
All computations run in parallel with disk operations.
Therefore, as long as there is measurable wait time for at
least one disk, it indicates that the CPU is fast enough to
keep up with the workload.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-Z, --force-zero
</strong></td></tr><tr><td>
Forces the insecure operation of syncing a file with zero
size that was previously non-zero.
If SnapRAID detects such a condition, it stops proceeding
unless you specify this option.
This allows you to easily detect when, after a system crash,
some accessed files were truncated.
This is a possible condition in Linux with the ext3/ext4
file systems.
This option can be used only with `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-E, --force-empty
</strong></td></tr><tr><td>
Forces the insecure operation of syncing a disk with all
the original files missing.
If SnapRAID detects that all the files originally present
on the disk are missing or rewritten, it stops proceeding
unless you specify this option.
This allows you to easily detect when a data file system is not
mounted.
This option can be used only with `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-U, --force-uuid
</strong></td></tr><tr><td>
Forces the insecure operation of syncing, checking, and fixing
with disks that have changed their UUID.
If SnapRAID detects that some disks have changed UUID,
it stops proceeding unless you specify this option.
This allows you to detect when your disks are mounted at the
wrong mount points.
It is, however, allowed to have a single UUID change with
single parity, and more with multiple parity, because this is
the normal case when replacing disks after a recovery.
This option can be used only with `sync`, `check`, or
`fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-D, --force-device
</strong></td></tr><tr><td>
Forces the insecure operation of fixing with inaccessible disks
or with disks on the same physical device.
For example, if you lost two data disks and have a spare disk to recover
only the first one, you can ignore the second inaccessible disk.
Or, if you want to recover a disk in the free space left on an
already used disk, sharing the same physical device.
This option can be used only with `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-N, --force-nocopy
</strong></td></tr><tr><td>
In `sync`, `check`, and `fix`, disables the copy detection heuristic.
Without this option, SnapRAID assumes that files with the same
attributes, such as name, size, and timestamp, are copies with the
same data.
This allows identification of copied or moved files from one disk
to another and reuses the already computed hash information
to detect silent errors or to recover missing files.
In some rare cases, this behavior may result in false positives
or a slow process due to many hash verifications, and this
option allows you to resolve such issues.
This option can be used only with `sync`, `check`, and `fix`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-F, --force-full
</strong></td></tr><tr><td>
In `sync`, forces a full recomputation of the parity.
This option can be used when you add a new parity level or if
you reverted to an old content file using more recent parity data.
Instead of recreating the parity from scratch, this allows
you to reuse the hashes present in the content file to validate data
and maintain data protection during the `sync` process using
the existing parity data.
This option can be used only with `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-R, --force-realloc
</strong></td></tr><tr><td>
In `sync`, forces a full reallocation of files and rebuild of the parity.
This option can be used to completely reallocate all files,
removing fragmentation, while reusing the hashes present in the content
file to validate data.
This option can be used only with `sync`.
WARNING! This option is for experts only, and it is highly
recommended not to use it.
You DO NOT have data protection during the `sync` operation.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-l, --log FILE
</strong></td></tr><tr><td>
Writes a detailed log to the specified file.
If this option is not specified, unexpected errors are printed
to the screen, potentially resulting in excessive output in case of
many errors. When -l, --log is specified, only
fatal errors that cause SnapRAID to stop are printed
to the screen.
If the path starts with '&gt;&gt;', the file is opened
in append mode. Occurrences of '%D' and '%T' in the name are
replaced with the date and time in the format YYYYMMDD and
HHMMSS. In Windows batch files, you must double
the '%' character, e.g., result-%%D.log. To use '&gt;&gt;', you must
enclose the name in quotes, e.g., `"&gt;&gt;result.log"`.
To output the log to standard output or standard error,
you can use `"&gt;&amp;1"` and `"&gt;&amp;2"`, respectively.
See the snapraid_log.txt file or man page for log tag descriptions.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-L, --error-limit NUMBER
</strong></td></tr><tr><td>
Sets a new error limit before stopping execution.
By default, SnapRAID stops if it encounters more than 100
input/output errors, indicating that a disk is likely failing.
This option affects `sync` and `scrub`, which are allowed
to continue after the first set of disk errors to try
to complete their operations.
However, `check` and `fix` always stop at the first error.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-S, --start BLKSTART
</strong></td></tr><tr><td>
Starts processing from the specified
block number. This can be useful for retrying to check
or fix specific blocks in case of a damaged disk.
This option is mainly for advanced manual recovery.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-B, --count BLKCOUNT
</strong></td></tr><tr><td>
Processes only the specified number of blocks.
This option is mainly for advanced manual recovery.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-C, --gen-conf CONTENT
</strong></td></tr><tr><td>
Generates a dummy configuration file from an existing
content file.
The configuration file is written to standard output
and does not overwrite an existing one.
This configuration file also contains the information
needed to reconstruct the disk mount points in case you
lose the entire system.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-v, --verbose
</strong></td></tr><tr><td>
Prints more information to the screen.
If specified once, it prints excluded files
and additional statistics.
This option has no effect on the log files.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-q, --quiet
</strong></td></tr><tr><td>
Prints less information to the screen.
If specified once, it removes the progress bar; twice,
the running operations; three times, the info
messages; four times, the status messages.
Fatal errors are always printed to the screen.
This option has no effect on the log files.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-H, --help
</strong></td></tr><tr><td>
Prints a short help screen.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-V, --version
</strong></td></tr><tr><td>
Prints the program version.
</td></tr>
</table>
<h2><a name="7">7</a> 
Configuration
</h2>
SnapRAID requires a configuration file to know where your disk array
is located and where to store the parity information.
<p>
In Unix, it uses the file `/usr/local/etc/snapraid.conf` if it exists,
otherwise `/etc/snapraid.conf`.
In Windows, it uses the file `snapraid.conf` in the same
directory as `snapraid.exe`.
<p>
It must contain the following options (case-sensitive):
<h3><a name="7.1">7.1</a> 
parity FILE [,FILE] ...
</h3>
Defines the files to use to store the parity information.
The parity enables protection from a single disk
failure, similar to RAID5.
<p>
You can specify multiple files, which must be on different disks.
When a file cannot grow anymore, the next one is used.
The total space available must be at least as large as the largest data disk in
the array.
<p>
You can add additional parity files later, but you
cannot reorder or remove them.
<p>
Keeping the parity disks reserved for parity ensures that
they do not become fragmented, improving performance.
<p>
In Windows, 256 MB is left unused on each disk to avoid the
warning about full disks.
<p>
This option is mandatory and can be used only once.
<h3><a name="7.2">7.2</a> 
(2,3,4,5,6)-parity FILE [,FILE] ...
</h3>
Defines the files to use to store extra parity information.
<p>
For each parity level specified, one additional level of protection
is enabled:
<ul>
<li>
2-parity enables RAID6 dual parity.
</li>
<li>
3-parity enables triple parity.
</li>
<li>
4-parity enables quad (four) parity.
</li>
<li>
5-parity enables penta (five) parity.
</li>
<li>
6-parity enables hexa (six) parity.
</li>
</ul>
<p>
Each parity level requires the presence of all previous parity
levels.
<p>
The same considerations as for the 'parity' option apply.
<p>
These options are optional and can be used only once.
<h3><a name="7.3">7.3</a> 
z-parity FILE [,FILE] ...
</h3>
Defines an alternate file and format to store triple parity.
<p>
This option is an alternative to '3-parity', primarily intended for
low-end CPUs like ARM or AMD Phenom, Athlon, and Opteron that do not
support the SSSE3 instruction set. In such cases, it provides
better performance.
<p>
This format is similar to but faster than the one used by ZFS RAIDZ3.
Like ZFS, it does not work beyond triple parity.
<p>
When using '3-parity', you will be warned if it is recommended to use
the 'z-parity' format for performance improvement.
<p>
It is possible to convert from one format to another by adjusting
the configuration file with the desired z-parity or 3-parity file
and using 'fix' to recreate it.
<h3><a name="7.4">7.4</a> 
content FILE
</h3>
Defines the file to use to store the list and checksums of all the
files present in your disk array.
<p>
It can be placed on a disk used for data, parity, or
any other disk available.
If you use a data disk, this file is automatically excluded
from the `sync` process.
<p>
This option is mandatory and can be used multiple times to save
multiple copies of the same file.
<p>
You must store at least one copy for each parity disk used
plus one. Using additional copies does not hurt.
<h3><a name="7.5">7.5</a> 
data NAME DIR
</h3>
Defines the name and mount point of the data disks in
the array. NAME is used to identify the disk and must
be unique. DIR is the mount point of the disk in the
file system.
<p>
You can change the mount point as needed, as long as
you keep the NAME fixed.
<p>
You should use one option for each data disk in the array.
<p>
You can rename a disk later by changing the NAME directly
in the configuration file and then running a 'sync' command.
In the case of renaming, the association is done using the stored
UUID of the disks.
<h3><a name="7.6">7.6</a> 
nohidden
</h3>
Excludes all hidden files and directories.
In Unix, hidden files are those starting with `.`.
In Windows, they are those with the hidden attribute.
<h3><a name="7.7">7.7</a> 
exclude/include PATTERN
</h3>
Defines the file or directory patterns to exclude or include
in the sync process.
All patterns are processed in the specified order.
<p>
If the first pattern that matches is an `exclude` one, the file
is excluded. If it is an `include` one, the file is included.
If no pattern matches, the file is excluded if the last pattern
specified is an `include`, or included if the last pattern
specified is an `exclude`.
<p>
See the PATTERN section for more details on pattern
specifications.
<p>
This option can be used multiple times.
<h3><a name="7.8">7.8</a> 
blocksize SIZE_IN_KIBIBYTES
</h3>
Defines the basic block size in kibibytes for the parity.
One kibibyte is 1024 bytes.
<p>
The default blocksize is 256, which should work for most cases.
<p>
WARNING! This option is for experts only, and it is highly
recommended not to change this value. To change this value in the
future, you will need to recreate the entire parity!
<p>
A reason to use a different blocksize is if you have many small
files, on the order of millions.
<p>
For each file, even if only a few bytes, an entire block of parity is allocated,
and with many files, this may result in significant unused parity space.
When you completely fill the parity disk, you are not
allowed to add more files to the data disks.
However, the wasted parity does not accumulate across data disks. Wasted space
resulting from a high number of files on a data disk limits only
the amount of data on that data disk, not others.
<p>
As an approximation, you can assume that half of the block size is
wasted for each file. For example, with 100,000 files and a 256 KiB
block size, you will waste 12.8 GB of parity, which may result
in 12.8 GB less space available on the data disk.
<p>
You can check the amount of wasted space on each disk using `status`.
This is the amount of space you must leave free on the data
disks or use for files not included in the array.
If this value is negative, it means you are close to filling
the parity, and it represents the space you can still waste.
<p>
To avoid this issue, you can use a larger partition for parity.
For example, if the parity partition is 12.8 GB larger than the data disks,
you have enough extra space to handle up to 100,000
files on each data disk without any wasted space.
<p>
A trick to get a larger parity partition in Linux is to format it
with the command:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
mkfs.ext4 -m 0 -T largefile4 DEVICE
</pre>
</td></tr></table>
<p>
This results in about 1.5% extra space, approximately 60 GB for
a 4 TB disk, which allows about 460,000 files on each data disk without
any wasted space.
<h3><a name="7.9">7.9</a> 
hashsize SIZE_IN_BYTES
</h3>
Defines the hash size in bytes for the saved blocks.
<p>
The default hashsize is 16 bytes (128 bits), which should work
for most cases.
<p>
WARNING! This option is for experts only, and it is highly
recommended not to change this value. To change this value in the
future, you will need to recreate the entire parity!
<p>
A reason to use a different hashsize is if your system has
limited memory. As a rule of thumb, SnapRAID typically requires
1 GiB of RAM for each 16 TB of data in the array.
<p>
Specifically, to store the hashes of the data, SnapRAID requires
approximately TS*(1+HS)/BS bytes of RAM,
where TS is the total size in bytes of your disk array, BS is the
block size in bytes, and HS is the hash size in bytes.
<p>
For example, with 8 disks of 4 TB, a block size of 256 KiB
(1 KiB = 1024 bytes), and a hash size of 16, you get:
<p>
<pre>
RAM = (8 * 4 * 10^12) * (1+16) / (256 * 2^10) = 1.93 GiB
</pre>
<p>
Switching to a hash size of 8, you get:
<p>
<pre>
RAM = (8 * 4 * 10^12) * (1+8) / (256 * 2^10) = 1.02 GiB
</pre>
<p>
Switching to a block size of 512, you get:
<p>
<pre>
RAM = (8 * 4 * 10^12) * (1+16) / (512 * 2^10) = 0.96 GiB
</pre>
<p>
Switching to both a hash size of 8 and a block size of 512, you get:
<p>
<pre>
RAM = (8 * 4 * 10^12) * (1+8) / (512 * 2^10) = 0.51 GiB
</pre>
<h3><a name="7.10">7.10</a> 
autosave SIZE_IN_GIGABYTES
</h3>
Automatically saves the state when syncing or scrubbing after the
specified amount of GB processed.
This option is useful to avoid restarting long `sync`
commands from scratch if interrupted by a machine crash or any other event.
<h3><a name="7.11">7.11</a> 
temp_limit TEMPERATURE_CELSIUS
</h3>
Sets the maximum allowed disk temperature in Celsius. When specified,
SnapRAID periodically checks the temperature of all disks using the
smartctl tool. The current disk temperatures are displayed while
SnapRAID is operating. If any disk exceeds this limit, all operations
stop, and the disks are spun down (put into standby) for the duration
defined by the `temp_sleep` option. After the sleep period, operations
resume, potentially pausing again if the temperature limit is reached
once more.
<p>
During operation, SnapRAID also analyzes the heating curve of each
disk and estimates the long-term steady temperature they are expected
to reach if activity continues. The estimation is performed only after
the disk temperature has increased four times, ensuring that enough
data points are available to establish a reliable trend.
This predicted steady temperature is shown in parentheses next to the
current value and helps assess whether the system's cooling is
adequate. This estimated temperature is for informational purposes
only and has no effect on the behavior of SnapRAID. The program's
actions are based solely on the actual measured disk temperatures.
<p>
To perform this analysis, SnapRAID needs a reference for the system
temperature. It first attempts to read it from available hardware
sensors. If no system sensor can be accessed, it uses the lowest disk
temperature measured at the start of the run as a fallback reference.
<p>
Normally, SnapRAID shows only the temperature of the hottest disk.
To display the temperature of all disks, use the -A or --stats option.
<h3><a name="7.12">7.12</a> 
temp_sleep TIME_IN_MINUTES
</h3>
Sets the standby time, in minutes, when the temperature limit is
reached. During this period, the disks remain spun down. The default
is 5 minutes.
<h3><a name="7.13">7.13</a> 
pool DIR
</h3>
Defines the pooling directory where the virtual view of the disk
array is created using the `pool` command.
<p>
The directory must already exist.
<h3><a name="7.14">7.14</a> 
share UNC_DIR
</h3>
Defines the Windows UNC path required to access the disks remotely.
<p>
If this option is specified, the symbolic links created in the pool
directory use this UNC path to access the disks.
Without this option, the symbolic links generated use only local paths,
which does not allow sharing the pool directory over the network.
<p>
The symbolic links are formed using the specified UNC path, adding the
disk name as specified in the `data` option, and finally adding the
file directory and name.
<p>
This option is required only for Windows.
<h3><a name="7.15">7.15</a> 
smartctl DISK/PARITY OPTIONS...
</h3>
Defines custom smartctl options to obtain the SMART attributes for
each disk. This may be required for RAID controllers and some USB
disks that cannot be auto-detected. The %s placeholder is replaced by
the device name, but it is optional for fixed devices like RAID controllers.
<p>
DISK is the same disk name specified in the `data` option.
PARITY is one of the parity names: `parity`, `2-parity`, `3-parity`,
`4-parity`, `5-parity`, `6-parity`, or `z-parity`.
<p>
In the specified OPTIONS, the `%s` string is replaced by the
device name. For RAID controllers, the device is
likely fixed, and you may not need to use `%s`.
<p>
Refer to the smartmontools documentation for possible options:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.smartmontools.org/wiki/Supported_RAID-Controllers
https://www.smartmontools.org/wiki/Supported_USB-Devices
</pre>
</td></tr></table>
<p>
For example:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
smartctl parity -d sat %s
</pre>
</td></tr></table>
<h3><a name="7.16">7.16</a> 
smartignore DISK/PARITY ATTR [ATTR...]
</h3>
Ignores the specified SMART attribute when computing the probability
of disk failure. This option is useful if a disk reports unusual or
misleading values for a particular attribute.
<p>
DISK is the same disk name specified in the `data` option.
PARITY is one of the parity names: `parity`, `2-parity`, `3-parity`,
`4-parity`, `5-parity`, `6-parity`, or `z-parity`.
The special value * can be used to ignore the attribute on all disks.
<p>
For example, to ignore the `Current Pending Sector Count` attribute on
all disks:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
smartignore * 197
</pre>
</td></tr></table>
<p>
To ignore it only on the first parity disk:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
smartignore parity 197
</pre>
</td></tr></table>
<h3><a name="7.17">7.17</a> 
Examples
</h3>
An example of a typical configuration for Unix is:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity /mnt/diskp/snapraid.parity
content /mnt/diskp/snapraid.content
content /var/snapraid/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
exclude /lost+found/
exclude /tmp/
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/sg0
smartctl 2-parity -d areca,2/1 /dev/sg0
</pre>
</td></tr></table>
<p>
An example of a typical configuration for Windows is:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity E:\snapraid.parity
content E:\snapraid.content
content C:\snapraid\snapraid.content
data d1 G:\array\
data d2 H:\array\
data d3 I:\array\
exclude Thumbs.db
exclude \$RECYCLE.BIN
exclude \System Volume Information
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/arcmsr0
smartctl 2-parity -d areca,2/1 /dev/arcmsr0
</pre>
</td></tr></table>
<h2><a name="8">8</a> 
Pattern
</h2>
Patterns are used to select a subset of files to exclude or include in
the process.
<p>
There are four different types of patterns:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
FILE
</strong></td></tr><tr><td>
Selects any file named FILE. You can use any globbing
characters like * and ?, and character classes like [a-z].
This pattern applies only to files, not directories.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
DIR/
</strong></td></tr><tr><td>
Selects any directory named DIR and everything inside.
You can use any globbing characters like * and ?.
This pattern applies only to directories, not files.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
/PATH/FILE
</strong></td></tr><tr><td>
Selects the exact specified file path. You can use any
globbing characters like * and ?, but they never match a
directory slash.
This pattern applies only to files, not directories.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
/PATH/DIR/
</strong></td></tr><tr><td>
Selects the exact specified directory path and everything
inside. You can use any globbing characters like * and ?, but
they never match a directory slash.
This pattern applies only to directories, not files.
</td></tr>
</table>
<p>
When you specify an absolute path starting with /, it is applied at
the array root directory, not the local file system root directory.
<p>
In Windows, you can use the backslash \ instead of the forward slash /.
Windows system directories, junctions, mount points, and other Windows
special directories are treated as files, meaning that to exclude
them, you must use a file rule, not a directory one.
<p>
If the file name contains a '*', '?', '[',
or ']' character, you must escape it to avoid having it interpreted as a
globbing character. In Unix, the escape character is '\'; in Windows, it is '^'.
When the pattern is on the command line, you must double the escape
character to avoid having it interpreted by the command shell.
<p>
In the configuration file, you can use different strategies to filter
the files to process.
The simplest approach is to use only `exclude` rules to remove all the
files and directories you do not want to process. For example:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Excludes any file named `*.unrecoverable`
exclude *.unrecoverable
# Excludes the root directory `/lost+found`
exclude /lost+found/
# Excludes any subdirectory named `tmp`
exclude tmp/
</pre>
</td></tr></table>
<p>
The opposite approach is to define only the files you want to process, using
only `include` rules. For example:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Includes only some directories
include /movies/
include /musics/
include /pictures/
</pre>
</td></tr></table>
<p>
The final approach is to mix `exclude` and `include` rules. In this case,
the order of rules is important. Earlier rules take
precedence over later ones.
To simplify, you can list all the `exclude` rules first and then
all the `include` rules. For example:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Excludes any file named `*.unrecoverable`
exclude *.unrecoverable
# Excludes any subdirectory named `tmp`
exclude tmp/
# Includes only some directories
include /movies/
include /musics/
include /pictures/
</pre>
</td></tr></table>
<p>
On the command line, using the -f option, you can only use `include`
patterns. For example:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Checks only the .mp3 files.
# In Unix, use quotes to avoid globbing expansion by the shell.
snapraid -f "*.mp3" check
</pre>
</td></tr></table>
<p>
In Unix, when using globbing characters on the command line, you must
quote them to prevent the shell from expanding them.
<h2><a name="9">9</a> 
Content
</h2>
SnapRAID stores the list and checksums of your files in the content file.
<p>
It is a binary file that lists all the files present in your disk array,
along with all the checksums to verify their integrity.
<p>
This file is read and written by the `sync` and `scrub` commands and
read by the `fix`, `check`, and `status` commands.
<h2><a name="10">10</a> 
Parity
</h2>
SnapRAID stores the parity information of your array in the parity
files.
<p>
These are binary files containing the computed parity of all the
blocks defined in the `content` file.
<p>
These files are read and written by the `sync` and `fix` commands and
only read by the `scrub` and `check` commands.
<h2><a name="11">11</a> 
Encoding
</h2>
SnapRAID in Unix ignores any encoding. It reads and stores the
file names with the same encoding used by the file system.
<p>
In Windows, all names read from the file system are converted and
processed in UTF-8 format.
<p>
To have file names printed correctly, you must set the Windows
console to UTF-8 mode with the command `chcp 65001` and use
a TrueType font like `Lucida Console` as the console font.
This affects only the printed file names; if you
redirect the console output to a file, the resulting file is always
in UTF-8 format.


<h1>Log</h1>

<h2><a name="1">1</a> 
Description
</h2>
This document describes the structured log tags output by SnapRAID,
which are designed to be used by tools monitoring the SnapRAID
processing state. The tags provide information in an easy-to-parse
format, ideal for automation and integration.
<p>
To capture these structured log tags, you must use the `--log` option
with SnapRAID.
<p>
You can direct the output to a specific file, or force the output to
the standard output or standard error using the special arguments
`&gt;&amp;1` or `&gt;&amp;2`. Note that these arguments often need to be quoted on
the command line to prevent the shell from interpreting them.
<p>
Example:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid status --log "&gt;&amp;2"
</pre>
</td></tr></table>
<p>
The output tags strictly adhere to the following format:
<p>
<pre>
NAME:VALUE:VALUE:VALUE...&lt;EOL&gt;
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
NAME
</strong></td></tr><tr><td>
This is the primary tag identifier, always a lowercase string
without spaces (e.g., `summary`, `block`, `info_time`).
</td></tr>
<tr valign="top" align="left"><td><strong>
VALUE
</strong></td></tr><tr><td>
Following the `NAME`, these can be additional sub-identifiers,
descriptive names (like a disk name), or numeric/string data
values. They are separated by a colon `:`.
</td></tr>
<tr valign="top" align="left"><td><strong>
&lt;EOL&gt;
</strong></td></tr><tr><td>
Each tag is terminated by an end-of-line character.
</td></tr>
</table>
<p>
This document provides a summary of the tags generated by SnapRAID.
For the most detailed and up-to-date information regarding the meaning
and context of the values, it is recommended to check the source
code's `log_tag()` statements.
<p>
When a path is output, it is always escaped using a backslash (\) as
the escape character.
<p>
The following characters are escaped into sequences:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
The colon
</em></td><td width="90%">
is escaped to \d.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
The newline
</em></td><td width="90%">
is escaped to \n.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
The carriage return
</em></td><td width="90%">
is escaped to \r.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
The backslash
</em></td><td width="90%">
is escaped to \\.
</td></tr>
</table>
<p>
Some tags are output only when the `--gui` option is used. They provide
extra verbose state and runtime progress only useful for a GUI
interface.
<h2><a name="2">2</a> 
Configuration Tags
</h2>
These tags report the memory usage and global configuration after
scanning the disk and reading the list of files.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
conf:file:&lt;path&gt;
</strong></td></tr><tr><td>
Configuration file loaded (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
conf:missing:
</strong></td></tr><tr><td>
Operating without a configuration file.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
blocksize:&lt;bytes&gt;
</strong></td></tr><tr><td>
The configured block size in bytes (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
data:&lt;disk_name&gt;:&lt;dir&gt;
</strong></td></tr><tr><td>
The data disks as defined in the configuration file.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The assigned name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;dir&gt;
</em></td><td width="90%">
The directory entry point of the disk.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
mode:&lt;raidname&gt;
</strong></td></tr><tr><td>
The RAID mode used. One of `par1`, `par2`, `par3`, `par4`,
`par5`, `par6` or `parz`. The number indicates the maximum
number of simultaneous disk failures the array can withstand.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
&lt;parity_level&gt;:&lt;split_index&gt;:&lt;path&gt;
</strong></td></tr><tr><td>
The parity files as defined in the configuration file.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;parity_level&gt;
</em></td><td width="90%">
One of `parity`, `2-parity`, ..., `6-parity`.
This corresponds to the level of redundancy.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;split_index&gt;
</em></td><td width="90%">
The split index (uint). If no
multiple split parity is configured, there is only the
index 0. A split parity configuration distributes parity
blocks across multiple files.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;path&gt;
</em></td><td width="90%">
The path (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
pool:&lt;dir&gt;
</strong></td></tr><tr><td>
The configured dir to the pool mount point (escaped).
This is the optional mount point for the 'pool' feature.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
share:&lt;dir&gt;
</strong></td></tr><tr><td>
The configured dir to the pool mount point (escaped).
This is the optional mount point for the 'share' feature.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
autosave:&lt;bytes&gt;
</strong></td></tr><tr><td>
If the autosave feature is enabled, and after how many bytes
(uint64). This specifies the interval for content file saving.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
filter:&lt;pattern&gt;
</strong></td></tr><tr><td>
All the active filters with their patterns. These patterns
exclude specific files or directories from the SnapRAID array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
filter:nohidden:
</strong></td></tr><tr><td>
If the no-hidden filter is enabled, meaning hidden files/directories
(starting with '.') are excluded from the array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
content:&lt;path&gt;
</strong></td></tr><tr><td>
The absolute path to a content file being used (escaped).
Content files store the metadata (like file hashes and timestamps)
for the array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
content:&lt;parity_level&gt;:&lt;split_index&gt;:&lt;path&gt;:&lt;uuid&gt;:&lt;size&gt;
</strong></td></tr><tr><td>
The parity files as stored in the content file.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;parity_level&gt;
</em></td><td width="90%">
One of `parity`, `2-parity`, ..., `6-parity`.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;split_index&gt;
</em></td><td width="90%">
The split index (uint). If no
multiple split parity is configured, there is only the
index 0.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;path&gt;
</em></td><td width="90%">
The path (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;uuid&gt;
</em></td><td width="90%">
The UUID of the partition containing the path.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;size&gt;
</em></td><td width="90%">
The size of the parity file. Size is -1 if not yet
fixed, meaning it can grow. This happens for the
latest split.
</td></tr>
</table>
<h2><a name="3">3</a> 
Diagnostics Tags
</h2>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
version:&lt;version&gt;
</strong></td></tr><tr><td>
The version of SnapRAID run.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
unixtime:&lt;time&gt;
</strong></td></tr><tr><td>
The current time in the unix format (uint64), representing
seconds since the epoch.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
time:&lt;YYYY-MM-DD HH:MM:SS&gt;
</strong></td></tr><tr><td>
The current time in human format.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
command:&lt;command&gt;
</strong></td></tr><tr><td>
The command run. One of `sync`, `scrub`, `check`, `fix`, `status`, ...
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
argv:&lt;number&gt;:&lt;argument&gt;
</strong></td></tr><tr><td>
All the arguments of the executable command. The 0 one is the
executable run.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
memory:used:&lt;bytes&gt;
</strong></td></tr><tr><td>
The total memory currently used by the application in bytes (uint64).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
memory:block:&lt;bytes&gt;
</strong></td></tr><tr><td>
Size of the internal `snapraid_block` structure in bytes (uint64).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
memory:extent:&lt;bytes&gt;
</strong></td></tr><tr><td>
Size of the internal `snapraid_extent` structure in bytes (uint64).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
memory:file:&lt;bytes&gt;
</strong></td></tr><tr><td>
Size of the internal `snapraid_file` structure in bytes (uint64).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
memory:link:&lt;bytes&gt;
</strong></td></tr><tr><td>
Size of the internal `snapraid_link` structure in bytes (uint64).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
memory:dir:&lt;bytes&gt;
</strong></td></tr><tr><td>
Size of the internal `snapraid_dir` structure in bytes (uint64).
</td></tr>
</table>
<h2><a name="4">4</a> 
Scan Tags
</h2>
These tags report detected differences between the filesystem and the
content file. They are output for every discovered change, and
`scan:equal` is only output when the `--gui` option is used.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
scan:equal:&lt;disk_name&gt;:&lt;path&gt;
</strong></td></tr><tr><td>
A file, link, or directory is equal (unchanged) (GUI only).
No action is required for this item.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
Name of the data disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;path&gt;
</em></td><td width="90%">
Path to the file/link/dir relative to the disk mount
(escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
scan:add:&lt;disk_name&gt;:&lt;path&gt;
</strong></td></tr><tr><td>
A new file, link, or directory was found that is not in the
content file. This item will be added to the array in a `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
scan:remove:&lt;disk_name&gt;:&lt;path&gt;
</strong></td></tr><tr><td>
A file, link, or directory has been removed from the filesystem
since the last sync. This item will be removed from the
content file in a `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
scan:update:&lt;disk_name&gt;:&lt;path&gt;
</strong></td></tr><tr><td>
A file or link has been updated (size, timestamp, or link target changed).
This item will have its content data blocks re-hashed in a `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
scan:move:&lt;disk_name&gt;:&lt;old_path&gt;:&lt;new_path&gt;
</strong></td></tr><tr><td>
A file was moved on the same disk. This is an efficient operation
that only updates the path metadata without re-hashing blocks.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;old_path&gt;
</em></td><td width="90%">
The old path to the file (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;new_path&gt;
</em></td><td width="90%">
The new path to the file (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
scan:copy:&lt;disk_name&gt;:&lt;path&gt;:&lt;source_disk&gt;:&lt;source_path&gt;
</strong></td></tr><tr><td>
A new file was found to be a copy of a file from another disk.
This is detected by matching file size and timestamp, and is an
efficient operation that avoids re-hashing all blocks.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;source_disk&gt;
</em></td><td width="90%">
The original file's disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;source_path&gt;
</em></td><td width="90%">
The original file's location (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
scan:restore:&lt;disk_name&gt;:&lt;path&gt;
</strong></td></tr><tr><td>
A file's inode has changed but not its date-time and size,
which suggests the file may be restored from backup.
The file won't be re-hashed in `sync` as its precomputed hash
is assumed to be correct.
</td></tr>
</table>
<p>
These tags provide a final count of all detected changes.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:equal:&lt;count&gt;
</strong></td></tr><tr><td>
Total number of equal (unchanged) files/links/firs found (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:added:&lt;count&gt;
</strong></td></tr><tr><td>
Total number of new files/links/dirs found (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:removed:&lt;count&gt;
</strong></td></tr><tr><td>
Total number of removed files/links/dirs found (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:updated:&lt;count&gt;
</strong></td></tr><tr><td>
Total number of updated files/links found (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:moved:&lt;count&gt;
</strong></td></tr><tr><td>
Total number of moved files found (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:copied:&lt;count&gt;
</strong></td></tr><tr><td>
Total number of copied files found (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:restored:&lt;count&gt;
</strong></td></tr><tr><td>
Total number of restored files found (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:equal
</strong></td></tr><tr><td>
A zero-argument tag indicating that no differences were found.
The array is already synchronized.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:diff
</strong></td></tr><tr><td>
A zero-argument tag indicating that differences were found.
The array needs a `sync` operation.
</td></tr>
</table>
<h2><a name="5">5</a> 
General Progress and Execution Tags
</h2>
These tags are used to report the runtime processing of the commands.
Only produced when `--gui` option is used.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
run:begin:&lt;blockstart&gt;:&lt;blockend&gt;:&lt;countmax&gt;
</strong></td></tr><tr><td>
A tag indicating the start of the command execution.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;blockstart&gt;
</em></td><td width="90%">
Starting block index (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;blockend&gt;
</em></td><td width="90%">
Ending block index + 1 (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;countmax&gt;
</em></td><td width="90%">
Number of blocks to process. It may be less
than &lt;blockend&gt; - &lt;blockstart&gt; + 1 if some blocks
are going to be skipped (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
run:end
</strong></td></tr><tr><td>
A zero-argument tag indicating the end of the command execution.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
run:pos:&lt;blockpos&gt;:&lt;countpos&gt;:&lt;countsize&gt;:&lt;perc&gt;:&lt;eta&gt;:&lt;size_speed&gt;:&lt;cpu&gt;:&lt;elapsed&gt;
</strong></td></tr><tr><td>
Detailed progress information during command execution.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;blockpos&gt;
</em></td><td width="90%">
Current block index position (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;countpos&gt;
</em></td><td width="90%">
Current item count position (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;countsize&gt;
</em></td><td width="90%">
Current size processed (uint64).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;perc&gt;
</em></td><td width="90%">
Percentage complete (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;eta&gt;
</em></td><td width="90%">
Estimated time of arrival in minutes (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;size_speed&gt;
</em></td><td width="90%">
Data processing speed in MiB/s (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;cpu&gt;
</em></td><td width="90%">
CPU usage percentage (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;elapsed&gt;
</em></td><td width="90%">
Elapsed time in seconds (uint64).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
sigint:&lt;blockpos&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
A user interruption (e.g., Ctrl+C) was signaled. The process
is gracefully aborting.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;blockpos&gt;
</em></td><td width="90%">
Current block index position (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
Text message exactly as it's printed on screen.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
msg:&lt;level&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Messages printed to the screen.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;level&gt;
</em></td><td width="90%">
One of `fatal`, `error`, `expected`, `status`,
`progress` or `verbose`.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
fatal
</em></td><td width="90%">
A fatal error occurred. Program will abort after this
message.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
error
</em></td><td width="90%">
A generic error condition that doesn't prevent the
program to continue.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
expected
</em></td><td width="90%">
An expected error condition. At present it
happens only when using the `-m` option with files
expected missing.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
status
</em></td><td width="90%">
A status message, usually providing context or a summary.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
progress
</em></td><td width="90%">
A progress message, often part of an ongoing operation.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
verbose
</em></td><td width="90%">
A verbose informative message, only shown in verbose mode.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
Text message exactly as it's printed on screen.
</td></tr>
</table>
<h2><a name="6">6</a> 
Thermal Tags
</h2>
The following tags are produced by the thermal monitoring functions
when SnapRAID is processing, typically during operations that involve
disk access.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:ambient:device:&lt;hwmon_dir&gt;:&lt;name&gt;:&lt;temp_file&gt;:&lt;label&gt;:&lt;temp&gt;
</strong></td></tr><tr><td>
Logs a temperature reading found in the system using the Linux
/sys/class/hwmon interface. Only present in Linux.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;hwmon_dir&gt;
</em></td><td width="90%">
The hwmon directory name (e.g., hwmon0).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;name&gt;
</em></td><td width="90%">
The name of the hwmon device (e.g., k10temp).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;temp_file&gt;
</em></td><td width="90%">
The temperature file name (e.g., temp1_input).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;label&gt;
</em></td><td width="90%">
The label associated with the temperature sensor (e.g., Tdie).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;temp&gt;
</em></td><td width="90%">
The temperature reading in degrees Celsius.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:ambient:candidate:&lt;temp&gt;
</strong></td></tr><tr><td>
Reports a temperature reading that is a candidate for the
ambient temperature, used in the heating model calculation.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;temp&gt;
</em></td><td width="90%">
The candidate temperature in degrees Celsius.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:system:candidate:&lt;temp&gt;
</strong></td></tr><tr><td>
Logs a temperature reading from a connected disk that is being
considered as a candidate for determining the ambient system
temperature.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;temp&gt;
</em></td><td width="90%">
The current temperature read from the disk
(uint, degrees Celsius).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:system:final:&lt;temp&gt;
</strong></td></tr><tr><td>
Logs the final ambient system temperature calculated. This
value is the lowest valid temperature observed among all
candidates, representing the room temperature.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;temp&gt;
</em></td><td width="90%">
The calculated ambient temperature in degrees Celsius.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:current:&lt;disk_name&gt;:&lt;device&gt;:&lt;temp&gt;
</strong></td></tr><tr><td>
Logs the most recent temperature reading for a specific disk
device.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The configured name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;device&gt;
</em></td><td width="90%">
The unique device ID (uint64).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;temp&gt;
</em></td><td width="90%">
The current temperature read from the disk in degrees
Celsius.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:highest:&lt;temp&gt;
</strong></td></tr><tr><td>
Logs the highest temperature observed among all monitored disks
in the current measurement cycle. This is used for thermal
throttling.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;temp&gt;
</em></td><td width="90%">
The highest temperature observed in degrees Celsius.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:heat:&lt;disk_name&gt;:&lt;device&gt;:&lt;count&gt;:&lt;data_points&gt;
</strong></td></tr><tr><td>
Logs the entire history of temperature data points collected
so far for a specific disk, used for fitting the heating model.
Only monotone increasing temperatures are included in the history.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The configured name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;device&gt;
</em></td><td width="90%">
The unique device ID (uint64).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;count&gt;
</em></td><td width="90%">
The total number of collected data points (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;data_points&gt;
</em></td><td width="90%">
A comma-separated list of temperature/time pairs.
Each pair is formatted as &lt;temp&gt;/&lt;time_offset&gt;.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;temp&gt;
</em></td><td width="90%">
Temperature reading in degrees Celsius.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;time_offset&gt;
</em></td><td width="90%">
Time offset from the start of the thermal
monitoring (uint, seconds).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:params:&lt;disk_name&gt;:&lt;device&gt;:&lt;k_heat&gt;:&lt;t_ambient&gt;:&lt;t_steady&gt;:&lt;rmse&gt;:&lt;r_squared&gt;:&lt;max_error&gt;
</strong></td></tr><tr><td>
Logs the estimated parameters for the exponential heating model
(fit using least squares) and associated quality metrics for a
specific disk.
The model is: T(t) = T_steady - (T_steady - T_0) e^(-kt),
where T_0 is the initial temperature.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The configured name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;device&gt;
</em></td><td width="90%">
The unique device ID (uint64).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;k_heat&gt;
</em></td><td width="90%">
The heating rate constant, k (double).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;t_ambient&gt;
</em></td><td width="90%">
The ambient temperature, T_ambient (double).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;t_steady&gt;
</em></td><td width="90%">
The estimated steady-state temperature, T_steady (double),
which is the maximum expected temperature of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;rmse&gt;
</em></td><td width="90%">
Root Mean Square Error of the fit (double).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;r_squared&gt;
</em></td><td width="90%">
Coefficient of determination (R^2) of the fit (double).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;max_error&gt;
</em></td><td width="90%">
Maximum absolute error of the fit (double).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:spindown
</strong></td></tr><tr><td>
Indicates that the thermal alarm limit has been reached, and
the process is initiating a disk spindown to begin the
cooldown procedure, preventing overheating.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:cooldown:&lt;sleep_time&gt;
</strong></td></tr><tr><td>
Indicates the duration of the cooldown waiting period after
spindown.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;sleep_time&gt;
</em></td><td width="90%">
The total time the system will wait for
cooldown (uint, seconds).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
thermal:spinup
</strong></td></tr><tr><td>
Indicates that the cooldown period is complete, and the disks
are being spun back up to resume the operation.
</td></tr>
</table>
<h2><a name="7">7</a> 
Command Status Tags
</h2>
This section describes the tags output with the `status` command.
<h4>
Summary Tags
</h4>
These tags provide general information about the array configuration
and overall state.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:block_size:&lt;uint&gt;
</strong></td></tr><tr><td>
The size of a block in bytes. This is the unit of parity
protection.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:parity_block_count:&lt;uint&gt;
</strong></td></tr><tr><td>
The total number of blocks allocated for all parity levels
combined.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:parity_block_total:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Total blocks available for a specific parity level (e.g.,
`parity`, `2-parity`).
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:parity_block_free:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Free blocks available for a specific parity level.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:parity_block_free_min:&lt;uint&gt;
</strong></td></tr><tr><td>
The minimum number of free blocks across all parity levels.
This determines the maximum size of data that can be added.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:file_count:&lt;uint&gt;
</strong></td></tr><tr><td>
Total number of files in the array.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:file_block_count:&lt;uint64&gt;
</strong></td></tr><tr><td>
Total number of data blocks used by files.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:fragmented_file_count:&lt;uint&gt;
</strong></td></tr><tr><td>
Total number of fragmented files, meaning files whose blocks
are not contiguous.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:excess_fragment_count:&lt;uint&gt;
</strong></td></tr><tr><td>
Total number of excess fragments (one less than the total fragments).
This is a measure of data fragmentation overhead.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:zerosubsecond_file_count:&lt;uint&gt;
</strong></td></tr><tr><td>
Total number of files with a zero sub-second timestamp. This
can occur on certain filesystems and may affect change detection.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:file_size:&lt;uint64&gt;
</strong></td></tr><tr><td>
Total size of all files in bytes.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:parity_size:&lt;uint64&gt;
</strong></td></tr><tr><td>
Total size of allocated parity blocks in bytes.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:parity_size_max:&lt;uint64&gt;
</strong></td></tr><tr><td>
Maximum possible parity size (allocated + min free) in bytes.
This is the effective maximum protection size.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:hash:&lt;name&gt;
</strong></td></tr><tr><td>
The current hash algorithm in use (e.g., `sha256`).
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:prev_hash:&lt;name&gt;
</strong></td></tr><tr><td>
The previous hash algorithm used, if a rehash is in progress.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:best_hash:&lt;name&gt;
</strong></td></tr><tr><td>
The best hash algorithm for optimal performance based on
system capabilities.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:total_wasted:&lt;uint64&gt;
</strong></td></tr><tr><td>
Total wasted space (space on data disks exceeding parity
capacity) in bytes.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:total_used:&lt;uint64&gt;
</strong></td></tr><tr><td>
Total used space by data files in bytes.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:total_free:&lt;uint64&gt;
</strong></td></tr><tr><td>
Total free space (usable by data) in bytes, limited by parity
capacity.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:total_use_percent:&lt;uint&gt;
</strong></td></tr><tr><td>
Overall array use percentage.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:has_unsynced:&lt;uint&gt;
</strong></td></tr><tr><td>
Count of blocks that are unsynced (need a sync), meaning their
parity data is out of date.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:has_unscrubbed:&lt;uint&gt;
</strong></td></tr><tr><td>
Count of blocks that are unscrubbed (just synced), meaning they
have never been verified since the last sync.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:has_rehash:&lt;uint&gt;
</strong></td></tr><tr><td>
Count of blocks needing a rehash, usually due to a content file
update or hash algorithm change.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:has_bad:&lt;count&gt;:&lt;first&gt;:&lt;last&gt;
</strong></td></tr><tr><td>
Count of bad blocks, along with the first and last bad block index.
Bad blocks indicate data or parity corruption.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:scrub_oldest_days:&lt;uint&gt;
</strong></td></tr><tr><td>
Days ago the oldest block was last scrubbed.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:scrub_median_days:&lt;uint&gt;
</strong></td></tr><tr><td>
Days ago the median block was last scrubbed.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:scrub_newest_days:&lt;uint&gt;
</strong></td></tr><tr><td>
Days ago the newest block was last scrubbed.
</td></tr>
</table>
<h4>
Per-Disk Tags
</h4>
These tags provide statistics for individual data disks. &lt;name&gt;
is the disk name.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:disk_file_count:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Number of files on the disk.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_block_count:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Number of blocks used by files on the disk.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_fragmented_file_count:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Number of fragmented files on the disk.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_excess_fragment_count:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Number of excess fragments on the disk.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_zerosubsecond_file_count:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Number of files with zero sub-second timestamp on the disk.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_file_size:&lt;name&gt;:&lt;uint64&gt;
</strong></td></tr><tr><td>
Total size of files on the disk in bytes.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_block_allocated:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Highest block index used on the disk + 1.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_block_total:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Total blocks on the disk (physical size).
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_block_free:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Free blocks on the disk.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_block_max_by_space:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Total blocks by disk space (used + free blocks), representing
the physical limit of the disk.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_block_max_by_parity:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Total blocks limited by parity space (parity size + min parity
free blocks).
This is the logical limit imposed by the parity files.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_block_max:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Maximum usable blocks (minimum of `..._by_space` and `..._by_parity`).
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_space_wasted:&lt;name&gt;:&lt;int64&gt;
</strong></td></tr><tr><td>
Wasted space on the disk in bytes (positive if disk is larger
than usable parity space).
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_used:&lt;name&gt;:&lt;uint64&gt;
</strong></td></tr><tr><td>
Used space on the disk in bytes.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_free:&lt;name&gt;:&lt;uint64&gt;
</strong></td></tr><tr><td>
Free usable space on the disk in bytes, limited by `disk_block_max`.
</td></tr>
<tr valign="top" align="left"><td><strong>
summary:disk_use_percent:&lt;name&gt;:&lt;uint&gt;
</strong></td></tr><tr><td>
Disk use percentage relative to `disk_block_max`.
</td></tr>
</table>
<h4>
File Timestamp Tags
</h4>
These tags list files with zero sub-second timestamps.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
zerosubsecond:&lt;disk_name&gt;:&lt;file_path&gt;
</strong></td></tr><tr><td>
Lists files that have a zero sub-second timestamp.
Up to 50 are logged per disk.
</td></tr>
</table>
<h4>
Block Information Tags
</h4>
These tags are generated when the GUI option is enabled (`state-&gt;opt.gui`).
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
block_count:&lt;uint&gt;
</strong></td></tr><tr><td>
The total number of blocks in the array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
block:&lt;index&gt;:&lt;time&gt;:&lt;used&gt;:&lt;unsynced&gt;:&lt;bad&gt;:&lt;rehash&gt;
</strong></td></tr><tr><td>
Status of a specific block.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;index&gt;
</em></td><td width="90%">
Block index.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;time&gt;
</em></td><td width="90%">
Last scrub time (Unix timestamp). A value of 0 means
the block has never been scrubbed.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;used&gt;
</em></td><td width="90%">
`used` if the block contains data, otherwise empty.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;unsynced&gt;
</em></td><td width="90%">
`unsynced` if the block needs a sync, otherwise empty.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;bad&gt;
</em></td><td width="90%">
`bad` if the block has errors, otherwise empty.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;rehash&gt;
</em></td><td width="90%">
`rehash` if the block needs a rehash, otherwise empty.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
block_noinfo:&lt;index&gt;:&lt;used&gt;:&lt;unsynced&gt;
</strong></td></tr><tr><td>
Status of an unused block (no info recorded) in the content file.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;index&gt;
</em></td><td width="90%">
Block index.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;used&gt;
</em></td><td width="90%">
`used` if the block contains data, otherwise empty.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;unsynced&gt;
</em></td><td width="90%">
`unsynced` if the block needs a sync, otherwise empty.
</td></tr>
</table>
<h4>
Scrub History Tags
</h4>
These tags provide details on the scrub/sync time distribution.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
info_count:&lt;uint&gt;
</strong></td></tr><tr><td>
Total number of info records about past scrub and sync
operations stored in the content file.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
info_time:&lt;time&gt;:&lt;count&gt;:&lt;status&gt;
</strong></td></tr><tr><td>
All the info records.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;time&gt;
</em></td><td width="90%">
Unix timestamp of the scrub/sync.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;count&gt;
</em></td><td width="90%">
Number of blocks processed at this timestamp.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;status&gt;
</em></td><td width="90%">
"scrubbed" (for blocks verified to be correct) or
"new" (for synced blocks that haven't been scrubbed yet).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
scrub_graph_range:&lt;max_columns&gt;:&lt;max_height&gt;
</strong></td></tr><tr><td>
Dimensions of the scrub history graph obtained from the
`info_time` records. This provides the boundary for the
precomputed graph data available in the `scrub_graph_bar` tags.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;max_columns&gt;
</em></td><td width="90%">
The number of columns in the graph (constant
GRAPH_COLUMN).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;max_height&gt;
</em></td><td width="90%">
The maximum height (peak count) of blocks found
in any column (the highest sum of scrubbed and new blocks).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
scrub_graph_bar:&lt;index&gt;:&lt;days_ago&gt;:&lt;scrubbed&gt;:&lt;new&gt;
</strong></td></tr><tr><td>
Data for a column of the scrub history graph. Each column
represents a time period.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;index&gt;
</em></td><td width="90%">
Column index. From 0 to max_columns - 1.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;days_ago&gt;
</em></td><td width="90%">
Days ago for this column's time range.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;scrubbed&gt;
</em></td><td width="90%">
Count of scrubbed blocks in that day range.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;new&gt;
</em></td><td width="90%">
Count of newly synced (unscrubbed) blocks in that day range.
</td></tr>
</table>
<h2><a name="8">8</a> 
Command Sync/Scrub Tags
</h2>
Tags specific for the `sync` and `scrub` commands.
Also the error tags are possible.
<h4>
Summary Tags
</h4>
These tags provide summary statistics at the end of the command.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
hash_summary:error_file:&lt;count&gt;
</strong></td></tr><tr><td>
Logs the total count of file-related errors that caused a
block to be skipped during the hashing phase. These are often
due to file changes (missing, size/time change) during the
sync operation. This happens only in `sync`.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;count&gt;
</em></td><td width="90%">
Total number of file errors (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:error_file:&lt;count&gt;
</strong></td></tr><tr><td>
Logs the total count of file-related errors encountered during
the process (e.g., missing files, file attribute changes).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;count&gt;
</em></td><td width="90%">
The total number of file errors encountered (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:error_io:&lt;count&gt;
</strong></td></tr><tr><td>
Logs the total count of input/output errors encountered on
data or parity disks.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;count&gt;
</em></td><td width="90%">
The total number of I/O errors encountered (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:error_data:&lt;count&gt;
</strong></td></tr><tr><td>
Logs the total count of "silent data errors" (data blocks
not matching their expected hash) encountered during the sync
process.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;count&gt;
</em></td><td width="90%">
The total number of silent data errors encountered (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:&lt;status&gt;
</strong></td></tr><tr><td>
Logs the overall exit status of the command. The `status` is
one of the following:
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
ok
</em></td><td width="90%">
No errors were found.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
error
</em></td><td width="90%">
If any errors were found (file, I/O, or data errors).
</td></tr>
</table>
<h2><a name="9">9</a> 
Command Check/Fix Tags
</h2>
Tags specific for the `check` and `fix` commands.
Also the error tags are possible.
<h4>
Fixed/Recovered Tags
</h4>
These tags log successful repairs during fix operations.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
fixed:&lt;block_pos&gt;:&lt;disk_name&gt;:&lt;file_path&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Indicates that a file was successfully fixed using parity data.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;block_pos&gt;
</em></td><td width="90%">
The block position being processed (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path&gt;
</em></td><td width="90%">
The file path relative to disk root (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the fix
(e.g., `Fixed size`, `Fixed data error at position...`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
parity_fixed:&lt;block_pos&gt;:&lt;parity&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Indicates that corrupted parity data was successfully
recomputed and written.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;block_pos&gt;
</em></td><td width="90%">
The block position being processed (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;parity&gt;
</em></td><td width="90%">
The name of the parity level (e.g., "parity", "2-parity").
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the fix
(e.g., `Fixed data error`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
empty_fixed:&lt;disk_name&gt;:&lt;file_path&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Logs successful recreation of a missing or corrupted empty file.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path&gt;
</em></td><td width="90%">
The file path relative to disk root (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the fix
(e.g., `Fixed empty file`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
hardlink_fixed:&lt;disk_name&gt;:&lt;link_path&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Logs successful recreation of a hard link during fix operation.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;link_path&gt;
</em></td><td width="90%">
The hard link path relative to disk root (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the fix
(e.g., `Fixed hardlink error`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
symlink_fixed:&lt;disk_name&gt;:&lt;link_path&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Logs successful recreation of a symbolic link during fix operation.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;link_path&gt;
</em></td><td width="90%">
The symlink path relative to disk root (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the fix
(e.g., `Fixed symlink error`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
dir_fixed:&lt;disk_name&gt;:&lt;dir_path&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Logs successful recreation of a missing directory during fix
operation.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;dir_path&gt;
</em></td><td width="90%">
The directory path relative to disk root (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the fix
(e.g., `Fixed dir error`).
</td></tr>
</table>
<h4>
Unrecoverable Error Tags
</h4>
These tags log errors that could not be recovered.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
unrecoverable:&lt;block_pos&gt;:&lt;disk_name&gt;:&lt;file_path&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Indicates that a block error could not be fixed due to
insufficient parity or other recovery limitations.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;block_pos&gt;
</em></td><td width="90%">
The block position being processed (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path&gt;
</em></td><td width="90%">
The file path relative to disk root (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the problem
(e.g., `Unrecoverable error at position &lt;file_pos&gt;`,
`Unrecoverable unsynced error at position &lt;file_pos&gt;`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
collision:&lt;disk_name&gt;:&lt;file_path&gt;:&lt;collision_path&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Logs that the modification time was not set on a recovered file to
avoid inode collision with another file.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path&gt;
</em></td><td width="90%">
The file path relative to disk root (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;collision_path&gt;
</em></td><td width="90%">
The path of the colliding file (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the problem
(e.g., `Not setting modification time to avoid inode collision`).
</td></tr>
</table>
<h4>
File Status Tags
</h4>
These tags log the final status of files after processing.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
status:unrecoverable:&lt;disk_name&gt;:&lt;file_path&gt;
</strong></td></tr><tr><td>
Indicates that a file has unrecoverable errors and was renamed to
`.unrecoverable` (in fix mode) or cannot be recovered (in check mode).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path&gt;
</em></td><td width="90%">
The file path relative to disk root (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
status:recovered:&lt;disk_name&gt;:&lt;file_path&gt;
</strong></td></tr><tr><td>
Logs that a file was successfully recovered during fix operation.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path&gt;
</em></td><td width="90%">
The file path relative to disk root (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
status:damaged:&lt;disk_name&gt;:&lt;file_path&gt;
</strong></td></tr><tr><td>
Indicates that a file is damaged (in audit-only mode, e.g., using `check`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path&gt;
</em></td><td width="90%">
The file path relative to disk root (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
status:recoverable:&lt;disk_name&gt;:&lt;file_path&gt;
</strong></td></tr><tr><td>
Logs that a file has errors but could be recovered in fix mode.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path&gt;
</em></td><td width="90%">
The file path relative to disk root (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
status:correct:&lt;disk_name&gt;:&lt;file_path&gt;
</strong></td></tr><tr><td>
Indicates that a file passed all checks successfully (verbose mode only).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path&gt;
</em></td><td width="90%">
The file path relative to disk root (escaped).
</td></tr>
</table>
<h4>
Summary Tags
</h4>
These tags provide summary statistics at the end of the command.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:error:&lt;error_count&gt;
</strong></td></tr><tr><td>
Logs the total number of errors encountered.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;error_count&gt;
</em></td><td width="90%">
Total number of errors (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:error_recovered:&lt;recovered_count&gt;
</strong></td></tr><tr><td>
Logs the total number of errors successfully recovered (fix mode only).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;recovered_count&gt;
</em></td><td width="90%">
Number of recovered errors (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:error_unrecoverable:&lt;unrecoverable_count&gt;
</strong></td></tr><tr><td>
Logs the total number of unrecoverable errors (not in audit-only mode).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;unrecoverable_count&gt;
</em></td><td width="90%">
Number of unrecoverable errors (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:&lt;status&gt;
</strong></td></tr><tr><td>
Logs the overall exit status of the command. The `status` is one of
the following:
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
`ok`
</em></td><td width="90%">
Indicates that the operation completed with no errors.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
`recovered`
</em></td><td width="90%">
Indicates that the operation completed with all
errors successfully recovered (fix mode only).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
`recoverable`
</em></td><td width="90%">
Indicates that errors were found but are all
recoverable (check mode only).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
`unrecoverable`
</em></td><td width="90%">
Indicates that unrecoverable errors were
found.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
`error`
</em></td><td width="90%">
Indicates that errors were found (audit-only mode).
</td></tr>
</table>
<h2><a name="10">10</a> 
Command List Tags
</h2>
This section describes the tags output with the `list` command.
<h4>
List Tags
</h4>
These tags log details about individual files and links processed during
the listing operation.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
file:&lt;disk_name&gt;:&lt;subpath&gt;:&lt;size&gt;:&lt;mtime_sec&gt;:&lt;mtime_nsec&gt;:&lt;inode&gt;
</strong></td></tr><tr><td>
Logs details for a regular file found on a disk.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The configured name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;subpath&gt;
</em></td><td width="90%">
The path of the file relative to the disk's root
(escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;size&gt;
</em></td><td width="90%">
The size of the file in bytes (uint64).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;mtime_sec&gt;
</em></td><td width="90%">
The file's modification time in seconds since the
Epoch (int64).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;mtime_nsec&gt;
</em></td><td width="90%">
The file's modification time nanosecond component
(uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;inode&gt;
</em></td><td width="90%">
The file's inode number (int64).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
link_&lt;type&gt;:&lt;disk_name&gt;:&lt;subpath&gt;:&lt;linkto&gt;
</strong></td></tr><tr><td>
Logs details for a link found on a disk. The `&lt;type&gt;` component
varies based on the kind of link.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;type&gt;
</em></td><td width="90%">
The type of link, one of: `hardlink`, `symlink`,
`symdir` (symlink to a directory), `junction`
(Windows-specific reparse point).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The configured name of the disk (string).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;subpath&gt;
</em></td><td width="90%">
The path of the link relative to the disk's root
(escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;linkto&gt;
</em></td><td width="90%">
The target path of the link (escaped).
</td></tr>
</table>
<h4>
Summary Tags
</h4>
These tags log final statistics about the entire listing operation.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:file_count:&lt;count&gt;
</strong></td></tr><tr><td>
Logs the total number of regular files processed.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;count&gt;
</em></td><td width="90%">
The total number of files (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:file_size:&lt;size&gt;
</strong></td></tr><tr><td>
Logs the total size of all regular files processed.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;size&gt;
</em></td><td width="90%">
The cumulative size of all files (uint64, bytes).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:link_count:&lt;count&gt;
</strong></td></tr><tr><td>
Logs the total number of links processed (hardlinks, symlinks,
symdirs, junctions).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;count&gt;
</em></td><td width="90%">
The total number of links (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:ok
</strong></td></tr><tr><td>
Indicates a successful completion of the listing operation.
Note that if a fatal error happens, the program will abort,
and you won't get this tag.
</td></tr>
</table>
<h2><a name="11">11</a> 
Command Dup Tags
</h2>
This section describes the tags output with the `dup` command.
<h4>
Duplicate Tags
</h4>
These tags log information about detected duplicate files and provide
a summary of the duplicate finding process. The content hash of the
whole file is used to determine duplicates.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
dup:&lt;diskname1&gt;:&lt;file_path1&gt;:&lt;diskname2&gt;:&lt;file_path2&gt;:&lt;size&gt;: dup
</strong></td></tr><tr><td>
Logs the information about a pair of duplicate files found.
The first file listed is the one just processed, and the second
file is the previously processed file that has the same content hash.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;diskname1&gt;
</em></td><td width="90%">
The configured name of the disk containing the
newly processed duplicate file.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path1&gt;
</em></td><td width="90%">
The path of the newly processed duplicate file
relative to its disk's mount point (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;diskname2&gt;
</em></td><td width="90%">
The configured name of the disk containing the
previously processed file that is the duplicate
of `&lt;file_path1&gt;`.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path2&gt;
</em></td><td width="90%">
The path of the previously processed duplicate file
relative to its disk's mount point (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;size&gt;
</em></td><td width="90%">
The size of the duplicate file in bytes (uint64). This
size corresponds to the file `&lt;file_path2&gt;`.
</td></tr>
</table>
<h4>
Summary Tags
</h4>
These tags provide a final summary of the duplicate finding process.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:dup_count:&lt;count&gt;
</strong></td></tr><tr><td>
Logs the total number of duplicate files found. A file is counted
as a duplicate if its hash matches a hash already seen.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;count&gt;
</em></td><td width="90%">
The total count of duplicate files (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:dup_size:&lt;size&gt;
</strong></td></tr><tr><td>
Logs the total size of all duplicate files found. This size is
the sum of the sizes of all files considered duplicates.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;size&gt;
</em></td><td width="90%">
The total size of duplicate files in gigabytes (uint64).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:unique
</strong></td></tr><tr><td>
Logs the final exit status indicating that no duplicate files were
found. This tag is logged if `&lt;count&gt;` is zero.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:dup
</strong></td></tr><tr><td>
Logs the final exit status indicating that at least one duplicate
file was found. This tag is logged if `&lt;count&gt;` is greater than
zero.
</td></tr>
</table>
<h2><a name="12">12</a> 
Command Pool Tags
</h2>
This section describes the tags output with the `pool` command.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:link_count:&lt;count&gt;
</strong></td></tr><tr><td>
Logs the total number of links created (symlinks, junctions).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;count&gt;
</em></td><td width="90%">
The total number of links (uint).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:ok
</strong></td></tr><tr><td>
Indicates a successful completion of the pool operation.
Note that if a fatal error happens, the program will abort,
and you won't get this tag.
</td></tr>
</table>
<h2><a name="13">13</a> 
Command Rehash Tags
</h2>
This section describes the tags output with the `rehash` command.
<h4>
Summary Tags
</h4>
These tags provide a final summary of the rehash scheduling process.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:scheduled
</strong></td></tr><tr><td>
Logs the final exit status indicating that a rehash operation has
been successfully scheduled. The rehash will be performed
incrementally in future `sync` or `scrub` commands.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:already_in_progress
</strong></td></tr><tr><td>
Logs the final exit status indicating that a rehash is already
in progress and cannot be scheduled again. This causes the
program to exit with a fatal error.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:exit:not_required
</strong></td></tr><tr><td>
Logs the final exit status indicating that the current hash
algorithm is already the `best hash` for the platform, and thus
a rehash is not required. This causes the program to exit with
a fatal error.
</td></tr>
</table>
<h2><a name="14">14</a> 
Command Smart Tags
</h2>
This section describes the tags output with the `smart` command.
<p>
Note that a `&lt;disk_name&gt;` may be associated with more `&lt;device_file&gt;`,
in case the logical disk uses more physical disks. In such a case,
you'll see multiple tags for the same `&lt;disk_name&gt;` but with different
`&lt;device_file&gt;`.
<h4>
SMART Attributes
</h4>
Tags logging specific disk identification and raw SMART attribute
values.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
smart:&lt;device_file&gt;:&lt;disk_name&gt;
</strong></td></tr><tr><td>
Logs the start of the SMART report for a device.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;device_file&gt;
</em></td><td width="90%">
The file path of the device (e.g., /dev/sdb).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The configured name of the disk.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
attr:&lt;device_file&gt;:&lt;disk_name&gt;:serial:&lt;serial_number&gt;
</strong></td></tr><tr><td>
Logs the disk's serial number.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;serial_number&gt;
</em></td><td width="90%">
The disk's serial number (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
attr:&lt;device_file&gt;:&lt;disk_name&gt;:vendor:&lt;vendor&gt;
</strong></td></tr><tr><td>
Logs the disk's vendor string.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;vendor&gt;
</em></td><td width="90%">
The disk's vendor identifier (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
attr:&lt;device_file&gt;:&lt;disk_name&gt;:model:&lt;model&gt;
</strong></td></tr><tr><td>
Logs the disk's model string.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;model&gt;
</em></td><td width="90%">
The disk's model identifier (escaped).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
attr:&lt;device_file&gt;:&lt;disk_name&gt;:afr:&lt;afr_value&gt;:&lt;afr_prob&gt;
</strong></td></tr><tr><td>
Logs the estimated Annual Failure Rate (AFR) and the
probability of one failure in the next year based on SMART
attributes. The AFR is calculated using the maximum rate
reported by specific SMART attributes (5, 187, 188, 197, 198).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;afr_value&gt;
</em></td><td width="90%">
The computed Annual Failure Rate (double).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;afr_prob&gt;
</em></td><td width="90%">
The probability of one or more failures in the
next year (double).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
attr:&lt;device_file&gt;:&lt;disk_name&gt;:size:&lt;size_bytes&gt;
</strong></td></tr><tr><td>
Logs the size of the disk.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;size_bytes&gt;
</em></td><td width="90%">
The disk size in bytes (uint64).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
attr:&lt;device_file&gt;:&lt;disk_name&gt;:error:&lt;error_count&gt;
</strong></td></tr><tr><td>
Logs the raw value of the total error count (e.g., from SMART
attribute 199, if used for the report).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;error_count&gt;
</em></td><td width="90%">
The total error count (uint64).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
attr:&lt;device_file&gt;:&lt;disk_name&gt;:rotationrate:&lt;rate&gt;
</strong></td></tr><tr><td>
Logs the disk's rotation rate. A value of 0 indicates an SSD.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;rate&gt;
</em></td><td width="90%">
The rotation rate (uint64, RPM).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
attr:&lt;device_file&gt;:&lt;disk_name&gt;:flags:&lt;flags_decimal&gt;:&lt;flags_hex&gt;
</strong></td></tr><tr><td>
Logs the SMART status flags from the utility (e.g., smartctl).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;flags_decimal&gt;
</em></td><td width="90%">
The raw flags value (uint64, decimal).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;flags_hex&gt;
</em></td><td width="90%">
The raw flags value (uint64, hexadecimal).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
attr:&lt;device_file&gt;:&lt;disk_name&gt;:&lt;id&gt;:&lt;value_decimal&gt;:&lt;value_hex&gt;
</strong></td></tr><tr><td>
Logs the raw value of any assigned SMART attribute.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;id&gt;
</em></td><td width="90%">
The SMART attribute ID (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;value_decimal&gt;
</em></td><td width="90%">
The raw attribute value (uint64, decimal).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;value_hex&gt;
</em></td><td width="90%">
The raw attribute value (uint64, hexadecimal).
</td></tr>
</table>
<h4>
Summary
</h4>
Tags logging the overall failure probabilities for the array.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
summary:array_failure:&lt;array_afr&gt;:&lt;array_prob&gt;
</strong></td></tr><tr><td>
Logs the total estimated failure rate for the entire array
(sum of individual disk AFRs) and the probability of at least
one disk failure in the next year.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;array_afr&gt;
</em></td><td width="90%">
The sum of AFRs of all disks in the array (double).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;array_prob&gt;
</em></td><td width="90%">
The probability of at least one disk failure in
</td></tr>
</table>
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
the next year (double).
</td></tr></table>
<h2><a name="15">15</a> 
Command Probe Tags
</h2>
This section describes the tags output with the `probe` command.
<p>
Note that a `&lt;disk_name&gt;` may be associated with more `&lt;device_file&gt;`,
in case the logical disk uses more physical disks. In such a case,
you'll see multiple tags for the same `&lt;disk_name&gt;` but with different
`&lt;device_file&gt;`.
<h4>
Device Power State
</h4>
Tags used to report the power state of each device.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
probe:&lt;device_file&gt;:&lt;disk_name&gt;:&lt;power_state&gt;
</strong></td></tr><tr><td>
Logs the detected power state of a device.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;device_file&gt;
</em></td><td width="90%">
The file path of the device (e.g., /dev/sdb).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The configured name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;power_state&gt;
</em></td><td width="90%">
The numerical power state: 0: Unknown,
1: StandBy, 2: Active.
</td></tr>
</table>
<h2><a name="16">16</a> 
Error Tags
</h2>
These tags report specific errors that occur on data disks during the
commands that access files and parities.
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
error:&lt;block&gt;:&lt;disk_name&gt;:&lt;file&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Logs file access errors (open, read, file changed) during the
data disk read operation for parity calculation or verification.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;block&gt;
</em></td><td width="90%">
The zero-based index of the block where the error occurred (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the data disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file&gt;
</em></td><td width="90%">
The path (relative to the disk mount point) of the
file containing the block (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the
error (e.g., `Open/Read/Write EIO error`, `Open/Read/Write error`,
`Data error at position &lt;pos&gt;, diff bits &lt;diff&gt;/&lt;bits&gt;`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
parity_error:&lt;block&gt;:&lt;level&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Logs errors during parity disk read or write operations.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;block&gt;
</em></td><td width="90%">
The zero-based index of the block where the error occurred (uint).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;level&gt;
</em></td><td width="90%">
The configuration name of the parity level (e.g.,
`parity`, `2-parity`).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the
error (e.g., `Read/Write EIO error`, `Read/Write error`,
`Data error, diff bits &lt;diff&gt;/&lt;bits&gt;`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
hardlink_error:&lt;disk_name&gt;:&lt;link_path&gt;:&lt;target_path&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Indicates an error when attempting to access a hard link.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;link_path&gt;
</em></td><td width="90%">
The hard link path relative to disk root (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;target_path&gt;
</em></td><td width="90%">
The target path of the hard link (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the
error (e.g., `Hardlink stat error`,
`Hardlink error for not regular file`, `Hardlink to stat error`,
`Hardlink-to error for not regular file`,
`Hardlink mismatch for different inode`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
symlink_error:&lt;disk_name&gt;:&lt;link_path&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Indicates an error when attempting to access a symbolic link.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;link_path&gt;
</em></td><td width="90%">
The symlink path relative to disk root (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the
error (e.g., `Symlink read error`,
`Symlink data error '&lt;actual&gt;' instead of '&lt;expected&gt;'`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
dir_error:&lt;disk_name&gt;:&lt;dir_path&gt;:&lt;msg&gt;
</strong></td></tr><tr><td>
Indicates an error when attempting to access a directory.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;dir_path&gt;
</em></td><td width="90%">
The directory path relative to disk root (escaped).
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;msg&gt;
</em></td><td width="90%">
A descriptive message indicating the nature of the
error (e.g., `Dir stat error`, `Dir error for not directory`).
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
outofparity:&lt;disk_name&gt;:&lt;file_path&gt;
</strong></td></tr><tr><td>
Logs that a file's blocks extend beyond the available parity
space, indicating that the parity files are too small to
protect all data. This occurs when data requires more parity
than is available on the parity disk(s) and is a critical
warning.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;disk_name&gt;
</em></td><td width="90%">
The name of the disk containing the file.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
&lt;file_path&gt;
</em></td><td width="90%">
The file path relative to the disk root (escaped).
</td></tr>
</table>



</div>

<div id="footer">

<div class="column">
<span class="bold">Donate with</span>
<br>
<!--
<a href="http://sourceforge.net/p/snapraid/donate/"><img src="paypal.png" width="160" height="60" alt="PayPal"></a>
-->
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=amadvance%40gmail%2ecom&lc=US&item_name=SnapRAID&no_note=0&currency_code=USD&bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHostedGuest"><img src="paypal.png" width="160" height="60" alt="PayPal"></a>
<!--
<a href="https://coinkite.com/u/amadvance/"><img src="bitcoin.png" width="160" height="60" alt="BitCoin"></a>
-->
</div>

<div class="column">
<span class="bold">Find other resources at</span>
<br>
<a href="https://github.com/amadvance/snapraid/"><img src="github.png" width="160" height="60" alt="GitHub"></a>
<a href="http://sourceforge.net/projects/snapraid/"><img src="sourceforge.png" width="115" height="60" alt="SourceForge"></a>
</div>

</div>
</body>
</html>


