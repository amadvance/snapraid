<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="A backup program for disk arrays. It stores parity information of your data and it recovers from up to six disk failures">
<meta name="keywords" content="snapraid snapshot raid backup disk array redundancy parity">
<meta name="author" content="Andrea Mazzoleni">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="style.css">
<title>SnapRAID</title>

<!-- Google Analytics 4 -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W1Z5FKHYQ4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-W1Z5FKHYQ4');
</script>

<!-- Google Universal Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<div id="header">
<img src="index.jpg" width="1200" height="150" alt="Title">
</div>
<div id="menu">
<a href="/">About</a>
<a href="download">Download</a>
<a href="design">Design</a>
<a href="compare">Compare</a>
<a href="faq">FAQ</a>
<a href="manual">Manual</a>
<a href="support">Support</a>
<a href="community">Community</a>
<a href="authors">Authors</a>
</div>
<div id="main">



<p>
Manual for <span class="bold">SnapRAID</span>.
</p>

<h2><a name="1">1</a> 
Synopsis
</h2>
<pre>
snapraid [-c, --conf CONFIG]
&nbsp;&nbsp;&nbsp;&nbsp;[-f, --filter PATTERN] [-d, --filter-disk NAME]
&nbsp;&nbsp;&nbsp;&nbsp;[-m, --filter-missing] [-e, --filter-error]
&nbsp;&nbsp;&nbsp;&nbsp;[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR]
&nbsp;&nbsp;&nbsp;&nbsp;[-p, --plan PERC|bad|new|full]
&nbsp;&nbsp;&nbsp;&nbsp;[-o, --older-than DAYS] [-l, --log FILE]
&nbsp;&nbsp;&nbsp;&nbsp;[-Z, --force-zero] [-E, --force-empty]
&nbsp;&nbsp;&nbsp;&nbsp;[-U, --force-uuid] [-D, --force-device]
&nbsp;&nbsp;&nbsp;&nbsp;[-N, --force-nocopy] [-F, --force-full]
&nbsp;&nbsp;&nbsp;&nbsp;[-R, --force-realloc]
&nbsp;&nbsp;&nbsp;&nbsp;[-S, --start BLKSTART] [-B, --count BLKCOUNT]
&nbsp;&nbsp;&nbsp;&nbsp;[-L, --error-limit NUMBER]
&nbsp;&nbsp;&nbsp;&nbsp;[-v, --verbose] [-q, --quiet]
&nbsp;&nbsp;&nbsp;&nbsp;status|smart|up|down|diff|sync|scrub|fix|check|list|dup
&nbsp;&nbsp;&nbsp;&nbsp;|pool|devices|touch|rehash
</pre>
<p>
<pre>
snapraid [-V, --version] [-H, --help] [-C, --gen-conf CONTENT]
</pre>
<h2><a name="2">2</a> 
Description
</h2>
SnapRAID is a backup program designed for disk arrays, storing
parity information for data recovery in the event of up to six
disk failures.
<p>
Primarily intended for home media centers with large,
infrequently changing files, SnapRAID offers several features:
<ul>
<li>
You can utilize disks already filled with files without the
need to reformat them, accessing them as usual.
</li>
<li>
All your data is hashed to ensure data integrity and prevent
silent corruption.
</li>
<li>
When the number of failed disks exceeds the parity count,
data loss is confined to the affected disks; data on
other disks remains accessible.
</li>
<li>
If you accidentally delete files on a disk, recovery is
possible.
</li>
<li>
Disks can have different sizes.
</li>
<li>
You can add disks at any time.
</li>
<li>
SnapRAID doesn't lock in your data; you can stop using it
anytime without reformatting or moving data.
</li>
<li>
To access a file, only a single disk needs to spin, saving
power and reducing noise.
</li>
</ul>
<p>
For more information, please visit the official SnapRAID site:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
<a href="http://www.snapraid.it/">http://www.snapraid.it/</a>
</pre>
</td></tr></table>
<h2><a name="3">3</a> 
Limitations
</h2>
SnapRAID is in between a RAID and a Backup program trying to get the best
benefits of them. Although it also has some limitations that you should
consider before using it.
<p>
The main one is that if a disk fails, and you haven't recently synced,
you may be unable to do a complete recover.
More specifically, you may be unable to recover up to the size of
the changed or deleted files from the last sync operation.
This happens even if the files changed or deleted are not in the
failed disk. This is why SnapRAID is better suited for
data that rarely change.
<p>
On the other hand, newly added files don't prevent recovering already
existing files. You may only lose the recently added files, if they are on
the failed disk.
<p>
Other SnapRAID limitations are:
<ul>
<li>
With SnapRAID, you still have separate file-systems for each disk.
With RAID you get a single large file-system.
</li>
<li>
SnapRAID doesn't stripe data.
With RAID you get a speed boost with striping.
</li>
<li>
SnapRAID doesn't support real-time recovery.
With RAID you do not have to stop working when a disk fails.
</li>
<li>
SnapRAID is able to recover damages only from a limited number of disks.
With a Backup you can recover from a complete
failure of the whole disk array.
</li>
<li>
Only file, time-stamps, symlinks and hardlinks are saved.
Permissions, ownership and extended attributes are not saved.
</li>
</ul>
<h2><a name="4">4</a> 
Getting Started
</h2>
To use SnapRAID you need to first select one disk of your disk array
to dedicate at the "parity" information. With one disk for parity you
will be able to recover from a single disk failure, like RAID5.
<p>
If you want to be able to recover from more disk failures, like RAID6,
you must reserve additional disks for parity. Any additional parity
disk allow to recover from one more disk failure.
<p>
As parity disks, you have to pick the biggest disks in the array,
as the parity information may grow in size as the biggest data
disk in the array.
<p>
These disks will be dedicated to store the "parity" files.
You should not store your data in them.
<p>
Then you have to define the "data" disks that you want to protect
with SnapRAID. The protection is more effective if these disks
contain data that rarely change. For this reason it's better to
DO NOT include the Windows C:\ disk, or the Unix /home, /var and /tmp
disks.
<p>
The list of files is saved in the "content" files, usually
stored in the data, parity or boot disks.
These files contain the details of your backup, with all the
check-sums to verify its integrity.
The "content" file is stored in multiple copies, and each one must
be in a different disk, to ensure that in even in case of multiple
disk failures at least one copy is available.
<p>
For example, suppose that you are interested only at one parity level
of protection, and that your disks are present in:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
/mnt/diskp &lt;- selected disk for parity
/mnt/disk1 &lt;- first disk to protect
/mnt/disk2 &lt;- second disk to protect
/mnt/disk3 &lt;- third disk to protect
</pre>
</td></tr></table>
<p>
you have to create the configuration file /etc/snapraid.conf with
the following options:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity /mnt/diskp/snapraid.parity
content /var/snapraid/snapraid.content
content /mnt/disk1/snapraid.content
content /mnt/disk2/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
</pre>
</td></tr></table>
<p>
If you are in Windows, you should use the Windows path format, with drive
letters and backslashes instead of slashes.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity E:\snapraid.parity
content C:\snapraid\snapraid.content
content F:\array\snapraid.content
content G:\array\snapraid.content
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
</pre>
</td></tr></table>
<p>
If you have many disks, and you run out of drive letters, you can mount
disks directly in sub folders. See:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.google.com/search?q=Windows+mount+point
</pre>
</td></tr></table>
<p>
At this point you are ready to start the "sync" command to build the
parity information.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid sync
</pre>
</td></tr></table>
<p>
This process may take some hours the first time, depending on the size
of the data already present in the disks. If the disks are empty
the process is immediate.
<p>
You can stop it at any time pressing Ctrl+C, and at the next run it
will start where interrupted.
<p>
When this command completes, your data is SAFE.
<p>
Now you can start using your array as you like, and periodically
update the parity information running the "sync" command.
<h3><a name="4.1">4.1</a> 
Scrubbing
</h3>
To periodically check the data and parity for errors, you can
run the "scrub" command.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid scrub
</pre>
</td></tr></table>
<p>
This command verifies the data in your array comparing it with
the hash computed in the "sync" command.
<p>
Every run of the command checks about the 8% of the array, but not data
already scrubbed in the previous 10 days.
You can use the -p, --plan option to specify a different amount,
and the -o, --older-than option to specify a different age in days.
For example, to check 5% of the array older than 20 days use:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -p 5 -o 20 scrub
</pre>
</td></tr></table>
<p>
If during the process, silent or input/output errors are found,
the corresponding blocks are marked as bad in the "content" file,
and listed in the "status" command.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid status
</pre>
</td></tr></table>
<p>
To fix them, you can use the "fix" command filtering for bad blocks with
the -e, --filter-error options:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -e fix
</pre>
</td></tr></table>
<p>
At the next "scrub" the errors will disappear from the "status" report
if really fixed. To make it fast, you can use -p bad to scrub only blocks
marked as bad.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -p bad scrub
</pre>
</td></tr></table>
<p>
Take care that running "scrub" on a not synced array may result in
errors caused by removed or modified files. These errors are reported
in the "scrub" result, but related blocks are not marked as bad.
<h3><a name="4.2">4.2</a> 
Pooling
</h3>
To have all the files in your array shown in the same directory tree,
you can enable the "pooling" feature. It consists in creating a
read-only virtual view of all the files in your array using symbolic
links.
<p>
You can configure the "pooling" directory in the configuration file with:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
pool /pool
</pre>
</td></tr></table>
<p>
or, if you are in Windows, with:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
pool C:\pool
</pre>
</td></tr></table>
<p>
and then run the "pool" command to create or update the virtual view.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid pool
</pre>
</td></tr></table>
<p>
If you are using a Unix platform and you want to share such directory
in the network to either Windows or Unix machines, you should add
to your /etc/samba/smb.conf the following options:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# In the global section of smb.conf
unix extensions = no
</pre>
</td></tr></table>
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# In the share section of smb.conf
[pool]
comment = Pool
path = /pool
read only = yes
guest ok = yes
wide links = yes
follow symlinks = yes
</pre>
</td></tr></table>
<p>
In Windows the same sharing operation is not so straightforward,
because Windows shares the symbolic links as they are, and that
requires the network clients to resolve them remotely.
<p>
To make it working, besides sharing in the network the pool directory,
you must also share all the disks independently, using as share points
the disk names as defined in the configuration file. You must also specify in
the "share" option of the configure file, the Windows UNC path that remote
clients needs to use to access such shared disks.
<p>
For example, operating from a server named "darkstar", you can use
the options:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 F:\array\
data d2 G:\array\
data d3 H:\array\
pool C:\pool
share \\darkstar
</pre>
</td></tr></table>
<p>
and share the following dirs in the network:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
\\darkstar\pool -&gt; C:\pool
\\darkstar\d1 -&gt; F:\array
\\darkstar\d2 -&gt; G:\array
\\darkstar\d3 -&gt; H:\array
</pre>
</td></tr></table>
<p>
to allow remote clients to access all the files at \\darkstar\\pool.
<p>
You may also need to configure remote clients enabling access at remote
symlinks with the command:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
fsutil behavior set SymlinkEvaluation L2L:1 R2R:1 L2R:1 R2L:1
</pre>
</td></tr></table>
<h3><a name="4.3">4.3</a> 
Undeleting
</h3>
SnapRAID is more like a backup program than a RAID system, and it
can be used to restore or undelete files to their previous state using
the -f, --filter option :
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -f FILE
</pre>
</td></tr></table>
<p>
or for a directory:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -f DIR/
</pre>
</td></tr></table>
<p>
You can also use it to recover only accidentally deleted files inside
a directory using the -m, --filter-missing option, that restores
only missing files, leaving untouched all the others.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -m -f DIR/
</pre>
</td></tr></table>
<p>
Or to recover all the deleted files in all the drives with:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid fix -m
</pre>
</td></tr></table>
<h3><a name="4.4">4.4</a> 
Recovering
</h3>
The worst happened, and you lost one or more disks!
<p>
DO NOT PANIC! You will be able to recover them!
<p>
The first thing you have to do is to avoid further changes at your disk array.
Disable any remote connection to it, any scheduled process, including any
scheduled SnapRAID nightly sync or scrub.
<p>
Then proceed with the following steps.
<h4><a name="4.4.1">4.4.1</a> 
STEP 1 -&gt; Reconfigure
</h4>
You need some space to recover, even better if you already have additional
spare disks, but in case, also an external USB or remote disk is enough.
<p>
Change the SnapRAID configuration file to make the "data" or "parity"
option of the failed disk to point to the place where you have enough empty
space to recover the files.
<p>
For example, if you have that disk "d1" failed, you can change from:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 /mnt/disk1/
</pre>
</td></tr></table>
<p>
to:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
data d1 /mnt/new_spare_disk/
</pre>
</td></tr></table>
<p>
If the disk to recover is a parity disk, change the appropriate "parity"
option.
If you have more broken disks, change all their configuration options.
<h4><a name="4.4.2">4.4.2</a> 
STEP 2 -&gt; Fix
</h4>
Run the fix command, storing the log in an external file with:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -d NAME -l fix.log fix
</pre>
</td></tr></table>
<p>
Where NAME is the name of the disk, like "d1" as in our previous example.
In case the disk to recover is a parity disk, use the "parity", "2-parity"
names.
If you have more broken disks, use multiple -d options to specify all
of them.
<p>
This command will take a long time.
<p>
Take care that you need also few gigabytes free to store the fix.log file.
Run it from a disk with some free space.
<p>
Now you have recovered all the recoverable. If some file is partially or totally
unrecoverable, it will be renamed adding the ".unrecoverable" extension.
<p>
You can get a detailed list of all the unrecoverable blocks in the fix.log file
checking all the lines starting with "unrecoverable:"
<p>
If you are not satisfied of the recovering, you can retry it as many
time you wish.
<p>
For example, if you have removed files from the array after the last
"sync", this may result in some other files not recovered.
In this case, you can retry the "fix" using the -i, --import option,
specifying where these files are now, to include them again in the
recovering process.
<p>
If you are satisfied of the recovering, you can now proceed further,
but take care that after syncing you cannot retry the "fix" command
anymore!
<h4><a name="4.4.3">4.4.3</a> 
STEP 3 -&gt; Check
</h4>
As paranoid check, you can now run a "check" command to ensure that
everything is OK on the recovered disk.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid -d NAME -a check
</pre>
</td></tr></table>
<p>
Where NAME is the name of the disk, like "d1" as in our previous example.
<p>
The options -d and -a tell SnapRAID to check only the specified disk,
and ignore all the parity data.
<p>
This command will take a long time, but if you are not paranoid,
you can skip it.
<h4><a name="4.4.4">4.4.4</a> 
STEP 4 -&gt; Sync
</h4>
Run the "sync" command to re-synchronize the array with the new disk.
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
snapraid sync
</pre>
</td></tr></table>
<p>
If everything is recovered, this command is immediate.
<h2><a name="5">5</a> 
Commands
</h2>
SnapRAID provides a few simple commands that allow to:
<ul>
<li>
Prints the status of the array -&gt; "status"
</li>
<li>
Controls the disks -&gt; "smart", "up", "down"
</li>
<li>
Makes a backup/snapshot -&gt; "sync"
</li>
<li>
Periodically checks data -&gt; "scrub"
</li>
<li>
Restore the last backup/snapshot -&gt; "fix".
</li>
</ul>
<p>
Take care that the commands have to be written in lower case.
<h3><a name="5.1">5.1</a> 
status
</h3>
Prints a summary of the state of the disk array.
<p>
It includes information about the parity fragmentation, how old
are the blocks without checking, and all the recorded silent
errors encountered while scrubbing.
<p>
Note that the information presented refers at the latest time you
run "sync". Later modifications are not taken into account.
<p>
If bad blocks were detected, their block numbers are listed.
To fix them, you can use the "fix -e" command.
<p>
It also shows a graph representing the last time each block
was scrubbed or synced. Scrubbed blocks are shown with '*',
blocks synced but not yet scrubbed with 'o'.
<p>
Nothing is modified.
<h3><a name="5.2">5.2</a> 
smart
</h3>
Prints a SMART report of all the disks of the array.
<p>
It includes an estimation of the probability of failure in the next
year allowing to plan maintenance replacements of the disks that show
suspicious attributes.
<p>
This probability estimation obtained correlating the SMART attributes
of the disks, with the Backblaze data available at:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.backblaze.com/hard-drive-test-data.html
</pre>
</td></tr></table>
<p>
If SMART reports that a disk is failing, "FAIL" or "PREFAIL" is printed
for that disk, and SnapRAID returns with an error.
In this case an immediate replacement of the disk is highly recommended.
<p>
Other possible strings are:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
logfail
</em></td><td width="90%">
In the past some attributes were lower than
the threshold.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
logerr
</em></td><td width="90%">
The device error log contains errors.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
selferr
</em></td><td width="90%">
The device self-test log contains errors.
</td></tr>
</table>
<p>
If the -v, --verbose option is specified a deeper statistical analysis
is provided. This analysis can help you to decide if you need more
or less parity.
<p>
This command uses the "smartctl" tool, and it's equivalent to run
"smartctl -a" on all the devices.
<p>
If your devices are not auto-detected correctly, you can configure
a custom command using the "smartctl" option in the configuration
file.
<p>
Nothing is modified.
<h3><a name="5.3">5.3</a> 
up
</h3>
Spins up all the disks of the array.
<p>
You can spin-up only some specific disks using the -d, --filter-disk option.
<p>
Take care that spinning-up all the disks at the same time needs a lot of power.
Ensure that your power-supply can sustain that.
<p>
Nothing is modified.
<h3><a name="5.4">5.4</a> 
down
</h3>
Spins down all the disks of the array.
<p>
This command uses the "smartctl" tool, and it's equivalent to run
"smartctl -s standby,now" on all the devices.
<p>
You can spin-down only some specific disks using the -d, --filter-disk option.
<p>
Nothing is modified.
<h3><a name="5.5">5.5</a> 
diff
</h3>
Lists all the files modified from the last "sync" that need to have
their parity data recomputed.
<p>
This command doesn't check the file data, but only the file time-stamp
size and inode.
<p>
At the end of the command, you'll get a summary of the file changes
grouped by:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
equal
</em></td><td width="90%">
Files equal at before.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
added
</em></td><td width="90%">
Files added that were not present before.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
removed
</em></td><td width="90%">
Files removed.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
updated
</em></td><td width="90%">
Files with a different size or time-stamp, meaning that
they were modified.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
moved
</em></td><td width="90%">
Files moved to a different directory of the same disk.
They are identified by having the same name, size, time-stamp
and inode, but different directory.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
copied
</em></td><td width="90%">
Files copied in the same or different disk. Note that if in
true they are moved to a different disk, you'll also have
them counted in "removed".
They are identified by having the same name, size, and
time-stamp. But if the sub-second time-stamp is zero,
then the full path should match, and not only the name.
</td></tr>
<tr valign="top" align="left"><td width="5%"></td><td width="5%"><em>
restored
</em></td><td width="90%">
Files with a different inode but with name, size and time-stamp
matching. These are usually files restored after being deleted.
</td></tr>
</table>
<p>
If a "sync" is required, the process return code is 2, instead of the
default 0. The return code 1 is instead for a generic error condition.
<p>
Nothing is modified.
<h3><a name="5.6">5.6</a> 
sync
</h3>
Updates the parity information. All the modified files
in the disk array are read, and the corresponding parity
data is updated.
<p>
You can stop this process at any time pressing Ctrl+C,
without losing the work already done.
At the next run the "sync" process will start where
interrupted.
<p>
If during the process, silent or input/output errors are found,
the corresponding blocks are marked as bad.
<p>
Files are identified by path and/or inode and checked by
size and time-stamp.
If the file size or time-stamp are different, the parity data
is recomputed for the whole file.
If the file is moved or renamed in the same disk, keeping the
same inode, the parity is not recomputed.
If the file is moved to another disk, the parity is recomputed,
but the previously computed hash information is kept.
<p>
The "content" and "parity" files are modified if necessary.
The files in the array are NOT modified.
<h3><a name="5.7">5.7</a> 
scrub
</h3>
Scrubs the array, checking for silent or input/output errors in data
and parity disks.
<p>
For each command invocation, about the 8% of the array is checked, but
nothing that was already scrubbed in the last 10 days.
This means that scrubbing once a week, every bit of data is checked
at least one time every three months.
<p>
You can define a different scrub plan or amount using the -p, --plan
option that takes as argument:
bad - Scrub blocks marked bad.
new - Scrub just synced blocks not yet scrubbed.
full - Scrub everything.
0-100 - Scrub the exact percentage of blocks.
<p>
If you specify a percentage amount, you can also use the -o, --older-than
option to define how old the block should be.
The oldest blocks are scrubbed first ensuring an optimal check.
If instead you want to scrub the just synced blocks, not yet scrubbed,
you should use the "-p new" option.
<p>
To get the details of the scrub status use the "status" command.
<p>
For any silent or input/output error found the corresponding blocks
are marked as bad in the "content" file.
These bad blocks are listed in "status", and can be fixed with "fix -e".
After the fix, at the next scrub they will be rechecked, and if found
corrected, the bad mark will be removed.
To scrub only the bad blocks, you can use the "scrub -p bad" command.
<p>
It's recommended to run "scrub" only on a synced array, to avoid to
have reported error caused by unsynced data. These errors are recognized
as not being silent errors, and the blocks are not marked as bad,
but such errors are reported in the output of the command.
<p>
Files are identified only by path, and not by inode.
<p>
The "content" file is modified to update the time of the last check
of each block, and to mark bad blocks.
The "parity" files are NOT modified.
The files in the array are NOT modified.
<h3><a name="5.8">5.8</a> 
fix
</h3>
Fix all the files and the parity data.
<p>
All the files and the parity data are compared with the snapshot
state saved in the last "sync".
If a difference is found, it's reverted to the stored snapshot.
<p>
The "fix" command doesn't differentiate between errors and
intentional modifications. It unconditionally reverts the file state
at the last "sync".
<p>
If no other option is specified the full array is processed.
Use the filter options to select a subset of files or disks to operate on.
<p>
To only fix the blocks marked bad during "sync" and "scrub",
use the -e, --filter-error option.
As difference from other filter options, with this one the fixes are
applied only to files that are not modified from the latest "sync".
<p>
All the files that cannot be fixed are renamed adding the
".unrecoverable" extension.
<p>
Before fixing, the full array is scanned to find any moved file,
after the last "sync" operation.
These files are identified by their time-stamp, ignoring their name
and directory, and are used in the recovering process if necessary.
If you moved some of them outside the array, you can use the -i, --import
option to specify additional directories to scan.
<p>
Files are identified only by path, and not by inode.
<p>
The "content" file is NOT modified.
The "parity" files are modified if necessary.
The files in the array are modified if necessary.
<h3><a name="5.9">5.9</a> 
check
</h3>
Verify all the files and the parity data.
<p>
It works like "fix", but it only simulates a recovery and no change
is written in the array.
<p>
This command is mostly intended for manual verification,
like after a recovery process or in other special conditions.
For periodic and scheduled checks uses "scrub".
<p>
If you use the -a, --audit-only option, only the file
data is checked, and the parity data is ignored for a
faster run.
<p>
Files are identified only by path, and not by inode.
<p>
Nothing is modified.
<h3><a name="5.10">5.10</a> 
list
</h3>
Lists all the files contained in the array at the time of the
last "sync".
<p>
Nothing is modified.
<h3><a name="5.11">5.11</a> 
dup
</h3>
Lists all the duplicate files. Two files are assumed equal if their
hashes are matching. The file data is not read, but only the
pre-computed hashes are used.
<p>
Nothing is modified.
<h3><a name="5.12">5.12</a> 
pool
</h3>
Creates or updates in the "pooling" directory a virtual view of all
the files of your disk array.
<p>
The files are not really copied here, but just linked using
symbolic links.
<p>
When updating, all the present symbolic links and empty
sub-directories are deleted and replaced with the new
view of the array. Any other regular file is left in place.
<p>
Nothing is modified outside the pool directory.
<h3><a name="5.13">5.13</a> 
devices
</h3>
Prints the low level devices used by the array.
<p>
This command prints the devices associations in place in the array,
and it's mainly intended as a script interface.
<p>
The first two columns are the low level device id and path.
The next two columns are the high level device id and path.
The latest column if the disk name in the array.
<p>
In most cases you have one low level device for each disk in the
array, but in some more complex configurations, you may have multiple
low level devices used by a single disk in the array.
<p>
Nothing is modified.
<h3><a name="5.14">5.14</a> 
touch
</h3>
Sets arbitrarily the sub-second time-stamp of all the files
that have it at zero.
<p>
This improves the SnapRAID capability to recognize moved
and copied files as it makes the time-stamp almost unique,
removing possible duplicates.
<p>
More specifically, if the sub-second time-stamp is not zero,
a moved or copied file is identified as such if it matches
the name, size and time-stamp. If instead the sub-second time-stamp
is zero, it's considered a copy only if it matches the full path,
size and time-stamp.
<p>
Note that the second precision time-stamp is not modified,
and all the dates and times of your files will be maintained.
<h3><a name="5.15">5.15</a> 
rehash
</h3>
Schedules a rehash of the whole array.
<p>
This command changes the hash kind used, typically when upgrading
from a 32 bits system to a 64 bits one, to switch from
MurmurHash3 to the faster SpookyHash.
<p>
If you are already using the optimal hash, this command
does nothing and tells you that nothing has to be done.
<p>
The rehash isn't done immediately, but it takes place
progressively during "sync" and "scrub".
<p>
You can get the rehash state using "status".
<p>
During the rehash, SnapRAID maintains full functionality,
with the only exception of "dup" not able to detect duplicated
files using a different hash.
<h2><a name="6">6</a> 
Options
</h2>
SnapRAID provides the following options:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-c, --conf CONFIG
</strong></td></tr><tr><td>
Selects the configuration file to use. If not specified in Unix
it's used the file "/usr/local/etc/snapraid.conf" if it exists,
or "/etc/snapraid.conf" otherwise.
In Windows it's used the file "snapraid.conf" in the same
directory of "snapraid.exe".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-f, --filter PATTERN
</strong></td></tr><tr><td>
Filters the files to process in "check" and "fix".
Only the files matching the entered pattern are processed.
This option can be used many times.
See the PATTERN section for more details in the
pattern specifications.
In Unix, ensure to quote globbing chars if used.
This option can be used only with "check" and "fix".
Note that it cannot be used with "sync" and "scrub", because they always
process the whole array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-d, --filter-disk NAME
</strong></td></tr><tr><td>
Filters the disks to process in "check", "fix", "up" and "down".
You must specify a disk name as named in the configuration
file.
You can also specify parity disks with the names: "parity", "2-parity",
"3-parity", ... to limit the operations a specific parity disk.
If you combine more --filter, --filter-disk and --filter-missing options,
only files matching all the set of filters are selected.
This option can be used many times.
This option can be used only with "check", "fix", "up" and "down".
Note that it cannot be used with "sync" and "scrub", because they always
process the whole array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-m, --filter-missing
</strong></td></tr><tr><td>
Filters the files to process in "check" and "fix".
Only the files missing/deleted from the array are processed.
When used with "fix", this is a kind of "undelete" command.
If you combine more --filter, --filter-disk and --filter-missing options,
only files matching all the set of filters are selected.
This option can be used only with "check" and "fix".
Note that it cannot be used with "sync" and "scrub", because they always
process the whole array.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-e, --filter-error
</strong></td></tr><tr><td>
Process the files with errors in "check" and "fix".
It processes only files that have blocks marked with silent
or input/output errors during "sync" and "scrub", and listed in "status".
This option can be used only with "check" and "fix".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-p, --plan PERC|bad|new|full
</strong></td></tr><tr><td>
Selects the scrub plan. If PERC is a numeric value from 0 to 100,
it's interpreted as the percentage of blocks to scrub.
Instead of a percentage, you can also specify a plan:
"bad" scrubs bad blocks, "new" the blocks not yet scrubbed,
and "full" for everything.
This option can be used only with "scrub".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-o, --older-than DAYS
</strong></td></tr><tr><td>
Selects the older the part of the array to process in "scrub".
DAYS is the minimum age in days for a block to be scrubbed,
default is 10.
Blocks marked as bad are always scrubbed despite this option.
This option can be used only with "scrub".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-a, --audit-only
</strong></td></tr><tr><td>
In "check" verifies the hash of the files without
doing any kind of check on the parity data.
If you are interested in checking only the file data this
option can speedup a lot the checking process.
This option can be used only with "check".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-h, --pre-hash
</strong></td></tr><tr><td>
In "sync" runs a preliminary hashing phase of all the new data
to have an additional verification before the parity computation.
Usually in "sync" no preliminary hashing is done, and the new
data is hashed just before the parity computation when it's read
for the first time.
Unfortunately, this process happens when the system is under
heavy load, with all disks spinning and with a busy CPU.
This is an extreme condition for the machine, and if it has a
latent hardware problem, it's possible to encounter silent errors
what cannot be detected because the data is not yet hashed.
To avoid this risk, you can enable the "pre-hash" mode and have
all the data read two times to ensure its integrity.
This option also verifies the files moved inside the array,
to ensure that the move operation went successfully, and in case
to block the sync and to allow to run a fix operation.
This option can be used only with "sync".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-i, --import DIR
</strong></td></tr><tr><td>
Imports from the specified directory any file that you deleted
from the array after the last "sync".
If you still have such files, they could be used by "check"
and "fix" to improve the recover process.
The files are read also in sub-directories and they are
identified regardless of their name.
This option can be used only with "check" and "fix".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-Z, --force-zero
</strong></td></tr><tr><td>
Forces the insecure operation of syncing a file with zero
size that before was not.
If SnapRAID detects a such condition, it stops proceeding
unless you specify this option.
This allows to easily detect when after a system crash,
some accessed files were truncated.
This is a possible condition in Linux with the ext3/ext4
file-systems.
This option can be used only with "sync".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-E, --force-empty
</strong></td></tr><tr><td>
Forces the insecure operation of syncing a disk with all
the original files missing.
If SnapRAID detects that all the files originally present
in the disk are missing or rewritten, it stops proceeding
unless you specify this option.
This allows to easily detect when a data file-system is not
mounted.
This option can be used only with "sync".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-U, --force-uuid
</strong></td></tr><tr><td>
Forces the insecure operation of syncing, checking and fixing
with disks that have changed their UUID.
If SnapRAID detects that some disks have changed UUID,
it stops proceeding unless you specify this option.
This allows to detect when your disks are mounted in the
wrong mount points.
It's anyway allowed to have a single UUID change with
single parity, and more with multiple parity, because it's
the normal case of replacing disks after a recovery.
This option can be used only with "sync", "check" or
"fix".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-D, --force-device
</strong></td></tr><tr><td>
Forces the insecure operation of fixing with inaccessible disks,
or with disks on the same physical device.
Like if you lost two data disks, and you have a spare disk to recover
only the first one, and you want to ignore the second inaccessible disk.
Or if you want to recover a disk in the free space left in an
already used disk, sharing the same physical device.
This option can be used only with "fix".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-N, --force-nocopy
</strong></td></tr><tr><td>
In "sync", "check and "fix", disables the copy detection heuristic.
Without this option SnapRAID assumes that files with same
attributes, like name, size and time-stamp are copies with the
same data.
This allows to identify copied or moved files from one disk
to another, and to reuse the already computed hash information
to detect silent errors or to recover missing files.
This behavior, in some rare cases, may result in false positives,
or in a slow process due the many hash verification, and this
option allows to resolve them.
This option can be used only with "sync", "check" and "fix".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-F, --force-full
</strong></td></tr><tr><td>
In "sync" forces a full recomputation of the parity.
This option can be used when you add a new parity level, or if
you reverted back to an old content file using a more recent parity data.
Instead of recreating the parity from scratch, this allows
to reuse the hashes present in the content file to validate data,
and to maintain data protection during the "sync" process using
the parity data you have.
This option can be used only with "sync".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-R, --force-realloc
</strong></td></tr><tr><td>
In "sync" forces a full reallocation of files and rebuild of the parity.
This option can be used to completely reallocate all the files
removing the fragmentation, but reusing the hashes present in the content
file to validate data.
This option can be used only with "sync".
WARNING! This option is for experts only, and it's highly
recommended to not use it.
You DO NOT have data protection during the "sync" operation.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-l, --log FILE
</strong></td></tr><tr><td>
Write a detailed log in the specified file.
If this option is not specified, unexpected errors are printed
on the screen, likely resulting in too much output in case of
many errors. When -l, --log is specified, on the screen, go only
fatal errors that makes SnapRAID to stop progress.
If the path starts with '&gt;&gt;' the file is opened
in append mode. Occurrences of '%D' and '%T' in the name are
replaced with the date and time in the format YYYYMMDD and
HHMMSS. Note that in Windows batch files, you'll have to double
the '%' char, like result-%%D.log. And to use '&gt;&gt;' you'll have
to enclose the name in ", like "&gt;&gt;result.log".
To output the log to standard output or standard error,
you can use respectively "&gt;&amp;1" and "&gt;&amp;2".
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-L, --error-limit
</strong></td></tr><tr><td>
Sets a new error limit before stopping execution.
By default SnapRAID stops if it encounters more than 100
Input/Output errors, meaning that likely a disk is going to
die.
This options affects "sync" and "scrub", that are allowed
to continue after the first bunch of disk errors, to try
to complete at most their operations.
Instead, "check" and "fix" always stop at the first error.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-S, --start BLKSTART
</strong></td></tr><tr><td>
Starts the processing from the specified
block number. It could be useful to retry to check
or fix some specific block, in case of a damaged disk.
It's present mainly for advanced manual recovering.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-B, --count BLKCOUNT
</strong></td></tr><tr><td>
Processes only the specified number of blocks.
It's present mainly for advanced manual recovering.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-C, --gen-conf CONTENT_FILE
</strong></td></tr><tr><td>
Generates a dummy configuration file from an existing
content file.
The configuration file is written in the standard output,
and it doesn't overwrite an existing one.
This configuration file also contains the information
needed to reconstruct the disk mount points, in case you
lose the entire system.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-v, --verbose
</strong></td></tr><tr><td>
Prints more information on the screen.
If specified one time, it prints excluded files
and more stats.
This option has no effect on the log files.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-q, --quiet
</strong></td></tr><tr><td>
Prints less information on the screen.
If specified one time, removes the progress bar, if two
times, the running operations, three times, the info
messages, four times the status messages.
Fatal errors are always printed on the screen.
This option has no effect on the log files.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-H, --help
</strong></td></tr><tr><td>
Prints a short help screen.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
-V, --version
</strong></td></tr><tr><td>
Prints the program version.
</td></tr>
</table>
<h2><a name="7">7</a> 
Configuration
</h2>
SnapRAID requires a configuration file to know where your disk array
is located, and where storing the parity information.
<p>
In Unix it's used the file "/usr/local/etc/snapraid.conf" if it exists,
or "/etc/snapraid.conf" otherwise.
In Windows it's used the file "snapraid.conf" in the same
directory of "snapraid.exe".
<p>
It should contain the following options (case sensitive):
<h3><a name="7.1">7.1</a> 
parity FILE [,FILE] ...
</h3>
Defines the files to use to store the parity information.
The parity enables the protection from a single disk
failure, like RAID5.
<p>
You can specify multiples files that should be in different disks.
When a file cannot grow anymore, the next one is used.
The total space available must be as big as the biggest data disk in
the array.
<p>
You can add additional parity files at later time, but you
cannot reorder or remove them.
<p>
Leaving the parity disks reserved for parity ensures that
it doesn't get fragmented, improving the performance.
<p>
In Windows 256 MB are left unused in each disk to avoid the
warning about full disks.
<p>
This option is mandatory and it can be used only one time.
<h3><a name="7.2">7.2</a> 
(2,3,4,5,6)-parity FILE [,FILE] ...
</h3>
Defines the files to use to store extra parity information.
<p>
For each parity specified, one additional level of protection
is enabled:
<ul>
<li>
2-parity enables RAID6 dual parity.
</li>
<li>
3-parity enables triple parity
</li>
<li>
4-parity enables quad (four) parity
</li>
<li>
5-parity enables penta (five) parity
</li>
<li>
6-parity enables hexa (six) parity
</li>
</ul>
<p>
Each parity level requires the presence of all the previous parity
levels.
<p>
The same considerations of the 'parity' option apply.
<p>
These options are optional and they can be used only one time.
<h3><a name="7.3">7.3</a> 
z-parity FILE [,FILE] ...
</h3>
Defines an alternate file and format to store the triple parity.
<p>
This option is an alternative at '3-parity' mainly intended for
low-end CPUs like ARM or AMD Phenom, Athlon and Opteron that don't
support the SSSE3 instructions set. In such cases it provides
a better performance.
<p>
This format is similar, but faster, at the one used by the ZFS RAIDZ3.
Like ZFS, it doesn't work beyond triple parity.
<p>
When using '3-parity' you will be warned if it's recommended to use
the 'z-parity' format for a performance improvement.
<p>
It's possible to convert from one format to another, adjusting
the configuration file with the wanted z-parity or 3-parity file,
and using 'fix' to recreate it.
<h3><a name="7.4">7.4</a> 
content FILE
</h3>
Defines the file to use to store the list and check-sums of all the
files present in your disk array.
<p>
It can be placed in the disk used to store data, parity, or
any other disk available.
If you use a data disk, this file is automatically excluded
from the "sync" process.
<p>
This option is mandatory and it can be used more times to save
more copies of the same files.
<p>
You have to store at least one copy for each parity disk used
plus one. Using some more doesn't hurt.
<h3><a name="7.5">7.5</a> 
data NAME DIR
</h3>
Defines the name and the mount point of the data disks of
the array. NAME is used to identify the disk, and it must
be unique. DIR is the mount point of the disk in the
file-system.
<p>
You can change the mount point as you like, as long you
keep the NAME fixed.
<p>
You should use one option for each data disk of the array.
<p>
You can rename later a disk, changing the NAME directly
in the configuration file, and then run a 'sync' command.
In the rename case, the association is done using the stored
UUID of the disks.
<h3><a name="7.6">7.6</a> 
nohidden
</h3>
Excludes all the hidden files and directory.
In Unix hidden files are the ones starting with ".".
In Windows they are the ones with the hidden attribute.
<h3><a name="7.7">7.7</a> 
exclude/include PATTERN
</h3>
Defines the file or directory patterns to exclude and include
in the sync process.
All the patterns are processed in the specified order.
<p>
If the first pattern that matches is an "exclude" one, the file
is excluded. If it's an "include" one, the file is included.
If no pattern matches, the file is excluded if the last pattern
specified is an "include", or included if the last pattern
specified is an "exclude".
<p>
See the PATTERN section for more details in the pattern
specifications.
<p>
This option can be used many times.
<h3><a name="7.8">7.8</a> 
blocksize SIZE_IN_KIBIBYTES
</h3>
Defines the basic block size in kibi bytes of the parity.
One kibi bytes is 1024 bytes.
<p>
The default blocksize is 256 and it should work for most cases.
<p>
WARNING! This option is for experts only, and it's highly
recommended to not change it. To change again this value in
future you'll have to recreate the whole parity!
<p>
A reason to use a different blocksize is if you have a lot of small
files. In the order of many millions.
<p>
For each file, even of few bytes, a whole block of parity is allocated,
and with many files this may result in a lot of unused parity space.
And when you completely fill the parity disk, you are not
allowed to add more files in the data disks.
Anyway, the wasted parity doesn't sum between data disks. Wasted space
resulting from a high number of files in a data disk, limits only
the amount of data in such data disk and not in others.
<p>
As approximation, you can assume that half of the block size is
wasted for each file. For example, with 100000 files and a 256 KiB
block size, you are going to waste 13 GB of parity, that may result
in 13 GB less space available in the data disk.
<p>
You can get the amount of wasted space in each disk using "status".
This is the amount of space that you must leave free in the data
disks, or use for files not included in the array.
If this value is negative, it means that your are near to fill
the parity, and it represents the space you can still waste.
<p>
To avoid the problem, you can use a bigger partition for parity.
For example, if you have the parity partition bigger than 13 GB
than data disks, you have enough extra space to handle up to 100000
files in each data disk.
<p>
A trick to get a bigger parity partition in Linux, is to format it
with the command:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
mkfs.ext4 -m 0 -T largefile4 DEVICE
</pre>
</td></tr></table>
<p>
This results in about 1.5% of extra space. Meaning about 60 GB for
a 4 TB disk, that allows about 460000 files in each data disk without
any wasted space.
<h3><a name="7.9">7.9</a> 
hashsize SIZE_IN_BYTES
</h3>
Defines the hash size in bytes of the saved blocks.
<p>
The default hashsize is 16 bytes (128 bits), and it should work
for most cases.
<p>
WARNING! This option is for experts only, and it's highly
recommended to not change it. To change again this value in
future you'll have to recreate the whole parity!
<p>
A reason to use a different hashsize is if your system has
small memory. As a rule of thumb SnapRAID usually requires
1 GiB of RAM memory for each 16 TB of data in the array.
<p>
Specifically, to store the hashes of the data, SnapRAID requires
about TS*(1+HS)/BS bytes of RAM memory.
Where TS is the total size in bytes of your disk array, BS is the
block size in bytes, and HS is the hash size in bytes.
<p>
For example with 8 disks of 4 TB and a block size of 256 KiB
(1 KiB = 1024 bytes), and an hash size of 16, you get:
<p>
<pre>
RAM = (8 * 4 * 10^12) * (1+16) / (256 * 2^10) = 1.93 GiB
</pre>
<p>
Switching to a hash size of 8, you get:
<p>
<pre>
RAM = (8 * 4 * 10^12) * (1+8) / (256 * 2^10) = 1.02 GiB
</pre>
<p>
Switching to a block size of 512, you get:
<p>
<pre>
RAM = (8 * 4 * 10^12) * (1+16) / (512 * 2^10) = 0.96 GiB
</pre>
<p>
Switching to both a hash size of 8, and a block size of 512 you get:
<p>
<pre>
RAM = (8 * 4 * 10^12) * (1+8) / (512 * 2^10) = 0.51 GiB
</pre>
<h3><a name="7.10">7.10</a> 
autosave SIZE_IN_GIGABYTES
</h3>
Automatically save the state when syncing or scrubbing after the specified amount
of GB processed.
This option is useful to avoid to restart from scratch long "sync"
commands interrupted by a machine crash, or any other event that
may interrupt SnapRAID.
<h3><a name="7.11">7.11</a> 
pool DIR
</h3>
Defines the pooling directory where the virtual view of the disk
array is created using the "pool" command.
<p>
The directory must already exist.
<h3><a name="7.12">7.12</a> 
share UNC_DIR
</h3>
Defines the Windows UNC path required to access the disks remotely.
<p>
If this option is specified, the symbolic links created in the pool
directory use this UNC path to access the disks.
Without this option the symbolic links generated use only local paths,
not allowing to share the pool directory in the network.
<p>
The symbolic links are formed using the specified UNC path, adding the
disk name as specified in the "disk" option, and finally adding the
file dir and name.
<p>
This option is only required for Windows.
<h3><a name="7.13">7.13</a> 
smartctl DISK/PARITY OPTIONS...
</h3>
Defines a custom smartctl command to obtain the SMART attributes
for each disk. This may be required for RAID controllers and for
some USB disk that cannot be auto-detected.
<p>
DISK is the same disk name specified in the "disk" option.
PARITY is one of the parity name as "parity,(1,2,3,4,5,6,z)-parity".
<p>
In the specified OPTIONS, the "%s" string is replaced by the
device name. Note that in case of RAID controllers the device is likely
fixed, and you don't have to use "%s".
<p>
Refers at the smartmontools documentation about the possible options:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
https://www.smartmontools.org/wiki/Supported_RAID-Controllers
https://www.smartmontools.org/wiki/Supported_USB-Devices
</pre>
</td></tr></table>
<h3><a name="7.14">7.14</a> 
Examples
</h3>
An example of a typical configuration for Unix is:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity /mnt/diskp/snapraid.parity
content /mnt/diskp/snapraid.content
content /var/snapraid/snapraid.content
data d1 /mnt/disk1/
data d2 /mnt/disk2/
data d3 /mnt/disk3/
exclude /lost+found/
exclude /tmp/
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/sg0
smartctl 2-parity -d areca,2/1 /dev/sg0
</pre>
</td></tr></table>
<p>
An example of a typical configuration for Windows is:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
parity E:\snapraid.parity
content E:\snapraid.content
content C:\snapraid\snapraid.content
data d1 G:\array\
data d2 H:\array\
data d3 I:\array\
exclude Thumbs.db
exclude \$RECYCLE.BIN
exclude \System Volume Information
smartctl d1 -d sat %s
smartctl d2 -d usbjmicron %s
smartctl parity -d areca,1/1 /dev/arcmsr0
smartctl 2-parity -d areca,2/1 /dev/arcmsr0
</pre>
</td></tr></table>
<h2><a name="8">8</a> 
Pattern
</h2>
Patterns are used to select a subset of files to exclude or include in
the process.
<p>
There are four different types of patterns:
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
FILE
</strong></td></tr><tr><td>
Selects any file named as FILE. You can use any globbing
character like * and ?, and char classes like [a-z].
This pattern is applied only to files and not to directories.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
DIR/
</strong></td></tr><tr><td>
Selects any directory named DIR and everything inside.
You can use any globbing character like * and ?.
This pattern is applied only to directories and not to files.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
/PATH/FILE
</strong></td></tr><tr><td>
Selects the exact specified file path. You can use any
globbing character like * and ? but they never match a
directory slash.
This pattern is applied only to files and not to directories.
</td></tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tr valign="top" align="left"><td><strong>
/PATH/DIR/
</strong></td></tr><tr><td>
Selects the exact specified directory path and everything
inside. You can use any globbing character like * and ? but
they never match a directory slash.
This pattern is applied only to directories and not to files.
</td></tr>
</table>
<p>
Note that when you specify an absolute path starting with /, it's
applied at the array root dir and not at the local file-system root dir.
<p>
In Windows you can use the backslash \ instead of the forward slash /.
Note that Windows system directories, junctions, mount points, and any
other Windows special directory are treated just as files, meaning that
to exclude them you must use a file rule, and not a directory one.
<p>
If the file name you want to use really contains a '*', '?', '[',
or ']' char, you have to escape it to avoid to have interpreted as a
globbing character. In Unix the escape char is '\', in Windows it's '^'.
Note that when the pattern is on the command line, you have to double the
escape character to avoid to have it interpreted by the command shell.
<p>
In the configuration file, you can use different strategies to filter
the files to process.
The simplest one is to use only "exclude" rules to remove all the
files and directories you do not want to process. For example:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Excludes any file named "*.unrecoverable"
exclude *.unrecoverable
# Excludes the root directory "/lost+found"
exclude /lost+found/
# Excludes any sub-directory named "tmp"
exclude tmp/
</pre>
</td></tr></table>
<p>
The opposite way is to define only the file you want to process, using
only "include" rules. For example:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Includes only some directories
include /movies/
include /musics/
include /pictures/
</pre>
</td></tr></table>
<p>
The final way, is to mix "exclude" and "include" rules. In this case take
care that the order of rules is important. Previous rules have the
precedence over the later ones.
To get things simpler you can first have all the "exclude" rules and then
all the "include" ones. For example:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Excludes any file named "*.unrecoverable"
exclude *.unrecoverable
# Excludes any sub-directory named "tmp"
exclude tmp/
# Includes only some directories
include /movies/
include /musics/
include /pictures/
</pre>
</td></tr></table>
<p>
On the command line, using the -f option, you can only use "include"
patterns. For example:
<p>
<table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td width="5%"></td><td width="95%">
<pre>
# Checks only the .mp3 files.
# Note the "" use to avoid globbing expansion by the shell in Unix.
snapraid -f "*.mp3" check
</pre>
</td></tr></table>
<p>
In Unix, when using globbing chars in the command line, you have to
quote them. Otherwise the shell will try to expand them.
<h2><a name="9">9</a> 
Content
</h2>
SnapRAID stores the list and check-sums of your files in the content file.
<p>
It's a binary file, listing all the files present in your disk array,
with all the check-sums to verify their integrity.
<p>
This file is read and written by the "sync" and "scrub" commands, and
read by "fix", "check" and "status".
<h2><a name="10">10</a> 
Parity
</h2>
SnapRAID stores the parity information of your array in the parity
files.
<p>
They are binary files, containing the computed parity of all the
blocks defined in the "content" file.
<p>
These files are read and written by the "sync" and "fix" commands, and
only read by "scrub" and "check".
<h2><a name="11">11</a> 
Encoding
</h2>
SnapRAID in Unix ignores any encoding. It reads and stores the
file names with the same encoding used by the file-system.
<p>
In Windows all the names read from the file-system are converted and
processed in the UTF-8 format.
<p>
To have the file names printed correctly you have to set the Windows
console in the UTF-8 mode, with the command "chcp 65001", and use
a TrueType font like "Lucida Console" as console font.
Note that it has effect only on the printed file names, if you
redirect the console output to a file, the resulting file is always
in the UTF-8 format.



</div>

<div id="footer">

<div class="column">
<span class="bold">Donate with</span>
<br>
<!--
<a href="http://sourceforge.net/p/snapraid/donate/"><img src="paypal.png" width="160" height="60" alt="PayPal"></a>
-->
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=amadvance%40gmail%2ecom&lc=US&item_name=SnapRAID&no_note=0&currency_code=USD&bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHostedGuest"><img src="paypal.png" width="160" height="60" alt="PayPal"></a>
<!--
<a href="https://coinkite.com/u/amadvance/"><img src="bitcoin.png" width="160" height="60" alt="BitCoin"></a>
-->
</div>

<div class="column">
<span class="bold">Find other resources at</span>
<br>
<a href="https://github.com/amadvance/snapraid/"><img src="github.png" width="160" height="60" alt="GitHub"></a>
<a href="http://sourceforge.net/projects/snapraid/"><img src="sourceforge.png" width="115" height="60" alt="SourceForge"></a>
</div>

</div>
</body>
</html>


